function PSF= GREIT_desired_img_FEMmesh(xyc, radius, opt)
%GREIT_DESIRED_IMG_FEMmesh  GREIT onto a FEM mesh
% PSF= GREIT_desired_img_FEMmesh(xyc, radius, opt)
%   xyc     - array of point centers [2xNpoints]
%   radius  - the radius of the target on the desired image as a fraction
%             of the model radius (half the larger dimension in xy)
%   opt     - a struct with these mandatory fields:
%      .rec_model   a 2D model as generated by MK_GRID_MODEL, with some
%                   restrictions, see below. 
%
% Generates the GREIT "desired img" mapped onto the centres
%   of the elements specified in opt.rec_model. It is assumed
%   the radius is larger than the element size, so only the
%   element centres are relevant
%
% See also: CALC_GREIT_RM, MK_GREIT_MODEL, MK_PIXEL_SLICE, 
%           GREIT_DESIRED_IMG_SIGMOID GREIT_DESIRED_IMG_ORIGINAL

% (C) 2009-2015 Andy Adler and Bartlomiej Grychtol. 
% License: GPL v2 or v3
% $Id$
   if ischar(xyc) && strcmp(xyc,'UNIT_TEST'); do_unit_test; return; end

   copt.fstr = 'GREIT_desired_img_FEMmesh';
   copt.cache_obj = {xyc, radius, opt};
   PSF = eidors_cache(@desired_soln,{xyc, radius, opt},copt);
end

function PSF = desired_soln(xyc,radius,opt)
   
   opt.inside = opt.rec_model.inside;
   mxyc = interp_mesh(opt.rec_model); x=mxyc(:,1); y=mxyc(:,2);
   xmin = opt.meshsz(1); xmax = opt.meshsz(2);
   ymin = opt.meshsz(3); ymax = opt.meshsz(4);
   % scale radius to half the greater dimension
   radius = radius * 0.5 * max(xmax-xmin, ymax-ymin);
   PSF = zeros(size(x,1),size(xyc,2));
   x_spc = (xmax-xmin)/(opt.imgsz(1)-1) * 0.5;
   y_spc = (ymax-ymin)/(opt.imgsz(2)-1) * 0.5;
   for i=1:size(xyc,2);
      for dx = linspace(-x_spc, x_spc, 5)
         for dy = linspace(-y_spc, y_spc, 5)
            PSF(:,i) = PSF(:,i) +  1/25*( ...
               (dx+x(:)-xyc(1,i)).^2 + (dy+y(:)-xyc(2,i)).^2 ...
                        < radius^2 );
         end
      end
%     PSF(:,i) = PSF(:,i)/sum(PSF(:,i));
   end
   PSF = PSF(opt.inside,:);
end

function do_unit_test
   img=mk_image(mk_common_model('d2c2',32)); vh=fwd_solve(img);
   img.elem_data(206)=1.1;                    vi=fwd_solve(img);

   fm = ng_mk_cyl_models(0.2,[32,0.1],[0.05]);
   fm.stimulation = mk_stim_patterns(32,1,[0,1],[0,1],{},1);
   imdl= eidors_obj('inv_model','','fwd_model',fm);
   imdl.jacobian_bkgnd.value = 1;
   opt.desired_solution_fn = @GREIT_desired_img_original;
   imdl  = mk_GREIT_model(imdl,0.20,1e1,opt);
   imgr = inv_solve(imdl,vh,vi); subplot(121); show_fem(imgr);
   disp(calc_noise_figure(imdl,vh,vi))

   [~,idx] = sort(-imgr.elem_data);
   unit_test_cmp('[...]_img_original',idx(1:10), ...
         [365 366 333 334 398 397 364 367 332 399]');

   imdl.rec_model = img.fwd_model;
   imdl.rec_model.inside = true(num_elems(img),1);
   opt.desired_solution_fn = @GREIT_desired_img_FEMmesh;
   imdl  = mk_GREIT_model(imdl,0.20,1e1,opt);
   imgr = inv_solve(imdl,vh,vi); subplot(122); show_fem(imgr);
   disp(calc_noise_figure(imdl,vh,vi))

   [~,idx] = sort(-imgr.elem_data);
   unit_test_cmp('[...]_img_FEMmesh',idx(1:10), ...
         [235 206 267 236 178 301 205 268 152 300]');

end
