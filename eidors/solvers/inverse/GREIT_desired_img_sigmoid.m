function PSF = GREIT_desired_img_sigmoid(xyz,radius, opt)
%GREIT_DESIRED_IMG_SIGMOID sigmoid-decay desired image function for GREIT 
% PSF= GREIT_desired_img_sigmoid(xyc, radius, opt)
%   xyz     - array of centers of desired target images
%               [2xN] - xy only
%               [3xN] - xyz or, if radius = [], xyr
%               [4xN] - xyzr (radius is ignored)
%   radius  - the radius of the target on the desired image as a fraction
%             of the model radius (half the larger dimension in xy)
%   opt     - a struct with these fields:
%      .rec_model   a 2D or 3D model as generated by MK_GRID_MODEL that may
%                   have had some pixels/voxels removed (a rec_model that 
%                   is not a complete rectangle/parallelepiped). 
%      .steepness   [optional] a scalar controling the amount of blur, see
%                   below for details. Lower steepness gives moreblur, but
%                   if the value is too low, image may not reach the value 
%                   of 1 at the center of the target. 
%                   Default: 10/mean(radius)
%      .desired_img_radius
%                   Overwrites the radius input. May be specified as a
%                   vector or a function handle with the signature
%                       func(pts)
%                   where pts is either [2xN] or [3xN], dependig on the xyz
%                   function input, e.g. @(xyz) abs(xyz(3,:))/5;
%
% The desired images approximate in each pixel the area integral of:
%       f(r) = 1 / (1 + exp(s*(|r-r0| - radius)))
% where
%       r   - position vector in 2D/3D space
%       s   - opt.steepness
%       r0  - target center
% For |r-r0| = radius, f(r) = 0.5.
% 
% As of 2015-03-29, this is the default desired image function used by
% MK_GRID_MODEL.
%
% See also: CALC_GREIT_RM, MK_GREIT_MODEL, MK_PIXEL_SLICE

% (C) 2015 Bartlomiej Grychtol. All rights reserved Swisstom AG.
% License: GPL version 2 or 3
% $Id$

% >> SWISSTOM CONTRIBUTION <<

if ischar(xyz) && strcmp(xyz,'UNIT_TEST'), do_unit_test; return, end

[xyzr, radius, opt] = parse_opt(xyz, radius, opt);

copt.cache_obj = {xyzr, radius, opt.rec_model.nodes, opt.rec_model.elems, opt.steepness};
copt.fstr = 'GREIT_desired_img_sigmoid';
PSF = eidors_cache(@desired_soln,{xyzr, radius, opt},copt);


end


function PSF = desired_soln(xyz, radius, opt)
    num_it = size(xyz,2);
    progress_msg('Composing desired images:',0,num_it);
    mdl = opt.rec_model;
    switch opt.n_dim
        case 3
            mdl.vox = [mdl.elems(1:6:end,:) mdl.elems(6:6:end,:)];
        case 2
            mdl.vox = [mdl.elems(1:2:end,:) mdl.elems(2:2:end,:)];
    end
    [Xnodes,Ynodes,Znodes] = voxnodes(mdl);
    th = log(1e4)/opt.steepness;
    for i=1:size(xyz,2);
        progress_msg(i,num_it);
        farel = far_elems(Xnodes,Ynodes,Znodes, xyz(:,i), radius(i), th);
        el_idx = find(~farel);
        X = []; Y = []; Z = [];
        idx = []; factor = [];
        for e = el_idx'
            [x,y,z] = interp_elem(mdl,e,radius(i), opt);
            X = [X ; x(:)]; Y = [Y ; y(:)]; Z = [Z ; z(:)];
            n = numel(x);
            idx = [idx; e*ones(n,1)];
            factor = [factor; ones(n,1)/n];
        end
        D = sqrt(sum(bsxfun(@minus,[X Y Z],xyz(:,i)').^2, 2));
        x = D - radius(i);
        tmp = 1 ./ (1 + exp( opt.steepness * x));
        PSF(:,i) = full(sparse(idx,1,tmp(:) .* factor,size(mdl.vox,1),1));
    end
    progress_msg(Inf);
end

function [X, Y, Z] = voxnodes(mdl)
    x = mdl.nodes(:,1); X = x(mdl.vox);
    y = mdl.nodes(:,2); Y = y(mdl.vox);
    try
        z = mdl.nodes(:,3); Z = z(mdl.vox);
    catch
        Z = [];
    end
        
    
end


function [x,y,z,n] = interp_elem(mdl,e,radius, opt)
    maxsep = radius/5;

    minnode = min(mdl.nodes(mdl.vox(e,:),:));
    maxnode = max(mdl.nodes(mdl.vox(e,:),:));
    vec = {};
    for d = 1:opt.n_dim
        sep = maxnode(d) - minnode(d);
        N = max(3, ceil(sep/maxsep)+1);
        v = linspace(minnode(d),maxnode(d),N);
        v(end) = [];
        v = v + .5*(maxnode(d)-minnode(d))/(N-1);
        vec{d} = v;
    end
    switch opt.n_dim
        case 3
            [x, y, z] = ndgrid(vec{:});
        case 2
            [x, y] = ndgrid(vec{:});
            z = [];
    end
%     clf
%     show_fem(mdl);
%     hold on
%     plot3(x(:),y(:),z(:),'.');
%     hold off
%     pause
end

function farel = far_elems(Xnodes,Ynodes,Znodes,xyz,radius, th)
    farel = false(size(Xnodes,1),1);

    nodes_test = Xnodes < xyz(1) - radius - th;
    farel = farel | all(nodes_test,2);
    if all(farel), return, end;
    nodes_test = Xnodes > xyz(1) + radius + th;
    farel = farel | all(nodes_test,2);
    if all(farel), return, end;
    nodes_test = Ynodes < xyz(2) - radius - th;
    farel = farel | all(nodes_test,2);
    if all(farel), return, end;
    nodes_test = Ynodes > xyz(2) + radius + th;
    farel = farel | all(nodes_test,2);
    if all(farel), return, end;
    if ~isempty(Znodes)
        nodes_test  = Znodes > xyz(3) + radius + th;
        farel = farel | all(nodes_test,2);
        if all(farel), return, end;
        nodes_test  = Znodes < xyz(3) - radius - th;
        farel = farel | all(nodes_test,2);
        if all(farel), return, end;
    end
    idx = find(~farel);
end


function [xyz, radius, opt] = parse_opt(xyz, radius, opt)

    scale_radius = false;
    if isempty(radius)
        radius = xyz(end,:);
        scale_radius = true;
        xyz(end,:) = [];
    end
    
    if isfield(opt,'desired_img_radius')
       scale_radius = false;
       if isnumeric(opt.desired_img_radius)
          radius = opt.desired_img_radius;
       end
       if isa(opt.desired_img_radius, 'function_handle')
          radius = feval(opt.desired_img_radius,xyz);
       end
    end
    
    mdl = opt.rec_model; % must exist
    opt.n_dim = size(mdl.nodes,2);
    xyz = xyz(1:opt.n_dim, :); % ingore z if model is 2D
    

    opt.meshsz = [];
    try
        for i = 1:3
            opt.meshsz = [opt.meshsz min(mdl.nodes(:,i)) max(mdl.nodes(:,i))];
        end
    end
    
    opt.n_dim = length(opt.meshsz)/2;
    opt.meshsz = reshape(opt.meshsz,2,[])';
%     if size(opt.meshsz, 1)==2
%         opt.meshsz(3,:) = 0;
%     end
    opt.minpt = opt.meshsz(:,1);
    opt.maxpt = opt.meshsz(:,2);
    opt.range = opt.maxpt - opt.minpt;
    opt.maxrange = max(opt.range(1:2));

    %rescale points to between -1 and 1 in the x-y plane
    xyz = 2*bsxfun(@minus, xyz, mean(opt.meshsz,2))/opt.maxrange;
    mdl.nodes = 2*bsxfun(@minus, mdl.nodes, mean(opt.meshsz(1:size(mdl.nodes,2),:),2)')/opt.maxrange;
    opt.rec_model = mdl;
    if scale_radius
        radius = radius / opt.maxrange;
    end
    
    if ~isfield(opt, 'steepness')
        opt.steepness = 10/mean(radius);
    end
    
    if numel(radius) == 1
        radius = ones(1,size(xyz,2)) * radius;
    end
end

function do_unit_test
    v = linspace(-1,1,32);
    mdl= mk_grid_model([],v,v,[0 .7 1:.2:2 2.3 3]);
    opt.rec_model = mdl;
%     opt.desired_img_radius = .1:.1:.5;
    opt.desired_img_radius = @(xyz) xyz(3,:)/5;
    xyzr = zeros(5,4);
    xyzr(:,4) = .25;
    xyzr(:,3) = .5:.5:2.5;
    sol = GREIT_desired_img_sigmoid(xyzr',[],opt);
    img = mk_image(mdl,0);
    for i = 1:5
        subplot(2,3,i)
        img.elem_data= sol(:,i);
        show_3d_slices(img,xyzr(i,3),xyzr(i,2),xyzr(i,1));
    end
end
