function [V] = forward_solver(E,I,tol,pp,V, compat_param);
%[V] = forward_solver(E,I,tol,pp,V);
%
%This function solves the forward problem using matlab's \ sovler, or
%conjugate gradients (for large problems). 
%
%E   = The full rank system matrix 
%I   = The currents matrix (RHS) 
%tol = The tolerance in the forward solution, e.g. 1e-5
%pp  = UNUSED
%V   = The approximated nodal potential distribution (USED FOR PCG SOLN)

% (c) N. Polydorides 2003 % Copying permitted under terms of GNU GPL
% $Id$

% The EIDORS3D V2 was [V] = forward_solver(vtx,E,I,tol,pp,V);
% but vtx not used, so it's forward_solver(E,I,tol,pp,V, compat_param);
if size(E,2) == 3; % E is actually vtx
  if nargin>=2; E= I;             end
  if nargin>=3; I= tol;           end
  if nargin>=4; tol= pp;          end
  if nargin>=5; pp= V;            end
  if nargin>=6; V =compat_param;  end
end 

[n_nodes,n_stims] = size(I);

try
   V= E\I;
% TODO: Iteratively refine
%  From GH Scott: "once we have
%   computed the approximate solution x, we perform one step
%   of iterative refinement by computing the residual: r = Ax - b
%   and then recalling the solve routine to solve
%   Adx = r for the correction dx.
% However, we don't want to repeat the '\', so we implement
%   the underlying algorithm:
%   If A is sparse, then MATLAB software uses CHOLMOD (after 7.2) to compute X.
%    The computations result in  P'*A*P = R'*R
%   where P is a permutation matrix generated by amd, and R is
%   an upper triangular matrix. In this case, X = P*(R\(R'\(P'*B)))

catch 
   [lasterr_str,lasterr_id]= lasterr;
   if ~strcmp(lasterr_id , 'MATLAB:nomem')
      error(lasterr_str); % rethrow error
   end

   eidors_msg('Memory exhausted for inverse. Trying PCG',2);

   if nargin < 5
      sz= [size(E,1),n_stims];
      V = eidors_obj('get-cache', sz, 'forward_solver_V');
      if isempty(V); V= zeros(sz); end
   end

   if isreal(E)
      U = cholinc(E,tol*100); L = U'; 
      cgsolver = @pcg;
   else %Complex
      [L,U] = luinc(E,tol/10);
      cgsolver = @bicgstab;
   end

   for i=1:n_stims
      [V(:,i),flag] = feval( cgsolver, E,I(:,i), ...
               tol*norm(I(:,i)),n_nodes,L,U,V(:,i));
   end 
      eidors_obj('set-cache', sz, 'forward_solver_V', V);
end



%%% OLD CODE
   % Cholesky solver. Gives poor results matching others
   % so we no longer use it
   if 0 
       %Permute the rows and columns to make the factors sparser
       E = E(pp,pp);
       In = I(pp,:);
       rr(pp)=1:max(size(pp));  % this should be done only Once!
                                % actually much better just to do the
                                % renumbering when the mesh is generated!
       U = chol(E);
       q_c =  U' \ In;  
       Vn = U \ q_c;
       %De-permute the result for Cholesky
       V = Vn(rr,:);
   end
