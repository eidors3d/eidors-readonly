function [V] = left_divide(E,I,tol,~,V)
%[V] = LEFT_DIVIDE(E,I,tol,pp,V);
%[V] = LEFT_DIVIDE(E,I,fmdl)
% 
% Implements left division for symmetric positive definite system solves
% such as the sparse forward solve and dense solve for a GN descent
% direction. LEFT_DIVIDE is optimised for symmetric matrices and overcomes
% small inefficiencies of matlab's mldivide. For non-symmetric solves 
% please use mldivide.
%
% Also uses conjugate gradients (for large problems).
%
% E   = The full rank system matrix
% I   = The currents matrix (RHS)
% tol = The tolerance in the forward solution, e.g. 1e-5
%
% pp,V are old options from previous solver. tilde used in arguments list
% to ignore pp and keep matlab's code analyzer happy

% (c) N. Polydorides 2003 % Copying permitted under terms of GNU GPL
% $Id$

if ischar(E) && strcmp(E,'UNIT_TEST'); do_unit_test; return; end

if nargin<3;
   tol=1e-8;
end
do_pcg = false;
if isstruct(tol);
   fmdl = tol;
   try
      do_pcg = fmdl.left_divide.do_pcg;
   catch
   end
   try 
      tol = fmdl.left_divide.tol;
   catch
      tol = 1e-8;
   end
   try 
      V = fmdl.left_divide.V_initial;
   catch
      sz= [size(E),size(I)];
      V = eidors_obj('get-cache', sz, 'left_divide_V');
      if isempty(V); V = zeros(size(E,1),size(I,2)); end
   end
end


if ~do_pcg
   try
     V= non_iterative(E,I);
   catch excp
       % TODO: check if this catch block is needed
       if ~strcmp(excp.identifier , 'MATLAB:nomem')
           rethrow(excp); % rethrow error
       end
       
       eidors_msg('Memory exhausted for inverse. Trying PCG',2);
       V=iterative_solve(E,I,tol,V,fmdl);
   end
else
   V=iterative_solve(E,I,tol,V,fmdl);
end

function V= non_iterative(E,I);
    % V= E\I;
    % This takes MUCH longer when you have  more vectors in I,
    %  even if they are repeated. There must be some way to simplify
    %  this to speed it up. Matlab's sparse operators really should
    %  do this for you.
    
    % TODO: 
    % 1. change from QR implementation to basis implementation
    % 2. implement selection for required nodal values
    % 3. cache basis solve
    % 4. possibly change to itterative for successive solves on the same
    %    mesh
    if issparse(E)
        
% This should speed up, and help issue with octave on QR
        inotzeros = logical(any(I,2));
      if exist('OCTAVE_VERSION') == 5 % v 4.4 has problems with sparse qr
        [Qi,R] = qr(full(I(inotzeros,:)),0);
      else
        [Qi,R] = qr(I(inotzeros,:),0);
      end
        rnotzeros = logical(any(R,2));
        R= R(rnotzeros,:);
        Q = sparse(size(I,1), size(R,1));
        Q(inotzeros,:) = Qi(:,rnotzeros);
%        [Q,R] = qr(I,0);
%        rnotzeros = any(R~=0,2);
%        Q= Q(:,rnotzeros);
%        R= R(rnotzeros,:);
        V= (E \ Q)*R;
        
    else
        if isreal(E)
            try
                % for dense solve of tikhonov regularised least squares
                % matrix E is symmetric if it is of the form
                % (J.'*W*J + hp^2*R.'R) and is real
                opts.SYM=true;
                opts.POSDEF=true;
                
                V= linsolve(E,I,opts);
            catch Mexcp
                
                % error handling 
                if(strcmp(Mexcp.identifier,'MATLAB:posdef'))
                    
                    warning('EIDORS:leftDivideSymmetry',...
                        ['left_divide is optimised for symmetric ',...
                        'positive definite matrices.']);
                    
                else 
                    warning(['Error with linsolve in left_divide, trying backslash.\n',...
                        'Error identifier: ',Mexcp.identifier]);
                end
                
                % continue solve with backslash
                V=E\I;
            end
        else
            % cholesky only works for real valued system matrices
            V=E\I;
        end
    end
    
    % TODO: Iteratively refine
    %  From GH Scott: "once we have
    %   computed the approximate solution x, we perform one step
    %   of iterative refinement by computing the residual: r = Ax - b
    %   and then recalling the solve routine to solve
    %   Adx = r for the correction dx.
    % However, we don't want to repeat the '\', so we implement
    %   the underlying algorithm:
    %   If A is sparse, then MATLAB software uses CHOLMOD (after 7.2) to compute X.
    %    The computations result in  P'*A*P = R'*R
    %   where P is a permutation matrix generated by amd, and R is
    %   an upper triangular matrix. In this case, X = P*(R\(R'\(P'*B)))
    %
    % See also:
    % http://www.cs.berkeley.edu/~wkahan/MxMulEps.pdf
    % especially page 15 where it discusses the value of iterative refinement
    %  without extra precision bits.  ALso, we need to enable
    
function V=iterative_solve(E,I,tol,V,fmdl)
    
    [n_nodes,n_stims] = size(I);
    if isreal(E)
        opts.droptol = tol*100;
        opts.type = 'ict';
        U = ichol(E, opts);
        L = U';
        cgsolver = @pcg;
    else %Complex
        opts.droptol = tol/10;
        [L,U] = ilu(E, opts);
        cgsolver = @bicgstab;
    end
    
    for i=1:n_stims
        [V(:,i),~] = feval( cgsolver, E,I(:,i), ...
            tol*norm(I(:,i)),n_nodes,L,U,V(:,i));
    end
    sz= [size(E),size(I)];
    eidors_obj('set-cache', sz, 'left_divide_V', V);
    

% Test code
function do_unit_test

% test solvers are unaffected 
inv_solve('UNIT_TEST')
fwd_solve_1st_order('UNIT_TEST')

% test non-symmetric handling
s=warning('QUERY','EIDORS:leftDivideSymmetry');
warning('OFF','EIDORS:leftDivideSymmetry')
lastwarn('')
A=rand(1e3);
b=rand(1e3);

left_divide(A,b);
[~, LASTID] = lastwarn;
unit_test_cmp('sym warn',LASTID,'EIDORS:leftDivideSymmetry')
warning(s);

% test dense sym posdef solve
imdl=mk_common_model('n3r2',[16,2]);
img=mk_image(imdl,1);
img.elem_data=1+0.1*rand(size(img.elem_data));
J   = calc_jacobian(img);
RtR = calc_RtR_prior(imdl);
W   = calc_meas_icov(imdl);
hp  = calc_hyperparameter(imdl);
LHS = (J'*W*J +  hp^2*RtR);
RHS = J'*W;
unit_test_cmp('dense chol',LHS\RHS,left_divide(LHS,RHS),1e-13)
