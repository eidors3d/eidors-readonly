function [V] = left_divide(E,I,tol,~,V)
%[V] = LEFT_DIVIDE(E,I,tol,pp,V);
% 
% Implements left division for symmetric positive definite system solves
% such as the sparse forward solve and dense solve for a GN descent
% direction. LEFT_DIVIDE is optimised for symmetric matrices and overcomes
% small inefficiencies of matlab's mldivide. For non-symmetric solves 
% please use mldivide.
%
% Also uses conjugate gradients (for large problems).
%
% E   = The full rank system matrix
% I   = The currents matrix (RHS)
% tol = The tolerance in the forward solution, e.g. 1e-5
%
% pp,V are old options from previous solver. tilde used in arguments list
% to ignore pp and keep matlab's code analyzer happy

% (c) N. Polydorides 2003 % Copying permitted under terms of GNU GPL
% $Id$

if ischar(E) && strcmp(E,'UNIT_TEST'); do_unit_test; return; end

if ~exist('tol','var'); tol = 1e-8; end

[n_nodes,n_stims] = size(I);

try
    % V= E\I;
    % This takes MUCH longer when you have  more vectors in I,
    %  even if they are repeated. There must be some way to simplify
    %  this to speed it up. Matlab's sparse operators really should
    %  do this for you.
    
    % TODO: 
    % 1. change from QR implementation to basis implementation
    % 2. implement selection for required nodal values
    % 3. cache basis solve
    % 4. possibly change to itterative for successive solves on the same
    %    mesh
    if issparse(E)
        
        [Q,R] = qr(I,0);
        rnotzeros = any(R~=0,2);
        Q= Q(:,rnotzeros);
        R= R(rnotzeros,:);
        V= (E \ Q)*R;
        
    else
        if isreal(E)
            try
                % for dense solve of tikhonov regularised least squares
                % matrix E is symmetric if it is of the form
                % (J.'*W*J + hp^2*R.'R) and is real
                opts.SYM=true;
                opts.POSDEF=true;
                
                V= linsolve(E,I,opts);
            catch Mexcp
                
                % error handling 
                if(strcmp(Mexcp.identifier,'MATLAB:posdef'))
                    
                    warning('EIDORS:leftDivideSymmetry',...
                        ['left_divide is optimised for symmetric ',...
                        'positive definite matrices.']);
                    
                else 
                    warning(['Error with linsolve in left_divide, trying backslash.\n',...
                        'Error identifier: ',Mexcp.identifier]);
                end
                
                % continue solve with backslash
                V=E\I;
            end
        else
            % cholesky only works for real valued system matrices
            V=E\I;
        end
    end
    
    % TODO: Iteratively refine
    %  From GH Scott: "once we have
    %   computed the approximate solution x, we perform one step
    %   of iterative refinement by computing the residual: r = Ax - b
    %   and then recalling the solve routine to solve
    %   Adx = r for the correction dx.
    % However, we don't want to repeat the '\', so we implement
    %   the underlying algorithm:
    %   If A is sparse, then MATLAB software uses CHOLMOD (after 7.2) to compute X.
    %    The computations result in  P'*A*P = R'*R
    %   where P is a permutation matrix generated by amd, and R is
    %   an upper triangular matrix. In this case, X = P*(R\(R'\(P'*B)))
    %
    % See also:
    % http://www.cs.berkeley.edu/~wkahan/MxMulEps.pdf
    % especially page 15 where it discusses the value of iterative refinement
    %  without extra precision bits.  ALso, we need to enable
    
    
catch excp
    % TODO: check if this catch block is needed
    if ~strcmp(excp.identifier , 'MATLAB:nomem')
        rethrow(excp); % rethrow error
    end
    
    eidors_msg('Memory exhausted for inverse. Trying PCG',2);
    
    if nargin < 5
        sz= [size(E,1),n_stims];
        V = eidors_obj('get-cache', sz, 'left_divide_V');
        if isempty(V); V= zeros(sz); end
    end
    
    ver = eidors_obj('interpreter_version'); % Matlab2013 renamed cholinc -> ichol
    if isreal(E)
        opts.droptol = tol*100;
        opts.type = 'ict';
        if ver.isoctave || ver.ver < 7.012
            U = cholinc(E, opts.droptol);
        else
            U = ichol(E, opts);
        end
        L = U';
        cgsolver = @pcg;
    else %Complex
        opts.droptol = tol/10;
        if ver.isoctave || ver.ver < 7.012 % Matlab2007 introduced ilu, luinc has now been dropped
            [L,U] = luinc(E, opts.droptol);
        else
            [L,U] = ilu(E, opts);
        end
        cgsolver = @bicgstab;
    end
    
    for i=1:n_stims
        [V(:,i),~] = feval( cgsolver, E,I(:,i), ...
            tol*norm(I(:,i)),n_nodes,L,U,V(:,i));
    end
    eidors_obj('set-cache', sz, 'left_divide_V', V);
end

% Test code
function do_unit_test

% test solvers are unaffected 
inv_solve('UNIT_TEST')
fwd_solve_1st_order('UNIT_TEST')

% test non-symmetric handling
s=warning('QUERY','EIDORS:leftDivideSymmetry');
warning('OFF','EIDORS:leftDivideSymmetry')
lastwarn('')
A=rand(1e3);
b=rand(1e3);

left_divide(A,b);
[~, LASTID] = lastwarn;
unit_test_cmp('sym warn',LASTID,'EIDORS:leftDivideSymmetry')
warning(s);

% test dense sym posdef solve
imdl=mk_common_model('n3r2',[16,2]);
img=mk_image(imdl,1);
img.elem_data=1+0.1*rand(size(img.elem_data));
J   = calc_jacobian(img);
RtR = calc_RtR_prior(imdl);
W   = calc_meas_icov(imdl);
hp  = calc_hyperparameter(imdl);
LHS = (J'*W*J +  hp^2*RtR);
RHS = J'*W;
unit_test_cmp('dense chol',LHS\RHS,left_divide(LHS,RHS))
