function noiseEst = mantis_initnoise(stim,VM,Npp,P,verbose)
%MANTIS_INITNOISE estimate noise level in VM generated by measurements stim
%   Inputs:
%   stim    - EIDORS stimulation pattern, as generated by mk_stim_pattern
%   VM      - measured voltages
%   Npp     - number of electrodes per plane
%   P       - number of electrode planes (as in "multiple belt" measurements)
%   verbose - level of verbosity: 0 = 0ff,
%                                 1 = timing,
%                                 2 = important info + timing,
%                                 3 = detailed info.
%   Output:
%   noiseEst - estimated noise level in the Frobenius norm
%
% (C) 2015 Robert Winkler. License: GPL version 2 or version 3

doSymSearch = true; % use symmetry approach

if nargin < 4; P = 1; end % standard case: one electrode belt
if nargin < 5; verbose = 0; end

M = length(stim); % number of stimulations

if mod(M,P) % #stimulations is not a multiple of #planes
  warning(['Unexpected stimulation pattern ' ...
          '(number of stimulations per belt varies). Trying to find' ...
          'redundant measurements.']);
  P = 1;
  doSymSearch = false;
end

% do noise estimate recursively for all electrode planes
if P > 1
  if verbose >= 3
    fprintf('Decomposing measurement data for %i planes.\n',P);
  end
  [stimk,VMk] = mantis_decplanes(stim,VM,Npp,P);
  noiseEst = zeros(P,1);
  dk = zeros(P,1);
  for k=1:P
    noiseEst(k) = mantis_initnoise(stimk{k},VMk{k},Npp,1);
    dk(k) = numel(VMk{k});
  end
  vavg = sum(noiseEst.^2)/sum(dk);                                        % weighted average variation
  noiseEst = sqrt(numel(VM)*vavg);                                        % combined/total noise estimate from individual planes
  return;

% noise estimate for "single" electrode plane
else
  
  S = numel(stim);    % number of stimulations
  N = zeros(S,1);     % number of electrodes
  M = zeros(S,1);     % number of measurements
  Mrank = zeros(S,1); % measurement rank
  
  for k=1:S
    M(k)     = size(stim(k).meas_pattern,1);
    N(k)     = size(stim(k).meas_pattern,2);
    Mrank(k) = rank(full(stim(k).meas_pattern));
  end
  
  if any(~(N(1)==N))
    error('Number of electrodes changes in measurements!');
  else
    N=N(1);
  end
  
  if any(~(M(1)==M))
    doSymSearch = false; % number of measurements per stimulation changes -> do redundancy search.
  else
    IM = zeros(N,M(1));
    for k=1:M(1); IM(:,k) = full(stim(k).stim_pattern); end % write currents as matrix

    if min(min(Mrank),rank(IM)) < N-1 % measurement rank or number of measurements insufficient for symmetry search
      doSymSearch = false;
      
    else % transform measurements to unit basis
      M = M(1);
      for k=1:S
        tmpind = (k-1)*M+1:k*M;
        if N > M; tolMM = 1e-8; else tolMM = min(svd(full(stim(k).meas_pattern)))+1e-8; end           
        VM(tmpind) = pinv(full(stim(k).meas_pattern),tolMM)*VM(tmpind); 
      end
    end
  end
end

if doSymSearch
  VM = reshape(VM,N,S); % this should work now, after basis transform (S = "new" M)
  if N > S; tolIM = 1e-8; else tolIM = min(svd(IM))+1e-8; end
  IMi = pinv(IM,tolIM);
  E = VM*IMi;
  E = E - transpose(E);
  noiseEst = sqrt(M*N/(2*(N-1)))*norm(E,'fro')/norm(IMi,'fro');
  
else % UGLY brute force search for redundant patterns. better implement a smarter/vectorized approach!
  
  cvec1 = [];
  cvec2 = [];
  cnt = 0;
  
  for k=1:S
    %sometimes, it's faster...
    stim(k).meas_pattern = full(stim(k).meas_pattern);
    stim(k).stim_pattern = full(stim(k).stim_pattern);
    
    % normalized lines (for comparison)
    stim(k).stim_fac = max(abs(stim(k).stim_pattern));
    stim(k).stim_npat = stim(k).stim_pattern/stim(k).stim_fac;
    
    stim(k).meas_fac = max(abs(stim(k).meas_pattern),[],2);
    stim(k).meas_npat = (stim(k).meas_pattern ./ ...
      repmat(stim(k).meas_fac,1,size(stim(k).meas_pattern,2)))'; % transposed = faster
  end
  
  for k1=1:S % 1st stimulation pattern
    %k1fac = max(abs(stim(k1).stim_pattern));
    %k1pat = stim(k1).stim_pattern./k1fac;
    k1pat = stim(k1).stim_npat;
    
    for l1=1:M(k1) % 1st measurement pattern
      %l1fac = max(abs(stim(k1).meas_pattern(l1,:)));
      %l1pat = (stim(k1).meas_pattern(l1,:))'./l1fac;
      l1pat = stim(k1).meas_npat(:,l1);
      
      for k2=(k1+1):S % search all following stim patterns (avoid double hits)
        %k2fac = max(abs(stim(k2).stim_pattern));
        %k2pat = stim(k2).stim_pattern./k2fac;
        k2pat = stim(k2).stim_npat;
        
        for l2=1:M(k2)
          %l2fac = max(abs(stim(k2).meas_pattern(l2,:)));
          %l2pat = (stim(k2).meas_pattern(l2,:))'./l2fac;
          l2pat = stim(k2).meas_npat(:,l2);
          
          if (norm(k1pat - l2pat) < 1e-10 && norm(k2pat - l1pat) < 1e-10) || ...
             (norm(k1pat + l2pat) < 1e-10 && norm(k2pat + l1pat) < 1e-10)
            
            cnt = cnt+1;
            cvec1(cnt) = VM(sum(M(1:k1-1))+l1);
            cvec2(cnt) = VM(sum(M(1:k2-1))+l2).*(...
              (stim(k1).stim_fac*stim(k1).meas_fac(l1))/(stim(k2).stim_fac*stim(k2).meas_fac(l2)));
            
          elseif (norm(k1pat + l2pat) < 1e-10 && norm(k2pat - l1pat) < 1e-10) || ...
                 (norm(k1pat - l2pat) < 1e-10 && norm(k2pat + l1pat) < 1e-10)
        
            cnt = cnt+1;
            cvec1(cnt) = VM(sum(M(1:k1-1))+l1);
            cvec2(cnt) = -VM(sum(M(1:k2-1))+l2).*(...
              (stim(k1).stim_fac*stim(k1).meas_fac(l1))/(stim(k2).stim_fac*stim(k2).meas_fac(l2)));
          end
        end
      end
    end
  end
  
  if verbose >= 3
    fprintf('%i redundancies found for noise estimation.\n',cnt);
  end
  
  if isempty(cvec1)
    warning('No redundancies found. Noise estimate not possible. Setting default value 1e-3*||VM||.');
    noiseEst = 1e-3*norm(VM,'fro');
  else  
    v = sum((cvec1-cvec2).^2)/(2*cnt);
    noiseEst = sqrt(numel(VM)*v);
  end
end

