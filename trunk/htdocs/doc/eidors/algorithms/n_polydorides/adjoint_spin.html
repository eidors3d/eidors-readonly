<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of adjoint_spin</title>
  <meta name="keywords" content="adjoint_spin">
  <meta name="description" content="function [JTb] = adjoint_spin(vtx,simp,elec,x,gnd_ind,zc,I,no_pl,Vmes);">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html?eidors/algorithms/n_polydorides/adjoint_spin.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- ../menu.html algorithms --><!-- menu.html n_polydorides -->
<h1>adjoint_spin
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [JTb] = adjoint_spin(vtx,simp,elec,x,gnd_ind,zc,I,no_pl,Vmes);</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [JTb] = adjoint_spin(vtx,simp,elec,x,gnd_ind,zc,I,no_pl,Vmes); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">function [JTb] = adjoint_spin(vtx,simp,elec,x,gnd_ind,zc,I,no_pl,Vmes);

The function calculates the product J'*b, i.e. Jacobian transpose times 
a (measurements Vmes) vector b, using the adjoint sources formulation.
 


JTb     = J'*Vmes
vtx     = The vertices matrix
simp    = The simplices matrix
elec    = The electrodes matrix
x       = The solution estimate based on which J is supposed to be caclulated
gnd_ind = The grounf index
zc      = The electrode contact impedance
I       = The current patterns
no_pl   = Number of electrode planes
Vmes    = The measurements vector</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="fem_master_full.html" class="code" title="function [E,D,Ela,pp] = fem_master_full(vtx,simp,mat,gnd_ind,elec,zc,perm_sym);">fem_master_full</a>	function [E,D,Ela,pp] = fem_master_full(vtx,simp,mat,gnd_ind,elec,zc,perm_sym);</li><li><a href="get_3d_meas.html" class="code" title="function [voltageH,voltageV,indH,indV,df] = get_3d_meas(elec,vtx,V,Ib,no_pl);">get_3d_meas</a>	GET_3D_MEAS: extracts multiplane voltage measurements from a calculated</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [JTb] = adjoint_spin(vtx,simp,elec,x,gnd_ind,zc,I,no_pl,Vmes);</a>
0002 <span class="comment">%function [JTb] = adjoint_spin(vtx,simp,elec,x,gnd_ind,zc,I,no_pl,Vmes);</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%The function calculates the product J'*b, i.e. Jacobian transpose times</span>
0005 <span class="comment">%a (measurements Vmes) vector b, using the adjoint sources formulation.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%JTb     = J'*Vmes</span>
0010 <span class="comment">%vtx     = The vertices matrix</span>
0011 <span class="comment">%simp    = The simplices matrix</span>
0012 <span class="comment">%elec    = The electrodes matrix</span>
0013 <span class="comment">%x       = The solution estimate based on which J is supposed to be caclulated</span>
0014 <span class="comment">%gnd_ind = The grounf index</span>
0015 <span class="comment">%zc      = The electrode contact impedance</span>
0016 <span class="comment">%I       = The current patterns</span>
0017 <span class="comment">%no_pl   = Number of electrode planes</span>
0018 <span class="comment">%Vmes    = The measurements vector</span>
0019 
0020 
0021 spin = 1;<span class="comment">%size(I,2);</span>
0022 [vr] = size(vtx,1);
0023 ptr = 0;
0024     
0025      <span class="comment">%Update model based on last x</span>
0026      [E,D,Ela,pp] = <a href="fem_master_full.html" class="code" title="function [E,D,Ela,pp] = fem_master_full(vtx,simp,mat,gnd_ind,elec,zc,perm_sym);">fem_master_full</a>(vtx,simp,x,gnd_ind,elec,zc,<span class="string">'{n}'</span>);
0027      EB = kron(eye(spin),inv(E));    
0028      
0029           
0030      <span class="keyword">for</span> j=1:spin:size(I,2); <span class="comment">%For each group of current patterns</span>
0031      
0032      Ib = I(:,j:j+spin-1);
0033      IB = reshape(Ib,size(Ib,1)*size(Ib,2),1);
0034      
0035      VB = EB*IB;
0036          
0037      
0038      <span class="comment">%The current fields for I(: ,spin) only</span>
0039      VB1 = reshape(VB,size(vtx,1)+size(elec,1),spin);
0040      VB2 = VB1(1:size(vtx,1),:); 
0041      <span class="comment">%These are the standard current fields used in the calculation of the Jacobian</span>
0042      Vjcf = reshape(VB2,size(vtx,1)*spin,1);
0043      <span class="comment">%Electrode potentials removed</span>
0044      
0045      volts = []; <span class="comment">%Some simulated data based on x</span>
0046      ind = [];
0047      dfh = [];
0048      
0049      [voltageH,voltageV,indH,indV,df] = <a href="get_3d_meas.html" class="code" title="function [voltageH,voltageV,indH,indV,df] = get_3d_meas(elec,vtx,V,Ib,no_pl);">get_3d_meas</a>(elec,vtx,VB1,<span class="keyword">...</span><span class="comment"> </span>
0050                                                        I(size(vtx,1)+1:<span class="keyword">end</span>,j:j+spin-1),no_pl);
0051      volts = [volts;voltageH];
0052      ind = [ind;indH];
0053      dfh = [dfh;df(1:2:end)];
0054        
0055   
0056           
0057          <span class="comment">%The measurement fields for the measurements during I(:,spin) are active</span>
0058          VmI = Vmes(ptr+1:ptr+sum(dfh)); <span class="comment">%Part of the measurements</span>
0059          ptr  = ptr+sum(dfh);
0060      
0061                 
0062          <span class="comment">%Set up the measurement patterns for all I(:,spin)</span>
0063          Imb = [];
0064          MC = [];
0065          kap = 1;
0066 
0067              <span class="keyword">for</span> ij=1:size(ind,1)
0068                  m_n = zeros(size(elec,1),1);
0069                  m_n(ind(ij,1)) = 1;
0070                  m_n(ind(ij,2)) = -1;
0071                  MC = [MC,m_n];
0072                  <span class="keyword">if</span> ij == sum(dfh(1:kap))
0073                      <span class="keyword">if</span> ij ~= size(ind,1)
0074                      kap = kap+1;
0075                      <span class="keyword">end</span>
0076                      Imb = sparse(blkdiag(Imb,MC(:,1+ij-dfh(kap):end)));
0077                  <span class="keyword">end</span>
0078             <span class="keyword">end</span>
0079              
0080                  
0081          <span class="comment">%These are measurement residuals of the j'th current pattern</span>
0082          b = VmI;
0083               
0084          Im = Imb*b; 
0085          
0086          <span class="comment">%Reshape it in columns.</span>
0087          Im_col = reshape(Im,size(elec,1),spin);
0088          mul = 1;
0089          
0090                     I_s = [];
0091                     <span class="keyword">for</span> t=1:spin
0092                         I_s = [I_s; zeros(size(vtx,1),1); Im_col(:,t)*mul];
0093                     <span class="keyword">end</span>
0094      
0095                     Vmf = EB*I_s;
0096                     Vmf1 = reshape(Vmf,size(vtx,1)+size(elec,1),spin);
0097                     Vmf2 = Vmf1(1:size(vtx,1),:);
0098                     Vjmf = reshape(Vmf2,size(vtx,1)*spin,1); <span class="comment">%</span>
0099                     
0100                     DM = kron(eye(spin),D); <span class="comment">% Gradient operator</span>
0101                     Vjmf_n = -DM * Vjmf;
0102                     Vjcf_n = -DM * Vjcf;
0103                     JTb_p = Vjmf_n .* Vjcf_n ;  
0104                     J_m = reshape(JTb_p,size(simp,1)*3,spin);
0105                     <span class="keyword">if</span> spin &gt; 1
0106                     JTb_x3 = sum(J_m.');
0107                 <span class="keyword">else</span>
0108                     JTb_x3 = J_m.';
0109                 <span class="keyword">end</span>
0110                     JTb_u = JTb_x3(1:3:end) + JTb_x3(2:3:end) + JTb_x3(3:3:end);
0111         
0112                     JTb = -JTb_u.' .* diag(Ela(1:3:<span class="keyword">end</span>,1:3:end));
0113         
0114    <span class="keyword">end</span>
0115    
0116    
0117 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0118 <span class="comment">% This is part of the EIDORS suite.</span>
0119 <span class="comment">% Copyright (c) N. Polydorides 2003</span>
0120 <span class="comment">% Copying permitted under terms of GNU GPL</span>
0121 <span class="comment">% See enclosed file gpl.html for details.</span>
0122 <span class="comment">% EIDORS 3D version 2.0</span>
0123 <span class="comment">% MATLAB version 5.3 R11</span>
0124 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0125</pre></div>
<hr><address>Generated on Tue 09-Aug-2011 11:38:31 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>