<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of time_prior_solve</title>
  <meta name="keywords" content="time_prior_solve">
  <meta name="description" content="TIME_PRIOR_SOLVE inverse solver to account for time differences">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html?eidors/algorithms/a_adler/time_prior_solve.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- ../menu.html algorithms --><!-- menu.html a_adler -->
<h1>time_prior_solve
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>TIME_PRIOR_SOLVE inverse solver to account for time differences</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function img= time_prior_solve( inv_model, data1, data2) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> TIME_PRIOR_SOLVE inverse solver to account for time differences
 img= aa_inv_solve( inv_model, data1, data2)
 img        =&gt; output image (or vector of images)
 inv_model  =&gt; inverse model struct
 data1      =&gt; differential data at earlier time
 data2      =&gt; differential data at later time

 both data1 and data2 may be matrices (MxT) each of
  M measurements at T times
 if either data1 or data2 is a vector, then it is expanded
  to be the same size matrix</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>	RtR = calc_RtR_prior( inv_model )</li><li><a href="../../../eidors/algorithms/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>	CALC_DIFFERENCE_DATA: calculate difference data between</li><li><a href="../../../eidors/algorithms/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>	CALC_HYPERPARAMETER: calculate hyperparameter value</li><li><a href="../../../eidors/algorithms/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="../../../eidors/algorithms/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>	CALC_JACOBIAN_BKGND: calculate background image around</li><li><a href="../../../eidors/algorithms/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>	meas_icov = calc_meas_icov( inv_model )</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG: eidors progress and status messages</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/examples/moving_tank_objs.html" class="code" title="function imgs= moving_tank_objs(data_sel, inv_sel, options)">moving_tank_objs</a>	MOVING_TANK_OBJS: create movies of objects moving in tanks</li><li><a href="../../../eidors/models/a_adler/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function one_step_inv= standard_form( inv_model, J )</a></li><li><a href="#_sub2" class="code">function one_step_inv= data_form( inv_model, J );</a></li><li><a href="#_sub3" class="code">function delta_vec= calc_delta( inv_model, J)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function img= time_prior_solve( inv_model, data1, data2)</a>
0002 <span class="comment">% TIME_PRIOR_SOLVE inverse solver to account for time differences</span>
0003 <span class="comment">% img= aa_inv_solve( inv_model, data1, data2)</span>
0004 <span class="comment">% img        =&gt; output image (or vector of images)</span>
0005 <span class="comment">% inv_model  =&gt; inverse model struct</span>
0006 <span class="comment">% data1      =&gt; differential data at earlier time</span>
0007 <span class="comment">% data2      =&gt; differential data at later time</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% both data1 and data2 may be matrices (MxT) each of</span>
0010 <span class="comment">%  M measurements at T times</span>
0011 <span class="comment">% if either data1 or data2 is a vector, then it is expanded</span>
0012 <span class="comment">%  to be the same size matrix</span>
0013 
0014 <span class="comment">% TODO: This function really should be calling the proper</span>
0015 <span class="comment">%   prior calculator functions, and not reimplementing</span>
0016 <span class="comment">%   them internally</span>
0017 
0018 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0019 <span class="comment">% $Id$</span>
0020 
0021 fwd_model= inv_model.fwd_model;
0022 time_steps = inv_model.time_prior_solve.time_steps;
0023 l_ts  = time_steps*2 + 1;
0024 
0025 <span class="comment">% The one_step reconstruction matrix is cached</span>
0026 one_step_inv = <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'get-cache'</span>, inv_model, <span class="string">'time_prior_solve'</span>);
0027 <span class="keyword">if</span> ~isempty(one_step_inv)
0028     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'time_prior_solve: using cached value'</span>, 2);
0029 <span class="keyword">else</span>
0030     img_bkgnd= <a href="../../../eidors/algorithms/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>( inv_model );
0031     J = <a href="../../../eidors/algorithms/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>( fwd_model, img_bkgnd);
0032 
0033 <span class="comment">%   one_step_inv= standard_form( inv_model, J );</span>
0034     one_step_inv= <a href="#_sub2" class="code" title="subfunction one_step_inv= data_form( inv_model, J );">data_form</a>( inv_model, J );
0035 
0036     <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'set-cache'</span>, inv_model, <span class="string">'time_prior_solve'</span>, one_step_inv);
0037     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'time_prior_solve: setting cached value'</span>, 2);
0038 <span class="keyword">end</span>
0039 
0040 dva = <a href="../../../eidors/algorithms/calc_difference_data.html" class="code" title="function dva = calc_difference_data( data1, data2, fwd_model)">calc_difference_data</a>( data1, data2, inv_model.fwd_model);
0041 
0042 l_dva = size( dva, 2);
0043 
0044 idx= [-time_steps:time_steps]'*ones(1,l_dva) + <span class="keyword">...</span>
0045      ones(l_ts,1)*(1:l_dva);
0046 <span class="comment">% replicate first and last measurements</span>
0047 idx(idx&lt;1) = 1;
0048 idx(idx&gt;l_dva) = l_dva;
0049 
0050 dvat= reshape(dva(:,idx),[],l_dva);
0051  
0052 sol = one_step_inv * dvat;
0053 
0054 <span class="comment">% create a data structure to return</span>
0055 img.name= <span class="string">'solved by time_prior_solve'</span>;
0056 img.elem_data = sol;
0057 img.inv_model= inv_model;
0058 img.fwd_model= fwd_model;
0059 
0060 <span class="comment">% calculate the one_step_inverse using the standard</span>
0061 <span class="comment">% formulation (JtWJ + hp^2*RtR)\JtW</span>
0062 <a name="_sub1" href="#_subfunctions" class="code">function one_step_inv= standard_form( inv_model, J )</a>
0063     RtR = <a href="../../../eidors/algorithms/calc_RtR_prior.html" class="code" title="function RtR_prior = calc_RtR_prior( inv_model )">calc_RtR_prior</a>( inv_model );
0064     W   = <a href="../../../eidors/algorithms/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model );
0065     hp  = <a href="../../../eidors/algorithms/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model );
0066 
0067     time_steps = inv_model.time_prior_solve.time_steps;
0068     l_ts  = time_steps*2 + 1;
0069 
0070     JtWJ = kron( speye(l_ts), J'*W*J);
0071     JtW  = kron( speye(l_ts), J'*W);
0072     one_step_inv= (JtWJ +  hp^2*RtR)\JtW;
0073 
0074     n_el= size(J,2);
0075     one_step_inv= one_step_inv(n_el*time_steps + (1:n_el),:);
0076 
0077 <span class="comment">% calculate the one_step_inverse using the data form</span>
0078 <span class="comment">% CovX * J' * inv(J*CovX*J' + CovZ)</span>
0079 <span class="comment">%   iRtR*Jt/(Ji*RtR*Jt +  hp^2*iW);</span>
0080 <a name="_sub2" href="#_subfunctions" class="code">function one_step_inv= data_form( inv_model, J );</a>
0081     space_prior= inv_model.time_smooth_prior.space_prior;
0082     time_weight= inv_model.time_smooth_prior.time_weight;
0083     ts         = inv_model.time_prior_solve.time_steps;
0084 
0085     space_Reg= feval(space_prior, inv_model);
0086 
0087     iRtRJt_frac=  (space_Reg\J');
0088     JiRtRJt_frac= J*iRtRJt_frac;
0089 
0090     <span class="comment">% JiRtRJt_mult accounts for different parts of the</span>
0091     <span class="comment">% frame being taken at different times</span>
0092     delta_vec= <a href="#_sub3" class="code" title="subfunction delta_vec= calc_delta( inv_model, J)">calc_delta</a>( inv_model, J);
0093     delta_vec1= delta_vec*ones(1,length(delta_vec));
0094     JiRtRJt_mult = time_weight.^abs(delta_vec1 - delta_vec1');
0095 
0096     [x,y]= meshgrid(-ts:ts,  -ts:ts);
0097     time_w_mat= time_weight.^abs(x-y);
0098 
0099     JiRtRJt= kron( time_w_mat, JiRtRJt_frac .* JiRtRJt_mult );
0100 
0101     <span class="comment">%FIXME: do we multiply be JiRtRJt_mult here?</span>
0102     iRtRJt=  kron( time_w_mat(ts+1,:), iRtRJt_frac );
0103 
0104     iW   = kron( speye(1+2*ts), inv( <span class="keyword">...</span>
0105                  <a href="../../../eidors/algorithms/calc_meas_icov.html" class="code" title="function meas_icov = calc_meas_icov( inv_model )">calc_meas_icov</a>( inv_model ) ));
0106     hp   = <a href="../../../eidors/algorithms/calc_hyperparameter.html" class="code" title="function hyperparameter = calc_hyperparameter( inv_model )">calc_hyperparameter</a>( inv_model );
0107 
0108     one_step_inv= iRtRJt/(JiRtRJt +  hp^2*iW);
0109 
0110 <span class="comment">% if measurements are taken at different times,</span>
0111 <span class="comment">% then calculate a delta of each wrt the centre time</span>
0112 <a name="_sub3" href="#_subfunctions" class="code">function delta_vec= calc_delta( inv_model, J)</a>
0113    stimulation= inv_model.fwd_model.stimulation;
0114    n_N= size(J,1);
0115 
0116    <span class="keyword">if</span> isfield(stimulation(1),<span class="string">'delta_time'</span>)
0117       delta_time= [stimulation(:).delta_time];
0118       <span class="keyword">if</span> diff(delta_time) ~= 0;
0119          error(<span class="string">'All time steps must be same for kalman filter'</span>);
0120       <span class="keyword">end</span>
0121    <span class="keyword">else</span>
0122       delta_time=0;
0123    <span class="keyword">end</span>
0124 
0125    <span class="comment">% sequence is a vector location of each stimulation in the frame</span>
0126    <span class="keyword">if</span> delta_time == 0
0127       seq= size(J,1);
0128    <span class="keyword">else</span>
0129       <span class="keyword">for</span> i=1:length(stimulation)
0130          seq(i) = size(stimulation(i).meas_pattern,1);
0131       <span class="keyword">end</span>
0132       seq= cumsum( seq );
0133    <span class="keyword">end</span>
0134 
0135    delta_time= cumsum(delta_time);
0136 
0137    delta_vec= zeros(size(J,1),1);
0138    seq= [0;seq(:)];
0139    <span class="keyword">for</span> i=1:length(seq)-1
0140       delta_vec( (seq(i)+1):seq(i+1) )= delta_time(i);
0141    <span class="keyword">end</span>
0142 
0143    <span class="comment">% normalize so middle time is centre, and max time is 1</span>
0144    delta_vec= (delta_vec - mean(delta_vec)) / <span class="keyword">...</span>
0145               (sum(delta_time) + eps );
0146 
0147</pre></div>
<hr><address>Generated on Tue 09-Aug-2011 11:38:31 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>