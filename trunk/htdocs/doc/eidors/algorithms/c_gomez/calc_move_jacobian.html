<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of calc_move_jacobian</title>
  <meta name="keywords" content="calc_move_jacobian">
  <meta name="description" content="CALC_JACOBIAN   Computes the Jacobian matrix for conductivity and">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html?eidors/algorithms/c_gomez/calc_move_jacobian.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- ../menu.html algorithms --><!-- menu.html c_gomez -->
<h1>calc_move_jacobian
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>CALC_JACOBIAN   Computes the Jacobian matrix for conductivity and</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function J = calc_move_jacobian(fwd_model, img_bkgd) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> CALC_JACOBIAN   Computes the Jacobian matrix for conductivity and
 electrode movement variables in 3D EIT.
 Args:     fwd_model - the EIDORS object forward model
            img_bkgd - the image background conductivity
 Returns:          J - the Jacobian matrix [Jc, Jm]

 WARNING: THIS CODE IS EXPERIMENTAL AND GIVES PROBLEMS
 SEE: Camille Gomez-Laberge, Andy Adler
 Direct EIT Jacobian calculations for conductivity change
  and electrode movement,  Physiol. Meas., 29:S89-S99, 2008</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/a_adler/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>	AA_FWD_PARAMETERS: data= aa_fwd_solve( fwd_model, image)</li><li><a href="../../../eidors/algorithms/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>	CALC_SYSTEM_MAT: calculate FEM system matrix from fwd_model and image</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG: eidors progress and status messages</li><li><a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function Ce= connectivity_matrix( pp );</a></li><li><a href="#_sub2" class="code">function [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );</a></li><li><a href="#_sub3" class="code">function J= nodes_to_stim_jacobian( delV, fwd_model, pp )</a></li><li><a href="#_sub4" class="code">function Jc = calc_conductivity_jacobian(pp, fwd_model, img_bkgd);</a></li><li><a href="#_sub5" class="code">function Jm = calc_movement_jacobian(pp, fwd_model, img_bkgd)</a></li><li><a href="#_sub6" class="code">function delVm=  calc_delVm( elec_nodes, pp, fwd_model, img_bkgd, colidx)</a></li><li><a href="#_sub7" class="code">function SS= calc_unconnected_system_mat( fwd_model, img)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function J = calc_move_jacobian(fwd_model, img_bkgd)</a>
0002 <span class="comment">% CALC_JACOBIAN   Computes the Jacobian matrix for conductivity and</span>
0003 <span class="comment">% electrode movement variables in 3D EIT.</span>
0004 <span class="comment">% Args:     fwd_model - the EIDORS object forward model</span>
0005 <span class="comment">%            img_bkgd - the image background conductivity</span>
0006 <span class="comment">% Returns:          J - the Jacobian matrix [Jc, Jm]</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% WARNING: THIS CODE IS EXPERIMENTAL AND GIVES PROBLEMS</span>
0009 <span class="comment">% SEE: Camille Gomez-Laberge, Andy Adler</span>
0010 <span class="comment">% Direct EIT Jacobian calculations for conductivity change</span>
0011 <span class="comment">%  and electrode movement,  Physiol. Meas., 29:S89-S99, 2008</span>
0012 
0013 <span class="comment">% (C) 2007, Camille Gomez-Laberge and Andy Adler.</span>
0014 <span class="comment">%  License: GPL version 2 or version 3</span>
0015 <span class="comment">% $Id$</span>
0016 
0017 warning(<span class="string">'THIS CODE IS KNOWN TO HAVE BUGS - use with care'</span>);
0018 
0019 <span class="comment">% System matrix and its parameters</span>
0020 
0021 pp = <a href="../../../eidors/algorithms/a_adler/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>( fwd_model );
0022 pp.dfact = factorial(pp.n_dims);
0023 pp.DEBUG = 1;
0024 <span class="keyword">if</span> pp.DEBUG
0025     pp.ss_mat = <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( fwd_model, img_bkgd);
0026     pp.fwd_meas =<a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>( fwd_model, img_bkgd);
0027 <span class="keyword">end</span>
0028 
0029 pp.Ce= <a href="#_sub1" class="code" title="subfunction Ce= connectivity_matrix( pp );">connectivity_matrix</a>( pp );
0030 s_mat= <a href="../../../eidors/algorithms/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>( fwd_model, img_bkgd );
0031 [pp.Vc, pp.Re] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, fwd_model, s_mat.E );
0032 Jc = <a href="#_sub4" class="code" title="subfunction Jc = calc_conductivity_jacobian(pp, fwd_model, img_bkgd);">calc_conductivity_jacobian</a>(pp, fwd_model, img_bkgd);
0033 Jm = <a href="#_sub5" class="code" title="subfunction Jm = calc_movement_jacobian(pp, fwd_model, img_bkgd)">calc_movement_jacobian</a>(pp, fwd_model, img_bkgd);
0034 J=[Jc,Jm];
0035 
0036 <span class="keyword">if</span> pp.normalize
0037     data= <a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>( img_bkgd );
0038     J= J ./ (data.meas(:)*ones(1,size(J,2)));
0039 <span class="keyword">end</span>
0040 
0041 
0042 
0043 <span class="comment">% Define the element connectivity matrix Ce</span>
0044 <a name="_sub1" href="#_subfunctions" class="code">function Ce= connectivity_matrix( pp );</a>
0045 lengthX = (pp.n_dims+1)*pp.n_elem;
0046 lengthY = pp.n_node;
0047 Xidx = pp.ELEM(:);
0048 Yidx = ones(lengthX, 1);
0049 Ce = sparse(1:lengthX, Xidx, Yidx, lengthX, lengthY);
0050 
0051 
0052 
0053 <span class="comment">% Calculate fwd_solution and Impedance mapper matrices</span>
0054 <a name="_sub2" href="#_subfunctions" class="code">function [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );</a>
0055 <span class="comment">% Define the stimulation matrix Vc for each node I, and pattern</span>
0056 <span class="comment">% Ground node is never excited; remove it from the index</span>
0057 nodeidx = 1:pp.n_node;
0058 nodeidx( fwd_model.gnd_node ) = [];
0059 
0060 <span class="comment">% The stimulation matrix Vc is the voltage at each node (row) for a</span>
0061 <span class="comment">% stimulation (column)</span>
0062 Vc = zeros(pp.n_node, pp.n_stim);
0063 Vc(nodeidx, :) = s_mat(nodeidx, nodeidx) \ pp.QQ(nodeidx,:);
0064 
0065 <span class="comment">% Define the electrode resistance matrix Re</span>
0066 <span class="comment">% Calculate the resistance between electrodes (row) and all nodes (col)</span>
0067 <span class="comment">% N2E matrix maps each electrode to its node(s); we exclude GND</span>
0068 Re = zeros(pp.n_elec, pp.n_node);
0069 Re(:, nodeidx) = pp.N2E(:, nodeidx) / s_mat(nodeidx, nodeidx);
0070 
0071 <span class="comment">% FIXME: why do we calculate the negative??</span>
0072 Re = -Re;
0073 
0074 
0075 
0076 <span class="comment">% Calculate Meas jacobian from derivative on nodes</span>
0077 <span class="comment">% Input delVc</span>
0078 <span class="comment">% Ouput J</span>
0079 <a name="_sub3" href="#_subfunctions" class="code">function J= nodes_to_stim_jacobian( delV, fwd_model, pp )</a>
0080 
0081 sz_out= size(delV,3);
0082 <span class="comment">% Define the conductivity Jacobian Jc</span>
0083 J = zeros(pp.n_meas, sz_out);
0084 <span class="comment">% Calculate the Jacobian columns for each stimulation pattern</span>
0085 rowidx = 0;
0086 <span class="keyword">for</span> j = 1:pp.n_stim
0087     <span class="comment">% Get the measurement pattern for the stimulation pattern j</span>
0088     meas_pattern = fwd_model.stimulation(j).meas_pattern;
0089     n_measj = size(meas_pattern, 1);
0090     <span class="comment">% Extract the voltage sensitivity for electrode j</span>
0091     delVcj = reshape( delV(:,j,:), pp.n_elec, sz_out);
0092     <span class="comment">% Calculate sensitivity block for measurements during stimulation j</span>
0093     J(rowidx+(1:n_measj), :) = meas_pattern*delVcj;
0094     rowidx = rowidx+n_measj;
0095 <span class="keyword">end</span>
0096 
0097 
0098 
0099 <span class="comment">% CONDUCTIVITY JACOBIAN (Based on Andy Adler's 1996 algorithms)</span>
0100 <span class="comment">% Define the voltage sensitivity delVc on electrode I, for stimulation</span>
0101 <span class="comment">% pattern J, for a change in conductivity of element K as a 3D array</span>
0102 <a name="_sub4" href="#_subfunctions" class="code">function Jc = calc_conductivity_jacobian(pp, fwd_model, img_bkgd);</a>
0103 delVc = zeros(pp.n_elec, pp.n_stim, pp.n_elem);
0104 <span class="comment">% Calculate the values for the voltage sensitivity for each element</span>
0105 <span class="keyword">for</span> k = 1:pp.n_elem
0106     <span class="keyword">if</span> ~mod(k,500)
0107         fprintf(<span class="string">'   JC: element # %d\n'</span>,k);
0108     <span class="keyword">end</span>
0109     <span class="comment">% Extract the coordinates of the element's four nodes</span>
0110     Ae = pp.NODE(:,pp.ELEM(:,k))';
0111     <span class="comment">% Augment Ae by adding a column of ones to invert</span>
0112     Ae = inv([ones(pp.n_dims+1,1), Ae]);
0113     <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0114     Be = Ae(2:pp.n_dims+1,:);
0115     <span class="comment">% Calculate the system submatrix subSe for the element i</span>
0116     subSe = 2*Be'*Be/pp.dfact/abs(det(Ae));
0117     <span class="comment">% Select the same submatrix of Ce</span>
0118     subidx = (pp.n_dims+1)*(k-1)+1 : (pp.n_dims+1)*k;
0119     <span class="comment">% The system submatrix is given by the product</span>
0120     <span class="keyword">if</span> ~pp.DEBUG
0121         delVc(:,:,k) = pp.Re * pp.Ce(subidx,:)' * subSe * pp.Ce(subidx,:)<span class="keyword">...</span>
0122             * pp.Vc;
0123     <span class="keyword">else</span>
0124         sz= (pp.n_dims+1)*pp.n_elem;
0125         delSe = sparse(sz,sz);
0126         se_idx= (pp.n_dims+1)*k+(-pp.n_dims : 0);
0127         delSe(se_idx, se_idx) = subSe;
0128 
0129         delVc(:,:,k) = pp.Re * pp.Ce' * delSe * pp.Ce * pp.Vc;
0130 
0131         <span class="keyword">if</span> mod(k,50) == 0
0132             delta=1e-6;
0133             img_delta = img_bkgd;
0134             img_delta.elem_data(k) = img_delta.elem_data(k) + delta;
0135             ss_mat_delta= <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( fwd_model, img_delta);
0136             delSe_pert = (ss_mat_delta - pp.ss_mat) / delta;
0137 
0138             <span class="keyword">if</span> norm(delSe -delSe_pert ,1) &gt; 1e-6
0139                 <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'delSe calc wrong'</span>,1);
0140             <span class="keyword">end</span>
0141         <span class="keyword">end</span>
0142     <span class="keyword">end</span>
0143 
0144 <span class="keyword">end</span>
0145 Jc= <a href="#_sub3" class="code" title="subfunction J= nodes_to_stim_jacobian( delV, fwd_model, pp )">nodes_to_stim_jacobian</a>( delVc, fwd_model, pp );
0146 
0147 
0148 
0149 <span class="comment">% MOVEMENT JACOBIAN</span>
0150 <a name="_sub5" href="#_subfunctions" class="code">function Jm = calc_movement_jacobian(pp, fwd_model, img_bkgd)</a>
0151 <span class="comment">% The movement Jacobian is defined for each coordinate Jm = [Jmx Jmy Jmz]</span>
0152 <span class="comment">% Define the voltage sensitivity delVm on electrode I, for stimulation</span>
0153 <span class="comment">% pattern J, for a movement of electrode K as a 3D array</span>
0154 delVm = zeros(pp.n_elec, pp.n_stim, pp.n_elec*pp.n_dims);
0155 <span class="keyword">for</span> colidx = 1:pp.n_dims
0156     fprintf(<span class="string">'   JM: direction # %d\n'</span>,colidx);
0157     <span class="comment">% Calculate the values for the voltage sensitivity for each electrode</span>
0158     <span class="keyword">for</span> k = 1:pp.n_elec
0159         <span class="comment">% Find which elements touch this electrode</span>
0160         elec_nodes = fwd_model.electrode(k).nodes;
0161  
0162         <span class="comment">%for compound electrodes, average jacobian for each node</span>
0163         delVm_part = zeros(pp.n_elec);
0164         <span class="keyword">for</span> each_elec_node= elec_nodes(:)';
0165            delVm_part =  delVm_part + <span class="keyword">...</span>
0166                 <a href="#_sub6" class="code" title="subfunction delVm=  calc_delVm( elec_nodes, pp, fwd_model, img_bkgd, colidx)">calc_delVm</a>(each_elec_node,pp,fwd_model,img_bkgd,colidx);
0167         <span class="keyword">end</span>
0168         delVm_part = delVm_part/length(elec_nodes);
0169 
0170         vm_idx= k + pp.n_elec*(colidx-1);
0171         delVm(:,:,vm_idx) = delVm_part;
0172 
0173         <span class="keyword">if</span> pp.DEBUG
0174             delta=1e-8;
0175             mdl_delta = fwd_model;
0176             mdl_delta.nodes(elec_nodes, colidx) = <span class="keyword">...</span>
0177                 mdl_delta.nodes(elec_nodes, colidx) + delta;
0178             S= <a href="../../../eidors/algorithms/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>( mdl_delta, img_bkgd); S=S.E;
0179 keyboard
0180             [Vc_delta] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, mdl_delta, S);
0181             delVm_pert = pp.N2E*(Vc_delta - pp.Vc) / delta;
0182             nn = norm(delVm_part - delVm_pert,1 ); <span class="comment">% WHY NEGATIVE?</span>
0183 
0184             <span class="keyword">if</span> nn &gt; 5e-5 ; keyboard; <span class="keyword">end</span>
0185         <span class="keyword">end</span>
0186     <span class="keyword">end</span>
0187 <span class="keyword">end</span>
0188 Jm= <a href="#_sub3" class="code" title="subfunction J= nodes_to_stim_jacobian( delV, fwd_model, pp )">nodes_to_stim_jacobian</a>( delVm, fwd_model, pp );
0189 
0190 
0191 
0192 <a name="_sub6" href="#_subfunctions" class="code">function delVm=  calc_delVm( elec_nodes, pp, fwd_model, img_bkgd, colidx)</a>
0193 [rowidx, elemidx] = find(pp.ELEM == elec_nodes);
0194 <span class="comment">% Define the system sensitivity matrix to movement delSm</span>
0195 sz= (pp.n_dims+1)*pp.n_elem;
0196 delSm = sparse(sz,sz);
0197 <span class="comment">% For each touching element, calculate the perturbation</span>
0198 jcount = 1;
0199 <span class="keyword">for</span> j = elemidx'
0200     <span class="comment">% Extract the coordinates of the element's four nodes</span>
0201     Ae = pp.NODE(:,pp.ELEM(:, j))';
0202     <span class="comment">% Define the invertible matrix P: augment Ae by adding a</span>
0203     <span class="comment">% column of ones to invert</span>
0204     P = [ones(pp.n_dims+1,1), Ae];
0205     Ae = inv(P);
0206     absdetAe = abs(det(Ae));
0207     <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0208     Be = Ae(2:pp.n_dims+1,:);
0209     <span class="comment">% For this coordinate, perturb P by [rowidx,colidx], which are</span>
0210     <span class="comment">% our paper's perturbation vectors [a,b]</span>
0211     a = zeros(pp.n_dims+1,1);
0212     b = a;
0213     a(rowidx(jcount)) = 1;
0214     jcount = jcount + 1;
0215     b(colidx+1) = 1;
0216     <span class="comment">% Calculate the system submatrix subSm for the element j by</span>
0217     <span class="comment">% asymmetric perturbation of the electrode node k</span>
0218     deldetAe =   1/absdetAe*b'*Ae*a;
0219     delBe = -Ae*a*b'*Ae;
0220     delBe = delBe(2:pp.n_dims+1,:);
0221     subSm = 2/pp.dfact*(<span class="keyword">...</span>
0222         deldetAe*Be'*Be + <span class="keyword">...</span>
0223         delBe'*Be/absdetAe + <span class="keyword">...</span>
0224         Be'*delBe/absdetAe);
0225 
0226     <span class="keyword">if</span> pp.DEBUG
0227         delta=1e-8;
0228         subSe = 2*Be'*Be/pp.dfact/abs(det(Ae));
0229         d_NODE= pp.NODE;
0230         d_NODE(colidx,elec_nodes) =  d_NODE(colidx,elec_nodes) + delta;
0231         Ae = d_NODE(:,pp.ELEM(:, j))';
0232         Ae = inv( [ones(pp.n_dims+1,1), Ae] );
0233         absdetAe_pert = abs(det(Ae));
0234         deldetAe_pert = (absdetAe_pert - absdetAe) / delta;
0235         <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0236         Be = Ae(2:pp.n_dims+1,:);
0237         subSe_delta = 2*Be'*Be/pp.dfact/abs(det(Ae));
0238         subSm_pert= (subSe_delta - subSe ) / delta;
0239         <span class="keyword">if</span> norm(subSm_pert - subSm,1) &gt; 1e-5
0240             <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'subSm calc wrong'</span>,1);
0241             dd= (subSm_pert - 2/pp.dfact/absdetAe *<span class="keyword">...</span>
0242                 (delBe'*Be + Be'*delBe) )./(Be'*Be);
0243 
0244             fprintf(<span class="string">'colidx=%d, j=%d std=%6.4f &gt;'</span>,<span class="keyword">...</span>
0245                 colidx,j, std(dd(:)));
0246             keyboard
0247             subSm= subSm_pert;
0248         <span class="keyword">end</span>
0249     <span class="keyword">end</span>
0250 
0251     <span class="comment">% Embed subSm into delSm such that subSm(1,1) is the</span>
0252     <span class="comment">% (4j+1,4j+1) element of delSm</span>
0253     se_idx= (pp.n_dims+1)*j+(-pp.n_dims : 0);
0254     delSm(se_idx, se_idx) = subSm;
0255 <span class="keyword">end</span>
0256 
0257 <span class="comment">% The system submatrix is given by the product where delSm is</span>
0258 <span class="comment">% non-zero only in submatrices corresponding to touching elements</span>
0259 delVm = pp.Re * pp.Ce' * delSm * pp.Ce * pp.Vc;
0260 <span class="keyword">if</span> pp.DEBUG
0261     delta=1e-8;
0262     mdl_delta = fwd_model;
0263     mdl_delta.nodes(elec_nodes, colidx) = <span class="keyword">...</span>
0264         mdl_delta.nodes(elec_nodes, colidx) + delta;
0265     ss_mat_delta= <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( mdl_delta, img_bkgd );
0266     delSm_pert = (ss_mat_delta - pp.ss_mat) / delta;
0267     <span class="comment">% delSe_pert shound be Ce'*delSe*Ce</span>
0268     <span class="keyword">if</span> norm(delSm -delSm_pert ,1) &gt; 1e-5
0269         <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'delSm calc wrong'</span>,1);
0270         delVm = pp.Re * pp.Ce' * delSm_pert * pp.Ce * pp.Vc;
0271         keyboard
0272     <span class="keyword">end</span>
0273 <span class="keyword">end</span>
0274 
0275 
0276 
0277 <a name="_sub7" href="#_subfunctions" class="code">function SS= calc_unconnected_system_mat( fwd_model, img)</a>
0278 <span class="comment">% Calc system matrix for Andy Adler's EIT code</span>
0279 <span class="comment">% fwd_model = forward model</span>
0280 <span class="comment">% img       = image background for system matrix calc</span>
0281 <span class="comment">% s_mat = CC' * SS * conductivites * CC;</span>
0282 <span class="comment">% where:</span>
0283 <span class="comment">%   SS  = Unconnected system Matrix</span>
0284 <span class="comment">%   CC  = Connectivity Matrix</span>
0285 
0286 p= <a href="../../../eidors/algorithms/a_adler/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>( fwd_model );
0287 
0288 d= p.n_dims+1;
0289 e= p.n_elem;
0290 n= p.n_node;
0291 
0292 SSiidx= floor([0:d*e-1]'/d)*d*ones(1,d) + ones(d*e,1)*(1:d) ;
0293 SSjidx= [1:d*e]'*ones(1,d);
0294 SSdata= zeros(d*e,d);
0295 dfact= (d-1)*(d-2); <span class="comment">% Valid for d&lt;=3</span>
0296 <span class="keyword">for</span> j=1:e
0297     a=  inv([ ones(d,1), p.NODE( :, p.ELEM(:,j) )' ]);
0298     idx= d*(j-1)+1 : d*j;
0299     SSdata(idx,1:d)= 2*a(2:d,:)'*a(2:d,:)/dfact/abs(det(a));
0300 <span class="keyword">end</span> <span class="comment">%for j=1:ELEMs</span>
0301 idx= 1:e*d;
0302 SS= sparse(SSiidx,SSjidx,SSdata) * <span class="keyword">...</span>
0303     sparse(idx,idx, img.elem_data(ceil(idx/d)) );
0304 
0305 <span class="keyword">return</span>
0306 
0307 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0308 <span class="comment">% TEST CODE FOR MATRIX DERIVATIVES</span>
0309 
0310 <span class="comment">% TEST dertiv of det(X + t*a*b')</span>
0311 
0312 d= 1e-6;
0313 X= rand(5);
0314 a=zeros(5,1); a(ceil(5*rand))=1;
0315 b=zeros(5,1); b(ceil(5*rand))=1;
0316 dX_p= (det(X + d*a*b') - det(X) )/d;
0317 dX  = b'*inv(X)*a*det(X);
0318 disp([dX_p dX]);
0319 
0320 <span class="comment">% TEST dertiv of inv(X + t*a*b')</span>
0321 dX_p= (inv(X + d*a*b') - inv(X) )/d;
0322 dX  = -inv(X)*a*b'*inv(X);
0323 disp(norm([dX_p-dX],1));
0324 
0325 <span class="comment">% TEST dertiv of 1/abs(det(X + t*a*b')) = abs(1/det(X+t*a*b'))</span>
0326 <span class="keyword">for</span> i=1:20
0327     X= rand(5);
0328     a=zeros(5,1); a(ceil(5*rand))=1;
0329     b=zeros(5,1); b(ceil(5*rand))=1;
0330     dX_p= (1/abs(det(X + d*a*b')) - 1/abs(det(X)) )/d;
0331     dX  = - 1/abs(det(X))*b'*inv(X)*a;
0332     disp(norm([dX_p-dX])/norm(dX));
0333 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 09-Aug-2011 11:38:31 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>