<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_grid_model</title>
  <meta name="keywords" content="mk_grid_model">
  <meta name="description" content="MK_GRID_MODEL: Create reconstruction model on pixelated grid">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html?eidors/models/a_adler/mk_grid_model.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- # models --><!-- menu.html a_adler -->
<h1>mk_grid_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>MK_GRID_MODEL: Create reconstruction model on pixelated grid</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> MK_GRID_MODEL: Create reconstruction model on pixelated grid 
  [cmdl,coarse2fine]= mk_grid_model(fmdl, xvec, yvec, zvec);

 Outputs:
  cmdl - eidors reconstruction model (coarse model)
  coarse2fine - c2f mapping to put onto fmdl (specify [] to not use)

 Inputs:
  fmdl - fine model (forward model) to create coarse2fine mapping
  xvec - x edges
  yvec - y edges
  zvec - z edges (optional - to create 3D model)

 if fmdl == [], then just create the grid model without c2f</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/a_adler/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>	MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach</li><li><a href="mk_common_gridmdl.html" class="code" title="function inv_mdl= mk_common_gridmdl( str, RM)">mk_common_gridmdl</a>	MK_COMMON_MODEL: make EIT on reconstruction grids (GREIT)</li><li><a href="../../../eidors/tests/test_2d_resistor.html" class="code" title="">test_2d_resistor</a>	Create 2D model of a cylindrical resistor</li><li><a href="../../../eidors/tests/test_3d_resistor.html" class="code" title="">test_3d_resistor</a>	Create 3D model of a Rectangular resistor</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function c2f= calc_c2f_2d( fmdl, xvec, yvec);</a></li><li><a href="#_sub2" class="code">function c2f= calc_c2f_3d( fmdl, xvec, yvec, zvec);</a></li><li><a href="#_sub3" class="code">function cmdl= mk_2d_grid(xvec, yvec);</a></li><li><a href="#_sub4" class="code">function cmdl= mk_3d_grid(xvec, yvec, zvec);</a></li><li><a href="#_sub5" class="code">function in_d_pts = calc_in_d_pts( d_pts, dvec);</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);</a>
0002 <span class="comment">% MK_GRID_MODEL: Create reconstruction model on pixelated grid</span>
0003 <span class="comment">%  [cmdl,coarse2fine]= mk_grid_model(fmdl, xvec, yvec, zvec);</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Outputs:</span>
0006 <span class="comment">%  cmdl - eidors reconstruction model (coarse model)</span>
0007 <span class="comment">%  coarse2fine - c2f mapping to put onto fmdl (specify [] to not use)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Inputs:</span>
0010 <span class="comment">%  fmdl - fine model (forward model) to create coarse2fine mapping</span>
0011 <span class="comment">%  xvec - x edges</span>
0012 <span class="comment">%  yvec - y edges</span>
0013 <span class="comment">%  zvec - z edges (optional - to create 3D model)</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% if fmdl == [], then just create the grid model without c2f</span>
0016 
0017 <span class="comment">% (C) 2008 Andy Adler. License: GPL version 2 or version 3</span>
0018 <span class="comment">% $Id$</span>
0019 
0020 <span class="keyword">if</span> nargin == 3
0021    cmdl = <a href="#_sub3" class="code" title="subfunction cmdl= mk_2d_grid(xvec, yvec);">mk_2d_grid</a>(xvec,yvec);
0022 <span class="keyword">elseif</span> nargin ==4
0023    cmdl = <a href="#_sub4" class="code" title="subfunction cmdl= mk_3d_grid(xvec, yvec, zvec);">mk_3d_grid</a>(xvec,yvec,zvec);
0024 <span class="keyword">else</span>
0025    error(<span class="string">'check nargin'</span>);
0026 <span class="keyword">end</span>
0027 
0028 <span class="keyword">if</span> ~isempty( fmdl)
0029    <span class="keyword">if</span> nargin ==3
0030       c2f= <a href="#_sub1" class="code" title="subfunction c2f= calc_c2f_2d( fmdl, xvec, yvec);">calc_c2f_2d</a>( fmdl, xvec, yvec);
0031    <span class="keyword">elseif</span> nargin ==4
0032       c2f= <a href="#_sub2" class="code" title="subfunction c2f= calc_c2f_3d( fmdl, xvec, yvec, zvec);">calc_c2f_3d</a>( fmdl, xvec, yvec, zvec);
0033    <span class="keyword">end</span>
0034 <span class="keyword">end</span>
0035 
0036 <a name="_sub1" href="#_subfunctions" class="code">function c2f= calc_c2f_2d( fmdl, xvec, yvec);</a>
0037    nef= size( fmdl.elems,1);
0038    c2f= sparse(nef,0);
0039    mdl_pts = <a href="../../../eidors/algorithms/a_adler/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>( fmdl, 3);
0040    x_pts = squeeze(mdl_pts(:,1,:));
0041    y_pts = squeeze(mdl_pts(:,2,:));
0042    <span class="keyword">for</span> yi= 1:length(yvec)-1
0043          in_y_pts = y_pts &gt;= yvec(yi) &amp; y_pts &lt; yvec(yi+1);
0044       <span class="keyword">for</span> xi= 1:length(xvec)-1
0045           in_x_pts =  x_pts &gt;= xvec(xi) &amp; x_pts &lt; xvec(xi+1);
0046           in_pts = mean( in_y_pts &amp; in_x_pts , 2);
0047           c2f = [c2f,sparse(in_pts)];
0048       <span class="keyword">end</span>
0049    <span class="keyword">end</span>
0050 
0051 <a name="_sub2" href="#_subfunctions" class="code">function c2f= calc_c2f_3d( fmdl, xvec, yvec, zvec);</a>
0052 <span class="comment">%  c2f= mk_coarse_fine_mapping( fmdl, cmdl);</span>
0053    nef= size( fmdl.elems,1);
0054 <span class="comment">%  c2f= sparse(nef,0);</span>
0055    c2fiidx= [];
0056    c2fjidx= [];
0057    c2fdata= [];
0058    jidx= 0;
0059    mdl_pts = <a href="../../../eidors/algorithms/a_adler/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>( fmdl, 3);
0060    x_pts = squeeze(mdl_pts(:,1,:));
0061    y_pts = squeeze(mdl_pts(:,2,:));
0062    z_pts = squeeze(mdl_pts(:,3,:));
0063    
0064    in_x_pts = <a href="#_sub5" class="code" title="subfunction in_d_pts = calc_in_d_pts( d_pts, dvec);">calc_in_d_pts</a>( x_pts, xvec);
0065    in_y_pts = <a href="#_sub5" class="code" title="subfunction in_d_pts = calc_in_d_pts( d_pts, dvec);">calc_in_d_pts</a>( y_pts, yvec);
0066    in_z_pts = <a href="#_sub5" class="code" title="subfunction in_d_pts = calc_in_d_pts( d_pts, dvec);">calc_in_d_pts</a>( z_pts, zvec);
0067 
0068    <span class="keyword">for</span> zi= 1:length(zvec)-1
0069       <span class="keyword">for</span> yi= 1:length(yvec)-1
0070              in_yz_pts = in_y_pts{yi} &amp; in_z_pts{zi};
0071          <span class="keyword">for</span> xi= 1:length(xvec)-1
0072              in_pts = mean( in_x_pts{xi} &amp; in_yz_pts, 2);
0073              <span class="comment">% c2f = [c2f,sparse(in_pts)];</span>
0074              [ii,jj,vv] = find(in_pts);
0075              c2fiidx= [c2fiidx;ii];
0076              c2fjidx= [c2fjidx;jj+jidx]; jidx=jidx+1;
0077              c2fdata= [c2fdata;vv];
0078          <span class="keyword">end</span>
0079       <span class="keyword">end</span>
0080    <span class="keyword">end</span>
0081    c2f= sparse(c2fiidx,c2fjidx,c2fdata, length(in_pts), jidx);
0082 
0083 <a name="_sub3" href="#_subfunctions" class="code">function cmdl= mk_2d_grid(xvec, yvec);</a>
0084    xlen = length(xvec);
0085    ylen = length(yvec);
0086    cmdl= <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>, <span class="keyword">...</span>
0087             sprintf(<span class="string">'Grid model %d x %d'</span>, xlen, ylen) );
0088 
0089    [x,y]= ndgrid( xvec, yvec);
0090    cmdl.nodes= [x(:),y(:)];
0091    k= 1:xlen-1;
0092    elem_frac = [ k;k+1;k+xlen; <span class="keyword">...</span>
0093                  k+1;k+xlen;k+xlen+1];
0094    elem_frac= reshape(elem_frac, 3,[])';
0095    cmdl.elems=  [];
0096    <span class="keyword">for</span> j=0:ylen-2
0097       cmdl.elems=  [cmdl.elems; elem_frac + xlen*j];
0098    <span class="keyword">end</span>
0099 
0100    cmdl.boundary = <a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>( cmdl.elems);
0101 
0102 <span class="comment">% assign one single parameter to each square element</span>
0103    e= size(cmdl.elems,1);
0104    params= ceil(( 1:e )/2);
0105    cmdl.coarse2fine = sparse(1:e,params,1,e,max(params));
0106 
0107 <a name="_sub4" href="#_subfunctions" class="code">function cmdl= mk_3d_grid(xvec, yvec, zvec);</a>
0108    xlen = length(xvec);
0109    ylen = length(yvec);
0110    zlen = length(zvec);
0111    cmdl= <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>, <span class="keyword">...</span>
0112             sprintf(<span class="string">'Grid model %d x %d x %d'</span>, xlen, ylen, zlen) );
0113 
0114    [x,y,z]= ndgrid( xvec, yvec, zvec);
0115    cmdl.nodes= [x(:),y(:),z(:)];
0116    k= 1:xlen-1;
0117    ac = xlen; up = xlen*ylen; <span class="comment">% accross vs up</span>
0118    elem_frac = [ k;     k+1 ;  k+ac;   k+up;  <span class="keyword">...</span>
0119                  k+1;   k+ac;  k+up;   k+up+1; <span class="keyword">...</span>
0120                  k+ac;  k+up;  k+up+1; k+up+ac; <span class="keyword">...</span>
0121                  k+1;   k+ac;  k+ac+1; k+up+1; <span class="keyword">...</span>
0122                  k+ac;  k+ac+1;k+up+1; k+up+ac; <span class="keyword">...</span>
0123                  k+ac+1;k+up+1;k+up+ac;k+up+ac+1];
0124    elem_frac= reshape(elem_frac, 4,[])';
0125 
0126    row_frac =  [];
0127    <span class="keyword">for</span> j=0:ylen-2
0128       row_frac=  [row_frac; elem_frac + ac*j];
0129    <span class="keyword">end</span>
0130 
0131    cmdl.elems=  [];
0132    <span class="keyword">for</span> k=0:zlen-2
0133       cmdl.elems=  [cmdl.elems; row_frac + up*k];
0134    <span class="keyword">end</span>
0135 
0136    cmdl.boundary = <a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>( cmdl.elems);
0137 
0138 <span class="comment">% assign one single parameter to each square element</span>
0139    e= size(cmdl.elems,1);
0140    params= ceil(( 1:e )/6);
0141    cmdl.coarse2fine = sparse(1:e,params,1,e,max(params));
0142 
0143 
0144 <a name="_sub5" href="#_subfunctions" class="code">function in_d_pts = calc_in_d_pts( d_pts, dvec);</a>
0145    l1dvec= length(dvec)-1;
0146    in_d_pts = cell(l1dvec,1);
0147    <span class="keyword">for</span> i= 1:l1dvec
0148       in_d_pts{i} = d_pts &gt;= dvec(i) &amp; d_pts &lt; dvec(i+1);
0149    <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 09-Aug-2011 11:38:31 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>