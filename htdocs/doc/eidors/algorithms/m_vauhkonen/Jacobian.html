<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Jacobian</title>
  <meta name="keywords" content="Jacobian">
  <meta name="description" content="Jacobian Computes the Jacobian for 2D EIT when elementwise basis is used">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- ../menu.html algorithms --><!-- menu.html m_vauhkonen -->
<h1>Jacobian
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Jacobian Computes the Jacobian for 2D EIT when elementwise basis is used</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [J]=Jacobian(Node,Element,Agrad,U,U0,rho,style); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Jacobian Computes the Jacobian for 2D EIT when elementwise basis is used
 Function [J]=Jacobian(g,H,Agrad,U,U0,rho,style);
 computes the Jacobian for 2D EIT when elementwise basis
 is used.

 INPUT

 Node = nodal data structure
 Element = element data structure
 Agrad = \int_{Element(ii) \nabla\phi_i\cdot\nabla\phi_j
 U = voltages corresponding to the injected currents
 U0 = voltages corresponding to the measurement field
 rho = resistivity or admittivity vector
 style = either 'real' for reconstructing resistivity or 'comp' 
 for reconstructin admittivity 

 OUTPUT

 J = Jacobian</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/models/m_vauhkonen/grinprodgaus.html" class="code" title="function int=grinprodgaus(g,sigma);">grinprodgaus</a>	grinprodgaus Computes the integral of the product of the gradients in 2D FEM</li><li><a href="../../../eidors/models/m_vauhkonen/grinprodgausquad.html" class="code" title="function int=grinprodgausquad(g,sigma);">grinprodgausquad</a>	grinprodgausquad Computes the integral of the product of the gradients in 2D FEM for quadratic isoparametric triangular elements</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/examples/eidors2d_demo1.html" class="code" title="">eidors2d_demo1</a>	EidorsDemo1 Demonstrates the use of 2D EIT Package with linear basis</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [J]=Jacobian(Node,Element,Agrad,U,U0,rho,style);</a>
0002 
0003 <span class="comment">%Jacobian Computes the Jacobian for 2D EIT when elementwise basis is used</span>
0004 <span class="comment">% Function [J]=Jacobian(g,H,Agrad,U,U0,rho,style);</span>
0005 <span class="comment">% computes the Jacobian for 2D EIT when elementwise basis</span>
0006 <span class="comment">% is used.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% INPUT</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Node = nodal data structure</span>
0011 <span class="comment">% Element = element data structure</span>
0012 <span class="comment">% Agrad = \int_{Element(ii) \nabla\phi_i\cdot\nabla\phi_j</span>
0013 <span class="comment">% U = voltages corresponding to the injected currents</span>
0014 <span class="comment">% U0 = voltages corresponding to the measurement field</span>
0015 <span class="comment">% rho = resistivity or admittivity vector</span>
0016 <span class="comment">% style = either 'real' for reconstructing resistivity or 'comp'</span>
0017 <span class="comment">% for reconstructin admittivity</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% OUTPUT</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% J = Jacobian</span>
0022 
0023 <span class="comment">% M. Vauhkonen 13.8.1999,</span>
0024 <span class="comment">% University of Kuopio, Department of Applied Physics, PO Box 1627,</span>
0025 <span class="comment">% FIN-70211 Kuopio, Finland, email: Marko.Vauhkonen@uku.fi</span>
0026 
0027 
0028 NNode=max(size(Node));
0029 NElement=max(size(Element));
0030 
0031 <span class="keyword">if</span> nargin&lt;3 
0032 Agrad=sparse(NNode^2,NElement); <span class="comment">% Gradients of the basis functions integrated over</span>
0033                        <span class="comment">% each element.</span>
0034 
0035  <span class="keyword">for</span> ii=1:NElement
0036   ind=Element(ii).Topology;
0037   gg=reshape([Node(ind).Coordinate],2,max(size(ind)))'; <span class="comment">% A 3x2 or 6x2 matrix of triangle vertices in (x,y) coord.</span>
0038   <span class="keyword">if</span> max(size(ind))==3
0039    anis=<a href="../../../eidors/models/m_vauhkonen/grinprodgaus.html" class="code" title="function int=grinprodgaus(g,sigma);">grinprodgaus</a>(gg,1);
0040   <span class="keyword">else</span>
0041    anis=<a href="../../../eidors/models/m_vauhkonen/grinprodgausquad.html" class="code" title="function int=grinprodgausquad(g,sigma);">grinprodgausquad</a>(gg,1);
0042   <span class="keyword">end</span>
0043   Aa=sparse(NNode,NNode);
0044   Aa(ind,ind)=anis;
0045   Agrad(:,ii)=Aa(:);    
0046  <span class="keyword">end</span>
0047  J=Agrad;
0048 <span class="keyword">else</span>
0049 <span class="keyword">if</span> style==<span class="string">'comp'</span>
0050   J=zeros(size(U,2)*size(U0,2),2*size(Agrad,2));
0051  <span class="keyword">for</span> ii=1:size(Agrad,2);
0052     Agrad1=reshape(Agrad(:,ii),NNode,NNode);
0053     AgU1=Agrad1*U(1:NNode,:);
0054     AgU2=Agrad1*U(NNode+1:2*NNode,:);
0055     JJ=-U0.'*[AgU1;AgU2];
0056     JJ=JJ(:);
0057     J(:,ii)=JJ;
0058     JJ=-U0.'*[-AgU2;AgU1];
0059     J(:,ii+size(Agrad,2))=JJ(:);
0060  <span class="keyword">end</span>
0061 <span class="keyword">elseif</span> style==<span class="string">'real'</span> 
0062  J=zeros(size(U,2)*size(U0,2),size(Agrad,2));
0063  <span class="keyword">for</span> ii=1:size(Agrad,2);
0064   JJ=U0.'*1/rho(ii)^2*reshape(Agrad(:,ii),NNode,NNode)*U;
0065   JJ=JJ(:);
0066   J(:,ii)=JJ;
0067  <span class="keyword">end</span>
0068 <span class="keyword">end</span>
0069 <span class="keyword">end</span>
0070 
0071</pre></div>
<hr><address>Generated on Wed 13-Jul-2011 23:23:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>