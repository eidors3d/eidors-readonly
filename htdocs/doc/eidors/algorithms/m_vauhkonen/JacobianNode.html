<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of JacobianNode</title>
  <meta name="keywords" content="JacobianNode">
  <meta name="description" content="JacobianNode Computes the Jacobian for 2D EIT when node basis is used">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html?eidors/algorithms/m_vauhkonen/JacobianNode.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- ../menu.html algorithms --><!-- menu.html m_vauhkonen -->
<h1>JacobianNode
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>JacobianNode Computes the Jacobian for 2D EIT when node basis is used</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [J]=JacobianNode(Node,Element,Agrad,U,U0,rho,style); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">JacobianNode Computes the Jacobian for 2D EIT when node basis is used
 Function [J]=JacobianNode(g,H,Agrad,U,U0,rho,style);
 computes the Jacobian for 2D EIT when node basis
 is used.

 INPUT

 Node = nodal data structure
 Element = element data structure
 Agrad = \int_{Element(ii) \nabla\phi_i\cdot\nabla\phi_j
 U = voltages corresponding to the injected currents
 U0 = voltages corresponding to the measurement field
 rho = resistivity or admittivity vector
 style = either 'real' for reconstructing resistivity or 'comp'
 for reconstructin admittivity

 OUTPUT

 J = Jacobian</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/models/m_vauhkonen/grinprodgausnode.html" class="code" title="function int=grinprodgausnode(g,I);">grinprodgausnode</a>	grinprodgausnode Computes the gradient part of the system matrix</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [J]=JacobianNode(Node,Element,Agrad,U,U0,rho,style);</a>
0002 
0003 <span class="comment">%JacobianNode Computes the Jacobian for 2D EIT when node basis is used</span>
0004 <span class="comment">% Function [J]=JacobianNode(g,H,Agrad,U,U0,rho,style);</span>
0005 <span class="comment">% computes the Jacobian for 2D EIT when node basis</span>
0006 <span class="comment">% is used.</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% INPUT</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Node = nodal data structure</span>
0011 <span class="comment">% Element = element data structure</span>
0012 <span class="comment">% Agrad = \int_{Element(ii) \nabla\phi_i\cdot\nabla\phi_j</span>
0013 <span class="comment">% U = voltages corresponding to the injected currents</span>
0014 <span class="comment">% U0 = voltages corresponding to the measurement field</span>
0015 <span class="comment">% rho = resistivity or admittivity vector</span>
0016 <span class="comment">% style = either 'real' for reconstructing resistivity or 'comp'</span>
0017 <span class="comment">% for reconstructin admittivity</span>
0018 <span class="comment">%</span>
0019 <span class="comment">% OUTPUT</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% J = Jacobian</span>
0022 
0023 <span class="comment">% M. Vauhkonen 13.8.1999,</span>
0024 <span class="comment">% University of Kuopio, Department of Applied Physics, PO Box 1627,</span>
0025 <span class="comment">% FIN-70211 Kuopio, Finland, email: Marko.Vauhkonen@uku.fi</span>
0026 
0027 
0028 NNode=max(size(Node));
0029 NElement=max(size(Element));
0030 
0031 
0032 
0033 <span class="keyword">if</span> nargin&lt;3
0034 
0035 mE=max(size(Element(1).Topology));
0036 <span class="keyword">if</span> mE==3
0037  Agrad=sparse(NNode^2,NNode);
0038  H=reshape([Element.Topology],3,NElement)';
0039  mH=max(max(H)); 
0040 <span class="keyword">else</span>
0041  H=reshape([Element.Topology],6,NElement)';
0042  mH=max(max(H(:,1:2:6))); 
0043  Agrad=sparse(NNode^2,mH);
0044  clear H
0045 <span class="keyword">end</span>
0046 g=reshape([Node.Coordinate],2,NNode)';      <span class="comment">%Nodes</span>
0047 
0048 <span class="keyword">for</span> jj=1:mH
0049 Aa=sparse(NNode,NNode);
0050 El=Node(jj).ElementConnection;
0051  <span class="keyword">for</span> ii=1:max(size(El))
0052    ind=Element(El(ii)).Topology; <span class="comment">% Indices of the element</span>
0053    gg=g(ind,:);
0054    <span class="keyword">if</span> max(size(gg))==3
0055     indsig=ind;
0056     I=find(jj==indsig);
0057     anis=<a href="../../../eidors/models/m_vauhkonen/grinprodgausnode.html" class="code" title="function int=grinprodgausnode(g,I);">grinprodgausnode</a>(gg,I);
0058     Aa(ind,ind)=Aa(ind,ind)+anis;
0059    <span class="keyword">else</span>
0060      indsig=ind(1:2:6);
0061      I=find(jj==indsig);
0062      anis=grinprodgaus2ndnode(gg,I);
0063      Aa(ind,ind)=Aa(ind,ind)+anis;         
0064    <span class="keyword">end</span>  
0065  <span class="keyword">end</span>  
0066  Agrad(:,jj)=Aa(:);
0067 <span class="keyword">end</span>
0068 J=Agrad;
0069 <span class="keyword">else</span>
0070 <span class="keyword">if</span> style==<span class="string">'comp'</span>
0071   J=zeros(size(U,2)*size(U0,2),2*size(Agrad,2));
0072  <span class="keyword">for</span> ii=1:size(Agrad,2);
0073     Agrad1=reshape(Agrad(:,ii),NNode,NNode);
0074     AgU1=Agrad1*U(1:NNode,:);
0075     AgU2=Agrad1*U(NNode+1:2*NNode,:);
0076     JJ=-U0.'*[AgU1;AgU2];
0077     JJ=JJ(:);
0078     J(:,ii)=JJ;
0079     JJ=-U0.'*[-AgU2;AgU1];
0080     J(:,ii+size(Agrad,2))=JJ(:);
0081  <span class="keyword">end</span>
0082 <span class="keyword">elseif</span> style==<span class="string">'real'</span>
0083   J=zeros(size(U,2)*size(U0,2),size(Agrad,2));
0084    <span class="keyword">for</span> ii=1:size(Agrad,2);
0085     JJ=-U0.'*reshape(Agrad(:,ii),NNode,NNode)*U;
0086     JJ=JJ(:);
0087     J(:,ii)=JJ;
0088    <span class="keyword">end</span>
0089  <span class="keyword">end</span>
0090 <span class="keyword">end</span>
0091 
0092 
0093 
0094 
0095 
0096 
0097 
0098</pre></div>
<hr><address>Generated on Tue 09-Aug-2011 11:38:31 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>