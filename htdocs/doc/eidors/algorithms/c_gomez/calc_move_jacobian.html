<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of calc_move_jacobian</title>
  <meta name="keywords" content="calc_move_jacobian">
  <meta name="description" content="CALC_JACOBIAN   Computes the Jacobian matrix for conductivity and">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- ../menu.html algorithms --><!-- menu.html c_gomez -->
<h1>calc_move_jacobian
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>CALC_JACOBIAN   Computes the Jacobian matrix for conductivity and</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function J = calc_move_jacobian(fwd_model, img_bkgd) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> CALC_JACOBIAN   Computes the Jacobian matrix for conductivity and
 electrode movement variables in 3D EIT.
 Args:     fwd_model - the EIDORS object forward model
            img_bkgd - the image background conductivity
 Returns:          J - the Jacobian matrix [Jc, Jm]</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/a_adler/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>	AA_FWD_PARAMETERS: data= aa_fwd_solve( fwd_model, image)</li><li><a href="../../../eidors/algorithms/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>	CALC_SYSTEM_MAT: calculate FEM system matrix from fwd_model and image</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG: eidors progress and status messages</li><li><a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function Ce= connectivity_matrix( pp );</a></li><li><a href="#_sub2" class="code">function [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );</a></li><li><a href="#_sub3" class="code">function J= nodes_to_stim_jacobian( delV, fwd_model, pp )</a></li><li><a href="#_sub4" class="code">function Jc = calc_conductivity_jacobian(pp, fwd_model, img_bkgd);</a></li><li><a href="#_sub5" class="code">function Jm = calc_movement_jacobian(pp, fwd_model, img_bkgd)</a></li><li><a href="#_sub6" class="code">function delVm=  calc_delVm( elec_nodes, pp, fwd_model, img_bkgd, colidx)</a></li><li><a href="#_sub7" class="code">function SS= calc_unconnected_system_mat( fwd_model, img)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function J = calc_move_jacobian(fwd_model, img_bkgd)</a>
0002 <span class="comment">% CALC_JACOBIAN   Computes the Jacobian matrix for conductivity and</span>
0003 <span class="comment">% electrode movement variables in 3D EIT.</span>
0004 <span class="comment">% Args:     fwd_model - the EIDORS object forward model</span>
0005 <span class="comment">%            img_bkgd - the image background conductivity</span>
0006 <span class="comment">% Returns:          J - the Jacobian matrix [Jc, Jm]</span>
0007 
0008 <span class="comment">% (C) 2007, Camille Gomez-Laberge and Andy Adler.</span>
0009 <span class="comment">%  License: GPL version 2 or version 3</span>
0010 <span class="comment">% $Id$</span>
0011 
0012 <span class="comment">% System matrix and its parameters</span>
0013 
0014 pp = <a href="../../../eidors/algorithms/a_adler/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>( fwd_model );
0015 pp.dfact = factorial(pp.n_dims);
0016 pp.DEBUG = 0;
0017 <span class="keyword">if</span> pp.DEBUG
0018     pp.ss_mat = <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( fwd_model, img_bkgd);
0019     pp.fwd_meas =<a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>( fwd_model, img_bkgd);
0020 <span class="keyword">end</span>
0021 
0022 pp.Ce= <a href="#_sub1" class="code" title="subfunction Ce= connectivity_matrix( pp );">connectivity_matrix</a>( pp );
0023 s_mat= <a href="../../../eidors/algorithms/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>( fwd_model, img_bkgd );
0024 [pp.Vc, pp.Re] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, fwd_model, s_mat.E );
0025 Jc = <a href="#_sub4" class="code" title="subfunction Jc = calc_conductivity_jacobian(pp, fwd_model, img_bkgd);">calc_conductivity_jacobian</a>(pp, fwd_model, img_bkgd);
0026 Jm = <a href="#_sub5" class="code" title="subfunction Jm = calc_movement_jacobian(pp, fwd_model, img_bkgd)">calc_movement_jacobian</a>(pp, fwd_model, img_bkgd);
0027 J=[Jc,Jm];
0028 
0029 <span class="keyword">if</span> pp.normalize
0030     data= <a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>( img_bkgd );
0031     J= J ./ (data.meas(:)*ones(1,size(J,2)));
0032 <span class="keyword">end</span>
0033 
0034 
0035 
0036 <span class="comment">% Define the element connectivity matrix Ce</span>
0037 <a name="_sub1" href="#_subfunctions" class="code">function Ce= connectivity_matrix( pp );</a>
0038 lengthX = (pp.n_dims+1)*pp.n_elem;
0039 lengthY = pp.n_node;
0040 Xidx = pp.ELEM(:);
0041 Yidx = ones(lengthX, 1);
0042 Ce = sparse(1:lengthX, Xidx, Yidx, lengthX, lengthY);
0043 
0044 
0045 
0046 <span class="comment">% Calculate fwd_solution and Impedance mapper matrices</span>
0047 <a name="_sub2" href="#_subfunctions" class="code">function [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );</a>
0048 <span class="comment">% Define the stimulation matrix Vc for each node I, and pattern</span>
0049 <span class="comment">% Ground node is never excited; remove it from the index</span>
0050 nodeidx = 1:pp.n_node;
0051 nodeidx( fwd_model.gnd_node ) = [];
0052 
0053 <span class="comment">% The stimulation matrix Vc is the voltage at each node (row) for a</span>
0054 <span class="comment">% stimulation (column)</span>
0055 Vc = zeros(pp.n_node, pp.n_stim);
0056 Vc(nodeidx, :) = s_mat(nodeidx, nodeidx) \ pp.QQ(nodeidx,:);
0057 
0058 <span class="comment">% Define the electrode resistance matrix Re</span>
0059 <span class="comment">% Calculate the resistance between electrodes (row) and all nodes (col)</span>
0060 <span class="comment">% N2E matrix maps each electrode to its node(s); we exclude GND</span>
0061 Re = zeros(pp.n_elec, pp.n_node);
0062 Re(:, nodeidx) = pp.N2E(:, nodeidx) / s_mat(nodeidx, nodeidx);
0063 
0064 <span class="comment">% FIXME: why do we calculate the negative??</span>
0065 Re = -Re;
0066 
0067 
0068 
0069 <span class="comment">% Calculate Meas jacobian from derivative on nodes</span>
0070 <span class="comment">% Input delVc</span>
0071 <span class="comment">% Ouput J</span>
0072 <a name="_sub3" href="#_subfunctions" class="code">function J= nodes_to_stim_jacobian( delV, fwd_model, pp )</a>
0073 
0074 sz_out= size(delV,3);
0075 <span class="comment">% Define the conductivity Jacobian Jc</span>
0076 J = zeros(pp.n_meas, sz_out);
0077 <span class="comment">% Calculate the Jacobian columns for each stimulation pattern</span>
0078 rowidx = 0;
0079 <span class="keyword">for</span> j = 1:pp.n_stim
0080     <span class="comment">% Get the measurement pattern for the stimulation pattern j</span>
0081     meas_pattern = fwd_model.stimulation(j).meas_pattern;
0082     n_measj = size(meas_pattern, 1);
0083     <span class="comment">% Extract the voltage sensitivity for electrode j</span>
0084     delVcj = reshape( delV(:,j,:), pp.n_elec, sz_out);
0085     <span class="comment">% Calculate sensitivity block for measurements during stimulation j</span>
0086     J(rowidx+(1:n_measj), :) = meas_pattern*delVcj;
0087     rowidx = rowidx+n_measj;
0088 <span class="keyword">end</span>
0089 
0090 
0091 
0092 <span class="comment">% CONDUCTIVITY JACOBIAN (Based on Andy Adler's 1996 algorithms)</span>
0093 <span class="comment">% Define the voltage sensitivity delVc on electrode I, for stimulation</span>
0094 <span class="comment">% pattern J, for a change in conductivity of element K as a 3D array</span>
0095 <a name="_sub4" href="#_subfunctions" class="code">function Jc = calc_conductivity_jacobian(pp, fwd_model, img_bkgd);</a>
0096 delVc = zeros(pp.n_elec, pp.n_stim, pp.n_elem);
0097 <span class="comment">% Calculate the values for the voltage sensitivity for each element</span>
0098 <span class="keyword">for</span> k = 1:pp.n_elem
0099     <span class="keyword">if</span> ~mod(k,500)
0100         fprintf(<span class="string">'   JC: element # %d\n'</span>,k);
0101     <span class="keyword">end</span>
0102     <span class="comment">% Extract the coordinates of the element's four nodes</span>
0103     Ae = pp.NODE(:,pp.ELEM(:,k))';
0104     <span class="comment">% Augment Ae by adding a column of ones to invert</span>
0105     Ae = inv([ones(pp.n_dims+1,1), Ae]);
0106     <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0107     Be = Ae(2:pp.n_dims+1,:);
0108     <span class="comment">% Calculate the system submatrix subSe for the element i</span>
0109     subSe = 2*Be'*Be/pp.dfact/abs(det(Ae));
0110     <span class="comment">% Select the same submatrix of Ce</span>
0111     subidx = (pp.n_dims+1)*(k-1)+1 : (pp.n_dims+1)*k;
0112     <span class="comment">% The system submatrix is given by the product</span>
0113     <span class="keyword">if</span> ~pp.DEBUG
0114         delVc(:,:,k) = pp.Re * pp.Ce(subidx,:)' * subSe * pp.Ce(subidx,:)<span class="keyword">...</span>
0115             * pp.Vc;
0116     <span class="keyword">else</span>
0117         sz= (pp.n_dims+1)*pp.n_elem;
0118         delSe = sparse(sz,sz);
0119         se_idx= (pp.n_dims+1)*k+(-pp.n_dims : 0);
0120         delSe(se_idx, se_idx) = subSe;
0121 
0122         delVc(:,:,k) = pp.Re * pp.Ce' * delSe * pp.Ce * pp.Vc;
0123 
0124         <span class="keyword">if</span> mod(k,50) == 0
0125             delta=1e-6;
0126             img_delta = img_bkgd;
0127             img_delta.elem_data(k) = img_delta.elem_data(k) + delta;
0128             ss_mat_delta= <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( fwd_model, img_delta);
0129             delSe_pert = (ss_mat_delta - pp.ss_mat) / delta;
0130 
0131             <span class="keyword">if</span> norm(delSe -delSe_pert ,1) &gt; 1e-6
0132                 <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'delSe calc wrong'</span>,1);
0133             <span class="keyword">end</span>
0134         <span class="keyword">end</span>
0135     <span class="keyword">end</span>
0136 
0137 <span class="keyword">end</span>
0138 Jc= <a href="#_sub3" class="code" title="subfunction J= nodes_to_stim_jacobian( delV, fwd_model, pp )">nodes_to_stim_jacobian</a>( delVc, fwd_model, pp );
0139 
0140 
0141 
0142 <span class="comment">% MOVEMENT JACOBIAN</span>
0143 <a name="_sub5" href="#_subfunctions" class="code">function Jm = calc_movement_jacobian(pp, fwd_model, img_bkgd)</a>
0144 <span class="comment">% The movement Jacobian is defined for each coordinate Jm = [Jmx Jmy Jmz]</span>
0145 <span class="comment">% Define the voltage sensitivity delVm on electrode I, for stimulation</span>
0146 <span class="comment">% pattern J, for a movement of electrode K as a 3D array</span>
0147 delVm = zeros(pp.n_elec, pp.n_stim, pp.n_elec*pp.n_dims);
0148 <span class="keyword">for</span> colidx = 1:pp.n_dims
0149     fprintf(<span class="string">'   JM: direction # %d\n'</span>,colidx);
0150     <span class="comment">% Calculate the values for the voltage sensitivity for each electrode</span>
0151     <span class="keyword">for</span> k = 1:pp.n_elec
0152         <span class="comment">% Find which elements touch this electrode</span>
0153         elec_nodes = fwd_model.electrode(k).nodes;
0154  
0155         <span class="comment">%for compound electrodes, average jacobian for each node</span>
0156         delVm_part = zeros(pp.n_elec);
0157         <span class="keyword">for</span> each_elec_node= elec_nodes(:)';
0158            delVm_part =  delVm_part + <span class="keyword">...</span>
0159                 <a href="#_sub6" class="code" title="subfunction delVm=  calc_delVm( elec_nodes, pp, fwd_model, img_bkgd, colidx)">calc_delVm</a>(each_elec_node,pp,fwd_model,img_bkgd,colidx);
0160         <span class="keyword">end</span>
0161         delVm_part = delVm_part/length(elec_nodes);
0162 
0163         vm_idx= k + pp.n_elec*(colidx-1);
0164         delVm(:,:,vm_idx) = delVm_part;
0165 
0166         <span class="keyword">if</span> pp.DEBUG
0167             delta=1e-8;
0168             mdl_delta = fwd_model;
0169             mdl_delta.nodes(elec_nodes, colidx) = <span class="keyword">...</span>
0170                 mdl_delta.nodes(elec_nodes, colidx) + delta;
0171             [Vc_delta] = <a href="#_sub2" class="code" title="subfunction [Vc, Re] = Vc_Re_matrices( pp, fwd_model, s_mat );">Vc_Re_matrices</a>( pp, mdl_delta, <span class="keyword">...</span>
0172                 <a href="../../../eidors/algorithms/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>( mdl_delta, img_bkgd));
0173             delVm_pert = pp.N2E*(Vc_delta - pp.Vc) / delta;
0174             nn = norm(delVm_part - delVm_pert,1 ); <span class="comment">% WHY NEGATIVE?</span>
0175 
0176             <span class="keyword">if</span> nn &gt; 5e-5 ; keyboard; <span class="keyword">end</span>
0177         <span class="keyword">end</span>
0178     <span class="keyword">end</span>
0179 <span class="keyword">end</span>
0180 Jm= <a href="#_sub3" class="code" title="subfunction J= nodes_to_stim_jacobian( delV, fwd_model, pp )">nodes_to_stim_jacobian</a>( delVm, fwd_model, pp );
0181 
0182 
0183 
0184 <a name="_sub6" href="#_subfunctions" class="code">function delVm=  calc_delVm( elec_nodes, pp, fwd_model, img_bkgd, colidx)</a>
0185 [rowidx, elemidx] = find(pp.ELEM == elec_nodes);
0186 <span class="comment">% Define the system sensitivity matrix to movement delSm</span>
0187 sz= (pp.n_dims+1)*pp.n_elem;
0188 delSm = sparse(sz,sz);
0189 <span class="comment">% For each touching element, calculate the perturbation</span>
0190 jcount = 1;
0191 <span class="keyword">for</span> j = elemidx'
0192     <span class="comment">% Extract the coordinates of the element's four nodes</span>
0193     Ae = pp.NODE(:,pp.ELEM(:, j))';
0194     <span class="comment">% Define the invertible matrix P: augment Ae by adding a</span>
0195     <span class="comment">% column of ones to invert</span>
0196     P = [ones(pp.n_dims+1,1), Ae];
0197     Ae = inv(P);
0198     absdetAe = abs(det(Ae));
0199     <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0200     Be = Ae(2:pp.n_dims+1,:);
0201     <span class="comment">% For this coordinate, perturb P by [rowidx,colidx], which are</span>
0202     <span class="comment">% our paper's perturbation vectors [a,b]</span>
0203     a = zeros(pp.n_dims+1,1);
0204     b = a;
0205     a(rowidx(jcount)) = 1;
0206     jcount = jcount + 1;
0207     b(colidx+1) = 1;
0208     <span class="comment">% Calculate the system submatrix subSm for the element j by</span>
0209     <span class="comment">% asymmetric perturbation of the electrode node k</span>
0210     deldetAe =   1/absdetAe*b'*Ae*a;
0211     delBe = -Ae*a*b'*Ae;
0212     delBe = delBe(2:pp.n_dims+1,:);
0213     subSm = 2/pp.dfact*(<span class="keyword">...</span>
0214         deldetAe*Be'*Be + <span class="keyword">...</span>
0215         delBe'*Be/absdetAe + <span class="keyword">...</span>
0216         Be'*delBe/absdetAe);
0217 
0218     <span class="keyword">if</span> pp.DEBUG
0219         delta=1e-8;
0220         subSe = 2*Be'*Be/pp.dfact/abs(det(Ae));
0221         d_NODE= pp.NODE;
0222         d_NODE(colidx,elec_nodes) =  d_NODE(colidx,elec_nodes) + delta;
0223         Ae = d_NODE(:,pp.ELEM(:, j))';
0224         Ae = inv( [ones(pp.n_dims+1,1), Ae] );
0225         absdetAe_pert = abs(det(Ae));
0226         deldetAe_pert = (absdetAe_pert - absdetAe) / delta;
0227         <span class="comment">% Define Be as the matrix Ae with row 1 deleted</span>
0228         Be = Ae(2:pp.n_dims+1,:);
0229         subSe_delta = 2*Be'*Be/pp.dfact/abs(det(Ae));
0230         subSm_pert= (subSe_delta - subSe ) / delta;
0231         <span class="keyword">if</span> norm(subSm_pert - subSm,1) &gt; 1e-5
0232             <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'subSm calc wrong'</span>,1);
0233             dd= (subSm_pert - 2/pp.dfact/absdetAe *<span class="keyword">...</span>
0234                 (delBe'*Be + Be'*delBe) )./(Be'*Be);
0235 
0236             fprintf(<span class="string">'colidx=%d, j=%d std=%6.4f &gt;'</span>,<span class="keyword">...</span>
0237                 colidx,j, std(dd(:)));
0238             keyboard
0239             subSm= subSm_pert;
0240         <span class="keyword">end</span>
0241     <span class="keyword">end</span>
0242 
0243     <span class="comment">% Embed subSm into delSm such that subSm(1,1) is the</span>
0244     <span class="comment">% (4j+1,4j+1) element of delSm</span>
0245     se_idx= (pp.n_dims+1)*j+(-pp.n_dims : 0);
0246     delSm(se_idx, se_idx) = subSm;
0247 <span class="keyword">end</span>
0248 
0249 <span class="comment">% The system submatrix is given by the product where delSm is</span>
0250 <span class="comment">% non-zero only in submatrices corresponding to touching elements</span>
0251 delVm = pp.Re * pp.Ce' * delSm * pp.Ce * pp.Vc;
0252 <span class="keyword">if</span> pp.DEBUG
0253     delta=1e-8;
0254     mdl_delta = fwd_model;
0255     mdl_delta.nodes(elec_nodes, colidx) = <span class="keyword">...</span>
0256         mdl_delta.nodes(elec_nodes, colidx) + delta;
0257     ss_mat_delta= <a href="#_sub7" class="code" title="subfunction SS= calc_unconnected_system_mat( fwd_model, img)">calc_unconnected_system_mat</a>( mdl_delta, img_bkgd );
0258     delSm_pert = (ss_mat_delta - pp.ss_mat) / delta;
0259     <span class="comment">% delSe_pert shound be Ce'*delSe*Ce</span>
0260     <span class="keyword">if</span> norm(delSm -delSm_pert ,1) &gt; 1e-5
0261         <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'delSm calc wrong'</span>,1);
0262         delVm = pp.Re * pp.Ce' * delSm_pert * pp.Ce * pp.Vc;
0263         keyboard
0264     <span class="keyword">end</span>
0265 <span class="keyword">end</span>
0266 
0267 
0268 
0269 <a name="_sub7" href="#_subfunctions" class="code">function SS= calc_unconnected_system_mat( fwd_model, img)</a>
0270 <span class="comment">% Calc system matrix for Andy Adler's EIT code</span>
0271 <span class="comment">% fwd_model = forward model</span>
0272 <span class="comment">% img       = image background for system matrix calc</span>
0273 <span class="comment">% s_mat = CC' * SS * conductivites * CC;</span>
0274 <span class="comment">% where:</span>
0275 <span class="comment">%   SS  = Unconnected system Matrix</span>
0276 <span class="comment">%   CC  = Connectivity Matrix</span>
0277 
0278 p= <a href="../../../eidors/algorithms/a_adler/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>( fwd_model );
0279 
0280 d= p.n_dims+1;
0281 e= p.n_elem;
0282 n= p.n_node;
0283 
0284 SSiidx= floor([0:d*e-1]'/d)*d*ones(1,d) + ones(d*e,1)*(1:d) ;
0285 SSjidx= [1:d*e]'*ones(1,d);
0286 SSdata= zeros(d*e,d);
0287 dfact= (d-1)*(d-2); <span class="comment">% Valid for d&lt;=3</span>
0288 <span class="keyword">for</span> j=1:e
0289     a=  inv([ ones(d,1), p.NODE( :, p.ELEM(:,j) )' ]);
0290     idx= d*(j-1)+1 : d*j;
0291     SSdata(idx,1:d)= 2*a(2:d,:)'*a(2:d,:)/dfact/abs(det(a));
0292 <span class="keyword">end</span> <span class="comment">%for j=1:ELEMs</span>
0293 idx= 1:e*d;
0294 SS= sparse(SSiidx,SSjidx,SSdata) * <span class="keyword">...</span>
0295     sparse(idx,idx, img.elem_data(ceil(idx/d)) );
0296 
0297 <span class="keyword">return</span>
0298 
0299 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0300 <span class="comment">% TEST CODE FOR MATRIX DERIVATIVES</span>
0301 
0302 <span class="comment">% TEST dertiv of det(X + t*a*b')</span>
0303 
0304 d= 1e-6;
0305 X= rand(5);
0306 a=zeros(5,1); a(ceil(5*rand))=1;
0307 b=zeros(5,1); b(ceil(5*rand))=1;
0308 dX_p= (det(X + d*a*b') - det(X) )/d;
0309 dX  = b'*inv(X)*a*det(X);
0310 disp([dX_p dX]);
0311 
0312 <span class="comment">% TEST dertiv of inv(X + t*a*b')</span>
0313 dX_p= (inv(X + d*a*b') - inv(X) )/d;
0314 dX  = -inv(X)*a*b'*inv(X);
0315 disp(norm([dX_p-dX],1));
0316 
0317 <span class="comment">% TEST dertiv of 1/abs(det(X + t*a*b')) = abs(1/det(X+t*a*b'))</span>
0318 <span class="keyword">for</span> i=1:20
0319     X= rand(5);
0320     a=zeros(5,1); a(ceil(5*rand))=1;
0321     b=zeros(5,1); b(ceil(5*rand))=1;
0322     dX_p= (1/abs(det(X + d*a*b')) - 1/abs(det(X)) )/d;
0323     dX  = - 1/abs(det(X))*b'*inv(X)*a;
0324     disp(norm([dX_p-dX])/norm(dX));
0325 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 13-Jul-2011 23:23:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>