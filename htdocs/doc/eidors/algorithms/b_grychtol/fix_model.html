<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fix_model</title>
  <meta name="keywords" content="fix_model">
  <meta name="description" content="FIX_MODEL: Add useful fields to a model">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- ../menu.html algorithms --><!-- menu.html b_grychtol -->
<h1>fix_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>FIX_MODEL: Add useful fields to a model</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [mdl] = fix_model(mdl,options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FIX_MODEL: Add useful fields to a model
    [mdl] = fix_model(mdl,options)
 INPUT:
    mdl - an FEM model with at least the following fields:
       .name
       .nodes
       .elem
    options - not coded yet

 OUTPUT:
    mdl - a copy of the input model with these additional fields:
       .boundary
       .boundary_face
       .faces
       .face2elem
       .elem2face
       .elem_centre
       .face_centre
       .normals
       .max_edge_len (per elem)

 The elems will be reordered so that all faces are counter-clockwise.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/a_adler/get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>	GET_ELEM_VOLUME: VOL = get_elem_volume(fwd_model, map_node )</li><li><a href="../../../eidors/algorithms/a_adler/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,options)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li><li><a href="../../../eidors/algorithms/m_crabb/linear_reorder.html" class="code" title="function [fwd_model] = linear_reorder(fwd_model,ccw)">linear_reorder</a>	function [fwd_model] = linear_reorder(fwd_model,ccw)</li><li><a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li><li><a href="../../../eidors/models/a_adler/elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>	ELEM_DIM: dimension of elements in space (are elements in 2D or 3D space)</li><li><a href="../../../eidors/models/a_adler/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="../../../eidors/models/a_adler/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/a_adler/num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>	NUM_ELEMS: number of elemnts in a (fwd or inv model or image)</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/a_adler/mk_c2f_circ_mapping.html" class="code" title="function [mapping failed] = mk_c2f_circ_mapping( mdl, xyzr );">mk_c2f_circ_mapping</a>	MK_C2F_CIRC_MAPPING: create a mapping matrix from circles/spheres to FEM</li><li><a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,options)">fix_model</a>	FIX_MODEL: Add useful fields to a model</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function inner_normal = test_inner_normal( mdl );</a></li><li><a href="#_sub2" class="code">function [faces, face2elem, elem2face] = calc_faces(mdl)</a></li><li><a href="#_sub3" class="code">function face2elem = calc_face2elem(elem2face)</a></li><li><a href="#_sub4" class="code">function elem2face = calc_elem2face(face2elem, face_per_elem)</a></li><li><a href="#_sub5" class="code">function normals = calc_normals(mdl)</a></li><li><a href="#_sub6" class="code">function len = calc_longest_edge(elems,nodes)</a></li><li><a href="#_sub7" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [mdl] = fix_model(mdl,options)</a>
0002 <span class="comment">% FIX_MODEL: Add useful fields to a model</span>
0003 <span class="comment">%    [mdl] = fix_model(mdl,options)</span>
0004 <span class="comment">% INPUT:</span>
0005 <span class="comment">%    mdl - an FEM model with at least the following fields:</span>
0006 <span class="comment">%       .name</span>
0007 <span class="comment">%       .nodes</span>
0008 <span class="comment">%       .elem</span>
0009 <span class="comment">%    options - not coded yet</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% OUTPUT:</span>
0012 <span class="comment">%    mdl - a copy of the input model with these additional fields:</span>
0013 <span class="comment">%       .boundary</span>
0014 <span class="comment">%       .boundary_face</span>
0015 <span class="comment">%       .faces</span>
0016 <span class="comment">%       .face2elem</span>
0017 <span class="comment">%       .elem2face</span>
0018 <span class="comment">%       .elem_centre</span>
0019 <span class="comment">%       .face_centre</span>
0020 <span class="comment">%       .normals</span>
0021 <span class="comment">%       .max_edge_len (per elem)</span>
0022 <span class="comment">%</span>
0023 <span class="comment">% The elems will be reordered so that all faces are counter-clockwise.</span>
0024 
0025 <span class="comment">% (C) 2011 Bartlomiej Grychtol. Licensed under GPL v2 or v3</span>
0026 <span class="comment">% $Id$</span>
0027 
0028 <span class="keyword">if</span> isstr(mdl) &amp;&amp; strcmp(mdl,<span class="string">'UNIT_TEST'</span>); <a href="#_sub7" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0029 
0030 
0031 mdl = <a href="../../../eidors/algorithms/m_crabb/linear_reorder.html" class="code" title="function [fwd_model] = linear_reorder(fwd_model,ccw)">linear_reorder</a>(mdl); <span class="comment">%counter-clockwise</span>
0032 <span class="keyword">if</span> ~isfield(mdl,<span class="string">'boundary'</span>)
0033     mdl.boundary = <a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(mdl);
0034 <span class="keyword">end</span>
0035 [mdl.faces mdl.face2elem mdl.elem2face] = <a href="#_sub2" class="code" title="subfunction [faces, face2elem, elem2face] = calc_faces(mdl)">calc_faces</a>(mdl);
0036 mdl.boundary_face = mdl.face2elem(:,2)==0;
0037 mdl.elem_centre = <a href="../../../eidors/algorithms/a_adler/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(mdl, 0);
0038 tmp = mdl;
0039 tmp.elems = tmp.faces;
0040 mdl.face_centre = <a href="../../../eidors/algorithms/a_adler/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>(tmp,0);
0041 mdl.normals = <a href="#_sub5" class="code" title="subfunction normals = calc_normals(mdl)">calc_normals</a>(mdl);
0042 mdl.inner_normal = <a href="#_sub1" class="code" title="subfunction inner_normal = test_inner_normal( mdl );">test_inner_normal</a>( mdl );
0043 mdl.max_edge_len = <a href="#_sub6" class="code" title="subfunction len = calc_longest_edge(elems,nodes)">calc_longest_edge</a>(mdl.elems,mdl.nodes);
0044 mdl.elem_volume = <a href="../../../eidors/algorithms/a_adler/get_elem_volume.html" class="code" title="function VOL = get_elem_volume( fwd_model, map_node )">get_elem_volume</a>(mdl);
0045 
0046 
0047 <span class="comment">% decrease memory footprint</span>
0048 mdl.elems = uint32(mdl.elems);
0049 mdl.faces = uint32(mdl.faces);
0050 mdl.elem2face = uint32(mdl.elem2face);
0051 mdl.face2elem = uint32(mdl.face2elem);
0052 
0053 <span class="comment">% Test whether normal points into or outsize</span>
0054 <span class="comment">% mdl.inner_normal(i,j) = 1 if face i of elem j points in</span>
0055 <a name="_sub1" href="#_subfunctions" class="code">function inner_normal = test_inner_normal( mdl );</a>
0056    inner_normal = logical(zeros(size(mdl.elem2face)));
0057    d = <a href="../../../eidors/models/a_adler/elem_dim.html" class="code" title="function num = elem_dim( mdl );">elem_dim</a>(mdl) + 1;
0058    <span class="keyword">for</span> i=1:<a href="../../../eidors/models/a_adler/num_elems.html" class="code" title="function num = num_elems( mdl );">num_elems</a>(mdl);
0059       el_faces = mdl.elem2face(i,:);
0060       el_ctr   = repmat( mdl.elem_centre(i,:), d, 1);
0061       vec_fa_el= el_ctr -  mdl.face_centre(el_faces,:);
0062       normal_i  = mdl.normals(el_faces,:);
0063       dot_prod = sum( normal_i.*vec_fa_el, 2 );
0064       inner_normal(i,:) = dot_prod' &gt; 0;
0065    <span class="keyword">end</span>
0066 
0067 <a name="_sub2" href="#_subfunctions" class="code">function [faces, face2elem, elem2face] = calc_faces(mdl)</a>
0068 
0069 
0070 e_dim = <a href="../../../eidors/models/a_adler/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(mdl);
0071 
0072 
0073 <span class="comment">%elem2face = zeros(size(mdl.elems));</span>
0074 <span class="keyword">switch</span> e_dim
0075     <span class="keyword">case</span> 2
0076         idx = [1 2; 2 3; 1 3];
0077     <span class="keyword">case</span> 3
0078         idx = [1 2 3; 2 3 4; 1 2 4; 1 3 4];
0079 <span class="keyword">end</span>
0080 elem_sorted = sort(mdl.elems,2);
0081 [faces ib ia] = unique(reshape(elem_sorted(:,idx),[],e_dim),<span class="string">'rows'</span>);
0082 elem2face = reshape(ia,[],e_dim+1);
0083 face2elem = <a href="#_sub3" class="code" title="subfunction face2elem = calc_face2elem(elem2face)">calc_face2elem</a>(elem2face);
0084 
0085 <a name="_sub3" href="#_subfunctions" class="code">function face2elem = calc_face2elem(elem2face)</a>
0086 <span class="comment">% This is easier to understand but very slow</span>
0087 <span class="comment">%     n_face = max(elem2face(:));</span>
0088 <span class="comment">%     face2elem = zeros(n_face,2);</span>
0089 <span class="comment">%     for i= 1:n_face</span>
0090 <span class="comment">%         [el jnk] = find(elem2face==i);</span>
0091 <span class="comment">%         if numel(el)==1, el(2) = 0; end</span>
0092 <span class="comment">%         face2elem(i,:) = el;</span>
0093 <span class="comment">%     end</span>
0094 <span class="comment">%     bck = face2elem; face2elem=[];</span>
0095     [n_elems, el_faces] = size(elem2face);
0096     elem2faceno = (1:n_elems)'*ones(1,el_faces);
0097     elem2faceno = elem2faceno(:);
0098     elem2face   = elem2face(:);
0099     face2elem(elem2face,2) = elem2faceno;
0100     <span class="comment">% flipping will give us the other element for shared faces</span>
0101     elem2faceno = flipud(elem2faceno);
0102     elem2face   = flipud(elem2face);
0103     face2elem(elem2face,1) = elem2faceno;
0104     <span class="comment">% replace with zeros repeated entries (boundary faces)</span>
0105     face2elem( face2elem(:,1) == face2elem(:,2), 2) = 0;
0106 
0107 <span class="comment">% This function is obsolete</span>
0108 <a name="_sub4" href="#_subfunctions" class="code">function elem2face = calc_elem2face(face2elem, face_per_elem)</a>
0109     n_elem = max(face2elem(:));
0110     elem2face = zeros(n_elem,face_per_elem);
0111     <span class="keyword">for</span> i = 1:n_elem
0112         [f jnk] = find(face2elem==i);
0113         elem2face(i,:) = f;
0114     <span class="keyword">end</span>
0115     
0116 <a name="_sub5" href="#_subfunctions" class="code">function normals = calc_normals(mdl)</a>
0117     [n_faces face_dim] = size(mdl.faces);
0118     <span class="keyword">switch</span> face_dim
0119         <span class="keyword">case</span> 2
0120             A = mdl.nodes(mdl.faces(:,1),:);
0121             B = mdl.nodes(mdl.faces(:,2),:);
0122             normals = (B-A)*[0 1; -1 0];
0123         <span class="keyword">case</span> 3
0124             <span class="comment">% vectorise cross product</span>
0125             x1 = mdl.nodes(mdl.faces(:,2),1) - mdl.nodes(mdl.faces(:,1),1);
0126             y1 = mdl.nodes(mdl.faces(:,2),2) - mdl.nodes(mdl.faces(:,1),2);
0127             z1 = mdl.nodes(mdl.faces(:,2),3) - mdl.nodes(mdl.faces(:,1),3);
0128             x2 = mdl.nodes(mdl.faces(:,3),1) - mdl.nodes(mdl.faces(:,1),1);
0129             y2 = mdl.nodes(mdl.faces(:,3),2) - mdl.nodes(mdl.faces(:,1),2);
0130             z2 = mdl.nodes(mdl.faces(:,3),3) - mdl.nodes(mdl.faces(:,1),3);
0131             <span class="comment">%(a2b3 ? a3b2, a3b1 ? a1b3, a1b2 ? a2b1).</span>
0132             normals = zeros(n_faces,3);
0133             normals(:,1) = y1.*z2 - z1.*y2;
0134             normals(:,2) = z1.*x2 - x1.*z2;
0135             normals(:,3) = x1.*y2 - y1.*x2;
0136         <span class="keyword">otherwise</span>;
0137             error(<span class="string">'not 2D or 3D'</span>)
0138     <span class="keyword">end</span>
0139     normals = normals./ repmat(sqrt(sum(normals.^2,2))',face_dim,1)';
0140     
0141     
0142 <a name="_sub6" href="#_subfunctions" class="code">function len = calc_longest_edge(elems,nodes)</a>
0143     [E_num E_dim] = size(elems);
0144 
0145     pairs = nchoosek(1:E_dim,2);
0146     len = zeros(E_num,1);
0147     <span class="keyword">for</span> i = 1:size(pairs,1)
0148         a = nodes(elems(:,pairs(i,1)),:);
0149         b = nodes(elems(:,pairs(i,2)),:);
0150         tmp = sqrt(sum((a-b).^2,2));
0151         len = max(len,tmp);  
0152     <span class="keyword">end</span>
0153     
0154 <a name="_sub7" href="#_subfunctions" class="code">function do_unit_test</a>
0155     <span class="comment">% square</span>
0156     nodes = [0 0; 0 1; 1 1; 1 0];
0157     elems = [1 2 3; 1 3 4];
0158     mdl = <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'square'</span>,<span class="string">'nodes'</span>, nodes, <span class="string">'elems'</span>, elems);
0159     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,options)">fix_model</a>(mdl);
0160     out.faces
0161     out.elem2face
0162     out.face2elem
0163 
0164     <span class="comment">%cube</span>
0165     nodes = [0 0 0; 0 1 0; 1 1 0; 1 0 0;<span class="keyword">...</span>
0166              0 0 1; 0 1 1; 1 1 1; 1 0 1];
0167     elems = [1 2 3 6; 3 6 7 8; 1 5 6 8; 1 3 4 8; 1 3 6 8];
0168     mdl = <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'cube'</span>,<span class="string">'nodes'</span>, nodes, <span class="string">'elems'</span>, elems);
0169     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,options)">fix_model</a>(mdl);
0170     out.faces
0171     out.elem2face
0172     out.face2elem    
0173     
0174     mdl = <a href="../../../eidors/models/a_adler/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,16); mdl= mdl.fwd_model;
0175     out = <a href="fix_model.html" class="code" title="function [mdl] = fix_model(mdl,options)">fix_model</a>(mdl);
0176</pre></div>
<hr><address>Generated on Wed 13-Jul-2011 23:23:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>