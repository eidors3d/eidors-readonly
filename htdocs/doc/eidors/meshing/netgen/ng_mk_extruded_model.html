<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ng_mk_extruded_model</title>
  <meta name="keywords" content="ng_mk_extruded_model">
  <meta name="description" content="NG_MAKE_EXTRUDED_MODEL: create extruded models using netgen">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html?eidors/meshing/netgen/ng_mk_extruded_model.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- # meshing --><!-- menu.html netgen -->
<h1>ng_mk_extruded_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>NG_MAKE_EXTRUDED_MODEL: create extruded models using netgen</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape,extra_ng_code) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> NG_MAKE_EXTRUDED_MODEL: create extruded models using netgen
 [fmdl,mat_idx] = ng_mk_extruded_models(trunk_shape, elec_pos, ...
                 elec_shape, extra_ng_code);
 INPUT:
 trunk_shape = { height,[x,y],curve_type,maxsz}
   height      -&gt; if height = 0 calculate a 2D model
   [x,y]       -&gt; N-by-2 CLOCKWISE list of points defining the 2D shape
                  NOTE: Use a cell array to specify additional curves for
                  internal objects
   curve_type  -&gt; 1 - interpret as vertices (default)
                  2 - interpret as splines with de Boor points at even 
                  indices (legacy)
                  3 - interpolate points (piecewise polynomial
                  interpolation). Syntax [3, N] also specifies the number
                  of samples to create.
                  4 - interpolate points with Fourier descriptor. Syntax 
                  [4, N] also specifies the number of samples to create.
                  NOTE: If additional curves are specified, curve_type can
                  also be a cell array. Otherwise, curve_type defaults to
                  1 for internal shapes.
   maxsz       -&gt; max size of mesh elems (default = course mesh)

 ELECTRODE POSITIONS:
  elec_pos = [n_elecs_per_plane,spacing,z_planes] where spacing is either
             0 for even spacing w.r.t angular positions (0,15,30... deg)
             or
             1 for equal distances between electrodes
             Any fractional part (e.g. 0.15) is interpreted as a starting
             position -- fraction of 2*pi for values spacing &lt; 1 and
             fraction of total perimeter for spacing &gt; 1.
     OR
  elec_pos = [degrees,z] centres of each electrode (N_elecs x 2)

 ELECTRODE SHAPES::
  elec_shape = [width,height, [maxsz, pem, discr]]  % Rectangular elecs
     OR
  elec_shape = [radius, [0, maxsz, pem, discr] ]  % Circular elecs
     radius      -&gt; specify -1 for point electrodes
     maxsz (OPT) -&gt; max size of mesh elems (default = course mesh),
                    ignored if &lt;= 0 
     pem  (OPT)  -&gt; 1: Point Electrode Model, 0: Complete Electrode Model (default)
     discr (OPT) -&gt; discretize electrode normals (0 = ignore = default)
                    Adjusting this value helps Netgen problems with
                    electrodes facing each other.

 Specify either a common electrode shape or for each electrode</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="../../../eidors/eidors_cache.html" class="code" title="function retval=eidors_cache( command, limit )">eidors_cache</a>	Control eidors_caching</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li><li><a href="../../../eidors/graphics_matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>	CALL_NETGEN: call netgen to create a vol_file from a geo_file</li><li><a href="fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>	FOURIER_FIT: use fourier series to interpolate onto a boundary</li><li><a href="ng_mk_extruded_model.html" class="code" title="function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape,extra_ng_code)">ng_mk_extruded_model</a>	NG_MAKE_EXTRUDED_MODEL: create extruded models using netgen</li><li><a href="ng_mk_fwd_model.html" class="code" title="function [fwd_mdl, mat_indices]=ng_mk_fwd_model( ng_vol_filename, centres,name, stim_pattern, z_contact, postprocmesh)">ng_mk_fwd_model</a>	NG_MK_FWD_MODEL: create a fwd_model object from a netgen vol file</li><li><a href="piece_poly_fit.html" class="code" title="function [pp, m] = piece_poly_fit(points, fstr, linear_frac)">piece_poly_fit</a>	PIECE_POLY_FIT: piecewise polynomial fitting toolset</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="ng_mk_extruded_model.html" class="code" title="function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape,extra_ng_code)">ng_mk_extruded_model</a>	NG_MAKE_EXTRUDED_MODEL: create extruded models using netgen</li><li><a href="../../../eidors/models/a_adler/test_GREIT_model.html" class="code" title="">test_GREIT_model</a>	</li><li><a href="../../../eidors/models/b_grychtol/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft)">mk_library_model</a>	MK_LIBRARY_MODEL - FEM models based on library shapes</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [fmdl_mat_idx] = mk_extruded_model(shape, elec_pos, elec_shape,</a></li><li><a href="#_sub2" class="code">function [tank_height, tank_shape, tank_maxh, is2D] = parse_shape(shape)</a></li><li><a href="#_sub3" class="code">function new_points = interpolate(points, N, curve_type)</a></li><li><a href="#_sub4" class="code">function [points, spln_sgmnts] = remove_linear_control_points(points)</a></li><li><a href="#_sub5" class="code">function out = interpolate_shape(points, n_points)</a></li><li><a href="#_sub6" class="code">function out = fourier_interpolate_shape(points, n_points)</a></li><li><a href="#_sub7" class="code">function out = calc_vertex_dir(points, edges, edgnrm)</a></li><li><a href="#_sub8" class="code">function out = calc_centroid(points)</a></li><li><a href="#_sub9" class="code">function out = calc_convex(verts)</a></li><li><a href="#_sub10" class="code">function [elecs, centres] = parse_elecs(elec_pos, elec_shape, tank_shape, hig, is2D )</a></li><li><a href="#_sub11" class="code">function [pos, normal] = calc_elec_centre(tank_shape, th)</a></li><li><a href="#_sub12" class="code">function [pos, normal] = calc_elec_centre_spline(tank_shape, th)</a></li><li><a href="#_sub13" class="code">function elec = elec_spec( row, is2D, hig, rad )</a></li><li><a href="#_sub14" class="code">function write_geo_file(geofn, tank_height, tank_shape,</a></li><li><a href="#_sub15" class="code">function write_header(fid,tank_height,tank_shape,maxsz,extra)</a></li><li><a href="#_sub16" class="code">function write_curve(fid, tank_shape, name, scale)</a></li><li><a href="#_sub17" class="code">function write_circ_elec(fid,name,c, dirn, rd, centroid, maxh)</a></li><li><a href="#_sub18" class="code">function write_rect_elec(fid,name,c, dirn,wh,d,maxh)</a></li><li><a href="#_sub19" class="code">function [srf,vtx,fc,bc,simp,edg,mat_ind] = ng_remove_electrodes</a></li><li><a href="#_sub20" class="code">function [srf,vtx,fc,bc,simp,edg,mat_ind] = ng_remove_electrodes_old</a></li><li><a href="#_sub21" class="code">function [mdl2,idx2] = mdl2d_from3d(mdl3,idx3);</a></li><li><a href="#_sub22" class="code">function [fmdl, mat_idx] = do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape, </a><span class="keyword">...</span>
0002     extra_ng_code)
0003 <span class="comment">% NG_MAKE_EXTRUDED_MODEL: create extruded models using netgen</span>
0004 <span class="comment">% [fmdl,mat_idx] = ng_mk_extruded_models(trunk_shape, elec_pos, ...</span>
0005 <span class="comment">%                 elec_shape, extra_ng_code);</span>
0006 <span class="comment">% INPUT:</span>
0007 <span class="comment">% trunk_shape = { height,[x,y],curve_type,maxsz}</span>
0008 <span class="comment">%   height      -&gt; if height = 0 calculate a 2D model</span>
0009 <span class="comment">%   [x,y]       -&gt; N-by-2 CLOCKWISE list of points defining the 2D shape</span>
0010 <span class="comment">%                  NOTE: Use a cell array to specify additional curves for</span>
0011 <span class="comment">%                  internal objects</span>
0012 <span class="comment">%   curve_type  -&gt; 1 - interpret as vertices (default)</span>
0013 <span class="comment">%                  2 - interpret as splines with de Boor points at even</span>
0014 <span class="comment">%                  indices (legacy)</span>
0015 <span class="comment">%                  3 - interpolate points (piecewise polynomial</span>
0016 <span class="comment">%                  interpolation). Syntax [3, N] also specifies the number</span>
0017 <span class="comment">%                  of samples to create.</span>
0018 <span class="comment">%                  4 - interpolate points with Fourier descriptor. Syntax</span>
0019 <span class="comment">%                  [4, N] also specifies the number of samples to create.</span>
0020 <span class="comment">%                  NOTE: If additional curves are specified, curve_type can</span>
0021 <span class="comment">%                  also be a cell array. Otherwise, curve_type defaults to</span>
0022 <span class="comment">%                  1 for internal shapes.</span>
0023 <span class="comment">%   maxsz       -&gt; max size of mesh elems (default = course mesh)</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% ELECTRODE POSITIONS:</span>
0026 <span class="comment">%  elec_pos = [n_elecs_per_plane,spacing,z_planes] where spacing is either</span>
0027 <span class="comment">%             0 for even spacing w.r.t angular positions (0,15,30... deg)</span>
0028 <span class="comment">%             or</span>
0029 <span class="comment">%             1 for equal distances between electrodes</span>
0030 <span class="comment">%             Any fractional part (e.g. 0.15) is interpreted as a starting</span>
0031 <span class="comment">%             position -- fraction of 2*pi for values spacing &lt; 1 and</span>
0032 <span class="comment">%             fraction of total perimeter for spacing &gt; 1.</span>
0033 <span class="comment">%     OR</span>
0034 <span class="comment">%  elec_pos = [degrees,z] centres of each electrode (N_elecs x 2)</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% ELECTRODE SHAPES::</span>
0037 <span class="comment">%  elec_shape = [width,height, [maxsz, pem, discr]]  % Rectangular elecs</span>
0038 <span class="comment">%     OR</span>
0039 <span class="comment">%  elec_shape = [radius, [0, maxsz, pem, discr] ]  % Circular elecs</span>
0040 <span class="comment">%     radius      -&gt; specify -1 for point electrodes</span>
0041 <span class="comment">%     maxsz (OPT) -&gt; max size of mesh elems (default = course mesh),</span>
0042 <span class="comment">%                    ignored if &lt;= 0</span>
0043 <span class="comment">%     pem  (OPT)  -&gt; 1: Point Electrode Model, 0: Complete Electrode Model (default)</span>
0044 <span class="comment">%     discr (OPT) -&gt; discretize electrode normals (0 = ignore = default)</span>
0045 <span class="comment">%                    Adjusting this value helps Netgen problems with</span>
0046 <span class="comment">%                    electrodes facing each other.</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% Specify either a common electrode shape or for each electrode</span>
0049 
0050 <span class="comment">% (C) Bartlomiej Grychtol, 2010. Licenced under GPL v2 or v3</span>
0051 <span class="comment">% $Id$</span>
0052 
0053 <span class="comment">% TODO: Implement control segments in the bit that writes the file.</span>
0054 
0055 <span class="keyword">if</span> isstr(shape) &amp;&amp; strcmp(shape,<span class="string">'UNIT_TEST'</span>); fmdl = <a href="#_sub22" class="code" title="subfunction [fmdl, mat_idx] = do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0056 
0057 <span class="keyword">if</span> nargin &lt; 4; extra_ng_code = {<span class="string">''</span>,<span class="string">''</span>}; <span class="keyword">end</span>
0058 cache_obj = { shape, elec_pos, elec_shape, extra_ng_code};
0059 
0060 fmdl = <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'get-cache'</span>, cache_obj, <span class="string">'ng_mk_extruded_models'</span> );
0061 <span class="keyword">if</span> isempty(fmdl);
0062    fmdl = <a href="#_sub1" class="code" title="subfunction [fmdl_mat_idx] = mk_extruded_model(shape, elec_pos, elec_shape, ">mk_extruded_model</a>( shape, elec_pos, elec_shape, extra_ng_code );
0063    <a href="../../../eidors/eidors_cache.html" class="code" title="function retval=eidors_cache( command, limit )">eidors_cache</a>(<span class="string">'boost_priority'</span>, -2); <span class="comment">% netgen objs are low priority</span>
0064    <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'set-cache'</span>, cache_obj, <span class="string">'ng_mk_extruded_models'</span>, fmdl);
0065    <a href="../../../eidors/eidors_cache.html" class="code" title="function retval=eidors_cache( command, limit )">eidors_cache</a>(<span class="string">'boost_priority'</span>, +2); <span class="comment">% return values</span>
0066 <span class="keyword">end</span>
0067 
0068 mat_idx = fmdl{2};
0069 fmdl = fmdl{1};
0070 
0071 
0072 <a name="_sub1" href="#_subfunctions" class="code">function [fmdl_mat_idx] = mk_extruded_model(shape, elec_pos, elec_shape, </a><span class="keyword">...</span>
0073     extra_ng_code)
0074 
0075 fnstem = tempname;
0076 geofn= [fnstem,<span class="string">'.geo'</span>];
0077 meshfn= [fnstem,<span class="string">'.vol'</span>];
0078 
0079 [tank_height, tank_shape, tank_maxh, is2D] = <a href="#_sub2" class="code" title="subfunction [tank_height, tank_shape, tank_maxh, is2D] = parse_shape(shape)">parse_shape</a>(shape);
0080 [elecs, centres] = <a href="#_sub10" class="code" title="subfunction [elecs, centres] = parse_elecs(elec_pos, elec_shape, tank_shape, hig, is2D )">parse_elecs</a>(elec_pos, elec_shape, tank_shape, tank_height, is2D );
0081 <a href="#_sub14" class="code" title="subfunction write_geo_file(geofn, tank_height, tank_shape, ">write_geo_file</a>(geofn, tank_height, tank_shape, <span class="keyword">...</span>
0082                tank_maxh, elecs, extra_ng_code);
0083            
0084 <span class="keyword">if</span> 0<span class="comment">% DEBUG SHAPE</span>
0085    plot(tank_shape.vertices(:,1),tank_shape.vertices(:,2));
0086    hold on
0087    plot(centres(:,1),centres(:,2),<span class="string">'sk'</span>)
0088    <span class="keyword">for</span> i = 1:size(elecs,2)
0089        dirn = elecs(i).normal;
0090        quiver(centres(i,1),centres(i,2),dirn(1),dirn(2),<span class="string">'k'</span>);
0091    <span class="keyword">end</span>
0092    hold off
0093    axis equal
0094 <span class="keyword">end</span>
0095            
0096 <a href="call_netgen.html" class="code" title="function status= call_netgen(geo_file, vol_file, msz_file, finelevel)">call_netgen</a>( geofn, meshfn );
0097 
0098 [fmdl,mat_idx] = <a href="ng_mk_fwd_model.html" class="code" title="function [fwd_mdl, mat_indices]=ng_mk_fwd_model( ng_vol_filename, centres,name, stim_pattern, z_contact, postprocmesh)">ng_mk_fwd_model</a>( meshfn, centres, <span class="string">'ng'</span>, [],0.01,<span class="keyword">...</span>
0099     @<a href="#_sub19" class="code" title="subfunction [srf,vtx,fc,bc,simp,edg,mat_ind] = ng_remove_electrodes">ng_remove_electrodes</a>);
0100 
0101 delete(geofn); delete(meshfn); <span class="comment">% remove temp files</span>
0102 
0103 <span class="keyword">if</span> is2D
0104     [fmdl,mat_idx] = <a href="#_sub21" class="code" title="subfunction [mdl2,idx2] = mdl2d_from3d(mdl3,idx3);">mdl2d_from3d</a>(fmdl,mat_idx);
0105 <span class="keyword">end</span>
0106 
0107 fmdl_mat_idx = {fmdl,mat_idx};
0108 
0109 
0110 
0111 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0112 <span class="comment">% TANK SHAPE (struct):</span>
0113 <span class="comment">%         vertices: [Nx2]</span>
0114 <span class="comment">%             size: 0.5* length of the diagonal of the containing rectangle</span>
0115 <span class="comment">%     edge_normals: [Nx2]</span>
0116 <span class="comment">%       vertex_dir: [Nx2] direction of vertex movement when scaling</span>
0117 <span class="comment">%         centroid: [x y]</span>
0118 <span class="comment">%   vertices_polar: [Nx2] Phi, r</span>
0119 <span class="comment">%           convex: [N] boolean array indicating external angle &gt;= 180 deg</span>
0120 <span class="comment">%       curve_type: One of three values</span>
0121 <span class="comment">%                   1 - Normal, each point is a vertex</span>
0122 <span class="comment">%                   2 - Spline, all even points are de Boor points</span>
0123 <span class="comment">%                   3 - Same as 1 but will be converted to smooth</span>
0124 <span class="comment">%</span>
0125 <a name="_sub2" href="#_subfunctions" class="code">function [tank_height, tank_shape, tank_maxh, is2D] = parse_shape(shape)</a>
0126     <span class="comment">% parses the shape input</span>
0127 
0128     <span class="comment">%defaults</span>
0129     is2D = false;
0130     tank_maxh = 0;
0131     tank_shape = [];
0132     tank_shape.curve_type = 1;
0133     curve_info = [];
0134 
0135     <span class="keyword">if</span> iscell(shape) &amp;&amp; length(shape)&gt;2
0136         tank_height = shape{1};
0137         <span class="keyword">if</span> ~iscell(shape{2})
0138             points = shape{2};
0139         <span class="keyword">else</span>
0140             c = shape{2};
0141             points = c{1};
0142             <span class="keyword">if</span> numel(shape{2}) &gt; 1
0143                 tank_shape.additional_shapes = c(2:end);
0144             <span class="keyword">end</span>
0145         <span class="keyword">end</span>
0146         
0147         <span class="keyword">if</span> ~iscell(shape{3})
0148             tank_shape.curve_type = shape{3};
0149             <span class="keyword">if</span> iscell(tank_shape.curve_type)
0150                 tank_shape.curve_type = tank_shape.curve_type{1};
0151             <span class="keyword">end</span>
0152         <span class="keyword">else</span>
0153             c = shape{3};
0154             tank_shape.curve_type = c{1};
0155             <span class="keyword">if</span> numel(shape{3}) &gt; 1
0156                 tank_shape.additional_curve_type = c(2:end);
0157             <span class="keyword">end</span>
0158         <span class="keyword">end</span>
0159         
0160         <span class="keyword">if</span> max(size(tank_shape.curve_type)) &gt; 1
0161             curve_info = tank_shape.curve_type;
0162             tank_shape.curve_type = curve_info(1);
0163         <span class="keyword">end</span>
0164 <span class="comment">%         if length(shape) &gt; 2</span>
0165 <span class="comment">%             tank_height = shape{1};</span>
0166 <span class="comment">%         end</span>
0167         <span class="keyword">if</span> length(shape) &gt; 3
0168             tank_maxh = shape{4};
0169         <span class="keyword">end</span>
0170     <span class="keyword">else</span>
0171         points = shape;
0172     <span class="keyword">end</span>
0173     
0174     spln_sgmnts = zeros(size(points)); <span class="comment">%default</span>
0175     <span class="keyword">if</span> tank_shape.curve_type == 2
0176         [points, spln_sgmnts] = <a href="#_sub4" class="code" title="subfunction [points, spln_sgmnts] = remove_linear_control_points(points)">remove_linear_control_points</a>(points);
0177     <span class="keyword">end</span>
0178     
0179     <span class="keyword">if</span> ~isempty(curve_info)
0180         N = curve_info(2);
0181     <span class="keyword">else</span>
0182         N = 50;
0183     <span class="keyword">end</span>
0184     points = <a href="#_sub3" class="code" title="subfunction new_points = interpolate(points, N, curve_type)">interpolate</a>(points,N, tank_shape.curve_type);
0185     spln_sgmnts = zeros(size(points));
0186     
0187     <span class="keyword">if</span> isfield(tank_shape, <span class="string">'additional_curve_type'</span>)
0188         <span class="keyword">for</span> i = 1:numel(tank_shape.additional_curve_type)
0189             <span class="keyword">if</span> numel(tank_shape.additional_curve_type{i}) == 1
0190                 N = 50;
0191             <span class="keyword">else</span>
0192                 N = tank_shape.additional_curve_type{i}(2);
0193             <span class="keyword">end</span>
0194             tank_shape.additional_shapes{i} = <a href="#_sub3" class="code" title="subfunction new_points = interpolate(points, N, curve_type)">interpolate</a>(<span class="keyword">...</span>
0195                 tank_shape.additional_shapes{i},N, tank_shape.additional_curve_type{i}(1));
0196         <span class="keyword">end</span>
0197     <span class="keyword">end</span>
0198     
0199     <span class="comment">% piecewise polynomial interpolation</span>
0200     <span class="keyword">if</span> tank_shape.curve_type == 3 
0201         <span class="keyword">if</span> ~isempty(curve_info)
0202             n_samples = curve_info(2);
0203         <span class="keyword">else</span>
0204             n_samples = 50;
0205         <span class="keyword">end</span>
0206         points = <a href="#_sub5" class="code" title="subfunction out = interpolate_shape(points, n_points)">interpolate_shape</a>(points, n_samples);
0207         spln_sgmnts = zeros(size(points)); <span class="comment">% now needs to be bigger</span>
0208     <span class="keyword">end</span>
0209 
0210     <span class="comment">% Fourier descriptor interpolation</span>
0211     <span class="keyword">if</span> tank_shape.curve_type == 4
0212         <span class="keyword">if</span> ~isempty(curve_info)
0213             n_samples = curve_info(2);
0214         <span class="keyword">else</span>
0215             n_samples = 50;
0216         <span class="keyword">end</span>
0217         points = <a href="#_sub6" class="code" title="subfunction out = fourier_interpolate_shape(points, n_points)">fourier_interpolate_shape</a>(points, n_samples);
0218         spln_sgmnts = zeros(size(points)); <span class="comment">% now needs to be bigger</span>
0219     <span class="keyword">end</span>
0220     
0221     tank_shape.centroid = <a href="#_sub8" class="code" title="subfunction out = calc_centroid(points)">calc_centroid</a>(points);
0222     tank_shape.spln_sgmnts = spln_sgmnts;
0223 
0224     tank_shape.vertices = points;
0225     <span class="comment">% diagonal of the containing rectangle:</span>
0226     tank_shape.size = 0.5 * sqrt(sum(range(points).^2));
0227     
0228     <span class="keyword">if</span> tank_height==0
0229         is2D = 1;
0230         <span class="comment">% Need some width to let netgen work, but not too much so</span>
0231         <span class="comment">% that it meshes the entire region</span>
0232         tank_height = tank_shape.size/5; <span class="comment">% initial estimate</span>
0233         <span class="keyword">if</span> tank_maxh&gt;0
0234             tank_height = min(tank_height,2*tank_maxh);
0235         <span class="keyword">end</span>
0236     <span class="keyword">end</span>
0237 
0238 
0239     tank_shape.edge_normals = [];
0240     tank_shape.vertex_dir = [];
0241 
0242     tmp = points;
0243     tmp(end+1,:) = tmp(1,:); <span class="comment">%duplicate first vertex at the end;</span>
0244 
0245     edges = diff(tmp,1);
0246     tmp = [];
0247     <span class="comment">% Normal to vector (x y) is (-y x).</span>
0248     <span class="comment">% It points outward for clockwise definition</span>
0249     tmp = circshift(edges, [0 1]); <span class="comment">%swap coords</span>
0250     <span class="comment">%normalize</span>
0251     lngth = sqrt(sum(tmp.^2, 2));
0252     tmp(:,1) = -tmp(:,1) ./ lngth;
0253     tmp(:,2) = tmp(:,2)  ./ lngth;
0254     tank_shape.edge_normals = tmp;
0255 
0256     tank_shape.vertex_dir = <a href="#_sub7" class="code" title="subfunction out = calc_vertex_dir(points, edges, edgnrm)">calc_vertex_dir</a>(points, edges, <span class="keyword">...</span>
0257         tank_shape.edge_normals);
0258     
0259     
0260     tmp = [];
0261     polar = zeros(size(points));
0262     <span class="keyword">for</span> i = 1:length(points)
0263         tmp = points(i,:) - tank_shape.centroid;
0264         [polar(i,1) polar(i,2)]  = cart2pol(tmp(1),tmp(2));
0265     <span class="keyword">end</span>
0266     tank_shape.vertices_polar = polar;
0267     
0268     tank_shape.convex = <a href="#_sub9" class="code" title="subfunction out = calc_convex(verts)">calc_convex</a>(tank_shape.vertices);
0269     
0270     <span class="comment">% debug plot</span>
0271 <span class="keyword">if</span> 0
0272     pts = edges./2 + points;
0273     plot(tank_shape.vertices(:,1),tank_shape.vertices(:,2),<span class="string">'-o'</span>); hold on;
0274     plot(tank_shape.centroid(:,1),tank_shape.centroid(:,2),<span class="string">'+'</span>);
0275     plot(tank_shape.vertices(:,1)+0.05*tank_shape.vertex_dir(:,1),<span class="keyword">...</span>
0276         tank_shape.vertices(:,2)+0.05*tank_shape.vertex_dir(:,2),<span class="string">'ro-'</span>)
0277     quiver(pts(:,1),pts(:,2),tank_shape.edge_normals(:,1),tank_shape.edge_normals(:,2));
0278     hold off
0279 <span class="keyword">end</span>
0280     
0281     
0282 <a name="_sub3" href="#_subfunctions" class="code">function new_points = interpolate(points, N, curve_type)</a>
0283 <span class="keyword">switch</span> curve_type
0284     <span class="keyword">case</span> 3 
0285         <span class="comment">% piecewise polynomial interpolation</span>
0286         new_points = <a href="#_sub5" class="code" title="subfunction out = interpolate_shape(points, n_points)">interpolate_shape</a>(points, N);
0287     <span class="keyword">case</span> 4
0288         <span class="comment">% Fourier descriptor interpolation</span>
0289         new_points = <a href="#_sub6" class="code" title="subfunction out = fourier_interpolate_shape(points, n_points)">fourier_interpolate_shape</a>(points, N);
0290     <span class="keyword">otherwise</span> 
0291         <span class="comment">% do nothing</span>
0292         new_points = points;
0293 <span class="keyword">end</span>  
0294     
0295     
0296 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0297 <span class="comment">% INPUT:</span>
0298 <span class="comment">% points - [2N x 2] defined vertices (odd) and control points (even)</span>
0299 <span class="comment">% OUTPUT:</span>
0300 <span class="comment">% points   - same as points but with linear control points removed</span>
0301 <span class="comment">% spln_sgmnts - boolean array indicating which segments are splines</span>
0302 <a name="_sub4" href="#_subfunctions" class="code">function [points, spln_sgmnts] = remove_linear_control_points(points)</a>
0303 n_points = length(points);
0304 points(end+1,:) = points(1,:);
0305 spln_sgmnts(1:(n_points/2)) = 1;
0306 <span class="keyword">for</span> i = 1:2:n_points
0307     a = (points(i+1,:) - points(i,:));
0308     a = a/norm(a);
0309     b = (points(i+2,:) - points(i,:));
0310     b = b/norm(b); 
0311     <span class="keyword">if</span> a(1) == b(1) &amp;&amp; a(2) == b(2)
0312         spln_sgmnts(i/2 + 0.5) = 0;
0313     <span class="keyword">end</span>    
0314 <span class="keyword">end</span>
0315 idx = find(spln_sgmnts==0) * 2;
0316 points(idx,:) = [];
0317 points(<span class="keyword">end</span>,:) = [];
0318 
0319     
0320 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0321 <span class="comment">% INPUT:</span>
0322 <span class="comment">% points - [N x 2] defined vertices</span>
0323 <span class="comment">% OUTPUT:</span>
0324 <span class="comment">% out    - interpolated vertices</span>
0325 <a name="_sub5" href="#_subfunctions" class="code">function out = interpolate_shape(points, n_points)</a>
0326 <span class="comment">% Quadratic spline interpolation of the points provided.</span>
0327 
0328 
0329 [pp m] = <a href="piece_poly_fit.html" class="code" title="function [pp, m] = piece_poly_fit(points, fstr, linear_frac)">piece_poly_fit</a>(points);
0330 p = linspace(0,1,n_points+1)'; p(end) = [];
0331 [th xy] = <a href="piece_poly_fit.html" class="code" title="function [pp, m] = piece_poly_fit(points, fstr, linear_frac)">piece_poly_fit</a>(pp,0,p);
0332 tmp = [th xy];
0333 tmp = sortrows(tmp,-1);<span class="comment">% ensure clockwise direction</span>
0334 xy = tmp(:,2:3);
0335 
0336 out = xy + repmat(m, [n_points,1]);
0337 
0338 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0339 <span class="comment">% INPUT:</span>
0340 <span class="comment">% points - [N x 2] defined vertices</span>
0341 <span class="comment">% OUTPUT:</span>
0342 <span class="comment">% out    - interpolated vertices</span>
0343 <a name="_sub6" href="#_subfunctions" class="code">function out = fourier_interpolate_shape(points, n_points)</a>
0344 <span class="comment">% Quadratic spline interpolation of the points provided.</span>
0345 
0346 
0347 pp = <a href="fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(points, size(points,1)-1); <span class="comment">% don't want to overfit</span>
0348 p = linspace(0,1,n_points+1)'; p(end) = [];
0349 xy = <a href="fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(pp,p);
0350 <span class="comment">% [th r] = cart2pol(xy);</span>
0351 <span class="comment">% tmp = [th xy];</span>
0352 <span class="comment">% tmp = sortrows(tmp,-1);% ensure clockwise direction</span>
0353 <span class="comment">% xy = tmp(:,2:3);</span>
0354 
0355 out = xy;<span class="comment">% + repmat(m, [n_points,1]);</span>
0356 
0357 
0358 <a name="_sub7" href="#_subfunctions" class="code">function out = calc_vertex_dir(points, edges, edgnrm)</a>
0359 <span class="comment">%     calculate the direction of vertex movement if all edges are shifted</span>
0360 <span class="comment">%     outwards by 1 unit along their normals:</span>
0361 
0362 <span class="comment">%     duplicate last edge at the beginning</span>
0363     edg = [edges(<span class="keyword">end</span>,:) ; edges];
0364     edgnrm = [edgnrm(<span class="keyword">end</span>,:) ; edgnrm];
0365 
0366     out = zeros(size(points));
0367     <span class="keyword">for</span> i = 1:length(points)
0368         p1 = points(i,:) + edgnrm(i,:);
0369         p2 = points(i,:) + edgnrm(i+1,:);
0370 
0371         dir1(1) = edgnrm(i,2); dir1(2) = -edgnrm(i,1);
0372         dir2(1) = edgnrm(i+1,2); dir2(2) = -edgnrm(i+1,1);
0373         <span class="comment">% if the edge directions are the same (accounting for round-off</span>
0374         <span class="comment">% error), return the edge normal.</span>
0375         <span class="keyword">if</span> isempty(find(abs(dir1 - dir2) &gt; 1e-14))
0376             out(i,:) = edgnrm(i,:);
0377         <span class="keyword">else</span>
0378             A = [dir1' , -dir2'];
0379             u = (p2 - p1)';
0380             x = A\u;
0381             out(i,:) = x(1) * dir1 + p1 - points(i,:);
0382         <span class="keyword">end</span>
0383     <span class="keyword">end</span>
0384 
0385 <a name="_sub8" href="#_subfunctions" class="code">function out = calc_centroid(points)</a>
0386 <span class="comment">% Calculates the centroid of the shape</span>
0387 <span class="comment">% The algorithm identifies a middle point M within the shape and then uses it</span>
0388 <span class="comment">% to divide the shape into N triangles (N=number of vertices), calculates</span>
0389 <span class="comment">% the area and centroid of each traingle, and finally computes the centroid</span>
0390 <span class="comment">% of the shape as a mean of the centroids of the individual traingles</span>
0391 <span class="comment">% weighted by their area.</span>
0392 
0393     <span class="comment">% it never makes sense to have less than 3 points</span>
0394     n_points = size(points,1);
0395     <span class="keyword">if</span>  n_points == 3
0396         out = mean(points); <span class="comment">% centroid of a triangle</span>
0397         <span class="keyword">return</span>
0398     <span class="keyword">end</span>
0399 
0400     out = 0;
0401     pts = [points ; points(1,:)];
0402 
0403     <span class="comment">% guess a point in the middle</span>
0404     m = mean(points);
0405 
0406     <span class="keyword">if</span> ~inpolygon(m(1),m(2),points(:,1),points(:,2))
0407         f1 = figure;
0408         set(f1,<span class="string">'Name'</span>, <span class="string">'Select a point within the shape'</span>);
0409         plot(pts(:,1),pts(:,2));
0410         m = ginput(1);
0411         close(f1)
0412     <span class="keyword">end</span>
0413 
0414     tmp = 0;
0415     tot_area = 0;
0416     <span class="keyword">for</span> i = 1:n_points
0417         a = pts(i,:);
0418         b = pts(i+1,:);
0419         cntrd = (m + a + b)/3;
0420         area = 0.5 * abs(det([m 1; a 1; b 1]));
0421         tmp = tmp + cntrd*area;
0422         tot_area = tot_area + area;
0423     <span class="keyword">end</span>
0424 
0425     out = tmp./tot_area;
0426 
0427 <a name="_sub9" href="#_subfunctions" class="code">function out = calc_convex(verts)</a>
0428 <span class="comment">% Returns an array of boolean values for every vertex, true if the external</span>
0429 <span class="comment">% angle at this vertex is greater or equal to 180 degrees, false otherwise.</span>
0430 <span class="comment">% This marks the vertices which upset the convexity of the polygon and</span>
0431 <span class="comment">% require special treatment.</span>
0432 
0433 n_verts = size(verts,1);
0434 tmp = [verts(<span class="keyword">end</span>,:); verts; verts(1,:)];
0435 verts = tmp;
0436 
0437 <span class="keyword">for</span> i = 2:n_verts+1
0438     v1 = [verts(i-1,:) - verts(i,:), 0];
0439     v2 = [verts(i+1,:) - verts(i,:), 0];
0440     cp = cross(v1',v2);
0441     out(i-1) = cp(3) &gt;= 0;
0442 <span class="keyword">end</span>
0443 
0444 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0445 <span class="comment">% ELECTRODE POSITIONS:</span>
0446 <span class="comment">%  elec_pos = [n_elecs_per_plane,(0=equal angles,1=equal dist),z_planes]</span>
0447 <span class="comment">%     OR</span>
0448 <span class="comment">%  elec_pos = [degrees,z] centres of each electrode (N_elecs x 2)</span>
0449 <span class="comment">%</span>
0450 <span class="comment">% ELECTRODE SHAPES::</span>
0451 <span class="comment">%  elec_shape = [width,height, {maxsz}]  % Rectangular elecs</span>
0452 <span class="comment">%     OR</span>
0453 <span class="comment">%  elec_shape = [radius, {0, maxsz} ]  % Circular elecs</span>
0454 <span class="comment">%     maxsz  (OPT)  -&gt; max size of mesh elems (default = courase mesh)</span>
0455 <span class="comment">%</span>
0456 <span class="comment">% OUTPUT:</span>
0457 <span class="comment">%  elecs(i).pos   = [x,y,z]</span>
0458 <span class="comment">%  elecs(i).shape = 'C' or 'R'</span>
0459 <span class="comment">%  elecs(i).dims  = [radius] or [width,height]</span>
0460 <span class="comment">%  elecs(i).maxh  = '-maxh=#' or '';</span>
0461 <a name="_sub10" href="#_subfunctions" class="code">function [elecs, centres] = parse_elecs(elec_pos, elec_shape, tank_shape, hig, is2D )</a>
0462 
0463     <span class="keyword">if</span> isempty(elec_pos)
0464         elecs = [];
0465         centres = [];
0466         <span class="keyword">return</span>; <span class="comment">% no electrodes, nothing to do</span>
0467     <span class="keyword">end</span>
0468     
0469    <span class="keyword">if</span> is2D
0470       elec_pos(:,3) = hig/2;
0471    <span class="keyword">end</span>
0472    
0473    <span class="comment">% temp fix</span>
0474    rad = tank_shape.size;
0475 
0476    <span class="comment">% It never makes sense to specify only one elec</span>
0477    <span class="comment">% So elec_pos means the number of electrodes in this case</span>
0478    <span class="keyword">if</span> size(elec_pos,1) == 1
0479        <span class="comment">% Parse elec_pos = [n_elecs_per_plane,(0=equal angles,1=equal dist),z_planes]</span>
0480       n_elecs= elec_pos(1); <span class="comment">% per plane</span>
0481       offset = elec_pos(2) - floor(elec_pos(2));
0482       <span class="keyword">switch</span> floor(elec_pos(2))
0483           <span class="keyword">case</span> 0
0484               th = linspace(0,2*pi, n_elecs+1)'; th(end)=[];
0485               th = th + offset*2*pi;
0486               ind = th &gt;= 2*pi;
0487               th(ind) = th(ind) - 2*pi;
0488           <span class="keyword">case</span> 1
0489               <span class="comment">% piece_poly_fit doesn't seem to work very well</span>
0490               <span class="keyword">if</span> 1<span class="comment">%tank_shape.curve_type == 4</span>
0491                   pp = <a href="fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(tank_shape.vertices,<span class="keyword">...</span>
0492                       size(tank_shape.vertices,1) - 1,tank_shape.vertices(1,:));
0493                   p = linspace(0,1,n_elecs+1)'; p(end) = [];
0494                   p = p + offset;
0495                   xy = <a href="fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(pp,p);
0496                  <span class="comment">% NOTE, THIS IS A HACK. Some complicated shapes can't be</span>
0497                  <span class="comment">% described by angle alone</span>
0498                   th = atan2(xy(:,2) - tank_shape.centroid(2), <span class="keyword">...</span>
0499                              xy(:,1) - tank_shape.centroid(1));
0500 
0501               <span class="keyword">elseif</span> any( tank_shape.curve_type == [1,2,3] )
0502                   <span class="comment">% I can't seem able to get the first electrode exactly on</span>
0503                   <span class="comment">% the first vertex</span>
0504                   pp= <a href="piece_poly_fit.html" class="code" title="function [pp, m] = piece_poly_fit(points, fstr, linear_frac)">piece_poly_fit</a>(tank_shape.vertices);
0505                   p = linspace(1,0,n_elecs+1)'; p(end) = [];
0506                   off = offset*2*pi + tank_shape.vertices_polar(1,1);
0507                   th = <a href="piece_poly_fit.html" class="code" title="function [pp, m] = piece_poly_fit(points, fstr, linear_frac)">piece_poly_fit</a>(pp,off,p);
0508               <span class="keyword">else</span>
0509                   error(<span class="string">'curve_type unrecognized'</span>);
0510               <span class="keyword">end</span>
0511       <span class="keyword">end</span>
0512 
0513       on_elecs = ones(n_elecs, 1);
0514       el_th = []; 
0515       el_z  = []; 
0516       <span class="keyword">for</span> i=3:length(elec_pos)
0517         el_th = [el_th; th];
0518         el_z  = [el_z ; on_elecs*elec_pos(i)];
0519       <span class="keyword">end</span>
0520    <span class="keyword">else</span>
0521       el_th = elec_pos(:,1)*2*pi/360;
0522       el_z  = elec_pos(:,2);
0523    <span class="keyword">end</span>
0524       
0525    n_elecs= size(el_z,1); 
0526 
0527    <span class="keyword">if</span> size(elec_shape,1) == 1
0528       elec_shape = ones(n_elecs,1) * elec_shape;
0529    <span class="keyword">end</span>
0530 
0531    <span class="keyword">for</span> i= 1:n_elecs
0532      row = elec_shape(i,:); 
0533      elecs(i) = <a href="#_sub13" class="code" title="subfunction elec = elec_spec( row, is2D, hig, rad )">elec_spec</a>( row, is2D, hig, rad );
0534    <span class="keyword">end</span>
0535    
0536    
0537    <span class="comment">%centres = [rad*sin(el_th),rad*cos(el_th),el_z];</span>
0538    <span class="keyword">for</span> i= 1:n_elecs; 
0539 <span class="comment">%        switch tank_shape.curve_type</span>
0540 <span class="comment">%            case 1</span>
0541                [centres(i,1:2), normal] = <a href="#_sub11" class="code" title="subfunction [pos, normal] = calc_elec_centre(tank_shape, th)">calc_elec_centre</a>(tank_shape, el_th(i));
0542 <span class="comment">%            case{2, 3}</span>
0543 <span class="comment">%                [centres(i,1:2), normal] = calc_elec_centre_spline(tank_shape, el_th(i));</span>
0544 <span class="comment">%            otherwise</span>
0545 <span class="comment">%                error('Unknown curve type');</span>
0546 <span class="comment">%        end</span>
0547        centres(i,3) = el_z(i);
0548        elecs(i).pos  = centres(i,:);
0549        <span class="keyword">if</span> elecs(i).discretize &gt; 0
0550         <span class="comment">% this bit is to prevent netgen choking on slightly misalligned</span>
0551         <span class="comment">% electrods</span>
0552         th = cart2pol(normal(1),normal(2));
0553         frac = 2*pi /elecs(i).discretize ;
0554         th = frac * round( th / frac);
0555         [normal(1) normal(2)] = pol2cart(th,1);
0556        <span class="keyword">end</span>
0557        elecs(i).normal = normal;
0558        
0559    <span class="keyword">end</span>
0560 
0561    <span class="keyword">if</span> n_elecs == 0
0562       elecs= struct([]); <span class="comment">% empty</span>
0563       centres= []; 
0564    <span class="keyword">end</span>
0565 
0566    
0567    
0568     <a name="_sub11" href="#_subfunctions" class="code">function [pos, normal] = calc_elec_centre(tank_shape, th)</a>
0569         <span class="comment">% The calculation relies on the theorem that if point D lies on a</span>
0570         <span class="comment">% line between B and C, but point A is not on that line, then:</span>
0571         <span class="comment">%   |BD|    |AB| sin(&lt;DAB)</span>
0572         <span class="comment">%   ---- = ---------------</span>
0573         <span class="comment">%   |DC|    |AC| sin(&lt;DAC)</span>
0574         <span class="comment">% Thus, B and C are vertices of our shape, A is its centroid and D</span>
0575         <span class="comment">% is the sought center of the electrode. All quantities on RHS are</span>
0576         <span class="comment">% known.</span>
0577         
0578         <span class="comment">% make sure th is between -pi and pi</span>
0579         <span class="keyword">if</span> th &gt; pi; th = th - 2*pi; <span class="keyword">end</span>
0580         
0581         
0582         vert_pol = tank_shape.vertices_polar; <span class="comment">%[th, r]</span>
0583         
0584      
0585         n_vert = size(vert_pol,1);
0586         vert_pol = [vert_pol , (1:n_vert)'];
0587         <span class="comment">% Re-order the vertices -pi to pi. Now counter-clockwise</span>
0588         vert_pol = sortrows(vert_pol,1); 
0589         <span class="comment">% find the edge on which the elctrode lies. (Edge 1 is between</span>
0590         <span class="comment">% verticies 1 and 2)</span>
0591         idx = find(vert_pol(:,1) &gt; th, 1, <span class="string">'first'</span>);
0592         <span class="keyword">if</span> isempty(idx); idx = 1; <span class="keyword">end</span>
0593         edg_no = vert_pol(idx,3);
0594         
0595         
0596         normal = tank_shape.edge_normals(edg_no,:);
0597               
0598         v1 = edg_no;
0599         <span class="keyword">if</span> edg_no == n_vert <span class="comment">% between the last and first vertex</span>
0600             v2 = 1;
0601         <span class="keyword">else</span>
0602             v2 = v1+1;
0603         <span class="keyword">end</span>
0604         vert_pol = [];
0605         
0606         
0607         vert_pol = tank_shape.vertices_polar;
0608         vert = tank_shape.vertices;
0609         cntr = tank_shape.centroid;
0610         <span class="comment">% position between vertices - see first comment</span>
0611         AB = sqrt(sum( (vert(v1,:) - cntr).^2 ));
0612         AC = sqrt(sum( (vert(v2,:) - cntr).^2 ));
0613         DAB = abs(vert_pol(v1,1)-th); 
0614         <span class="keyword">if</span> DAB &gt; pi, DAB = abs( DAB - 2*pi); <span class="keyword">end</span>; 
0615         DAC  = abs(vert_pol(v2,1)-th);
0616         <span class="keyword">if</span> DAC &gt; pi, DAC = abs( DAC - 2*pi); <span class="keyword">end</span>;
0617         <span class="keyword">if</span> DAC ~= 0
0618             ratio = AB * sin(DAB) / (AC * sin(DAC));
0619             pos = vert(v1,:) + ( ratio / (1 + ratio) ) * (vert(v2,:) - vert(v1,:));
0620         <span class="keyword">else</span>
0621             pos = vert(v2,:);
0622         <span class="keyword">end</span>
0623 
0624         
0625         
0626    <a name="_sub12" href="#_subfunctions" class="code">function [pos, normal] = calc_elec_centre_spline(tank_shape, th)</a>
0627         <span class="comment">% The calculation proceeds by finding a common point between a line</span>
0628         <span class="comment">% from the centroid outwards and the equation of the relevant</span>
0629         <span class="comment">% quadratic spline segment defined using 3 control points</span>
0630         
0631         <span class="comment">% make sure th is between -pi and pi</span>
0632         <span class="keyword">if</span> th &gt; pi; th = th - 2*pi; <span class="keyword">end</span> 
0633         
0634         vert_pol = tank_shape.vertices_polar; <span class="comment">%[th, r]</span>
0635         
0636         <span class="comment">% The number of vertices must be even, but just in case...</span>
0637         <span class="keyword">if</span> mod(size(vert_pol,1),2)
0638             error([<span class="string">'The number of points must be even. '</span><span class="keyword">...</span>
0639                 <span class="string">'One de Boor control point for every vertex'</span>]);
0640         <span class="keyword">end</span>
0641         
0642         <span class="comment">% if the curve is defined as splines, every second point is not</span>
0643         <span class="comment">% actually a vertex. We remove them.</span>
0644         <span class="keyword">if</span> tank_shape.curve_type == 2 || tank_shape.curve_type == 3
0645             vert_pol(2:2:<span class="keyword">end</span>,:) = [];
0646         <span class="keyword">end</span>
0647       
0648         n_vert = size(vert_pol,1);
0649    
0650         vert_pol = [vert_pol , (1:n_vert)']; <span class="comment">%excludes control points</span>
0651         <span class="comment">% Re-order the vertices -pi to pi. Now counter-clockwise</span>
0652         vert_pol = sortrows(vert_pol,1); 
0653         <span class="comment">% find the edge on which the electrode lies. Edge 1 is between</span>
0654         <span class="comment">% vertices 1 and 2.</span>
0655         idx = find(vert_pol(:,1) &gt; th, 1, <span class="string">'first'</span>);
0656         <span class="keyword">if</span> isempty(idx); idx = 1; <span class="keyword">end</span>
0657         edg_no = vert_pol(idx,3);
0658         
0659         v1 = edg_no;
0660         <span class="keyword">if</span> edg_no == n_vert <span class="comment">% between the last and first vertex</span>
0661             v2 = 1;
0662         <span class="keyword">else</span>
0663             v2 = v1+1;
0664         <span class="keyword">end</span>
0665         vert_pol = [];
0666         
0667         <span class="comment">% correcting for the control points</span>
0668         v1 = 2 * v1 - 1;
0669         v2 = 2 * v2 - 1;
0670         
0671         <span class="comment">% the spline goes from point P0 to P2 such that P1-P0 is a tangent</span>
0672         <span class="comment">% at P0 and P2-P1 is a tangent at P2</span>
0673         C = tank_shape.centroid;
0674         P0 = tank_shape.vertices(v1,:) - C;
0675         P1 = tank_shape.vertices(v1+1,:) - C; <span class="comment">% control point</span>
0676         P2 = tank_shape.vertices(v2,:) - C;
0677         
0678         
0679         <span class="comment">% find the gradient of the line from centroid to electrode center:</span>
0680         [x, y] = pol2cart(th, 1);
0681         <span class="comment">% FIXME: This doesn't crash only because of round-off errors.</span>
0682         g = y/x;
0683         <span class="comment">% (because we subtracted the centroid from the vertices, the line</span>
0684         <span class="comment">% passes through the origin now)</span>
0685         
0686         <span class="comment">% the spline is f(t) = (1-t)^2 * P0 + 2t(1-t)P1 + t^2 * P2</span>
0687         <span class="comment">% which can also be expressed as</span>
0688         f = @(t) (P2 - 2*P1 + P0)*t^2 + 2*(P1 - P0)*t + P0;
0689         <span class="comment">% and it's derivative:</span>
0690         df = @(t) 2*(P2 - 2*P1 + P0)*t + 2*(P1 - P0);
0691         <span class="comment">% to find the value of t for which the line cross, we substitute</span>
0692         <span class="comment">% p0 = y0-ax0 for P0 and so on.</span>
0693         p0 = P0(2) - g * P0(1);
0694         p1 = P1(2) - g * P1(1);
0695         p2 = P2(2) - g * P2(1);
0696         
0697         <span class="comment">% thus we have a quadratic equation a*t^2 + b*t + c = 0 where</span>
0698         a = (p2 - 2*p1 + p0);
0699         b = 2* (p1 - p0);
0700         c = p0;
0701         
0702         <span class="keyword">if</span> abs(a) &lt; 1e-10
0703             t = -c/b;
0704             pos = f(t) + C;
0705             tmp = df(t);
0706             normal = [-tmp(2), tmp(1)] / sqrt(sum(tmp.^2));
0707             <span class="keyword">return</span>;
0708         <span class="keyword">end</span>
0709         
0710         <span class="comment">% the determinant is</span>
0711         D = b^2 - 4*a*c;
0712         
0713         <span class="comment">% find the roots</span>
0714         <span class="keyword">if</span> D == 0
0715             t = -b / (2 * a);
0716 
0717         <span class="keyword">elseif</span> D &gt; 0
0718             t1 = (-b - sqrt(D) ) / (2 * a);
0719             t2 = (-b + sqrt(D) ) / (2 * a);
0720             <span class="keyword">if</span> t1 &gt;= 0 &amp;&amp; t1 &lt;= 1
0721                 t = t1;
0722             <span class="keyword">else</span>
0723                 t = t2;
0724             <span class="keyword">end</span>
0725         <span class="keyword">else</span>
0726             error(<span class="string">'Something went wrong, cannot place electrode on spline'</span>);
0727         <span class="keyword">end</span>
0728         
0729         pos = f(t) + C;
0730         tmp = df(t);
0731         normal = [-tmp(2), tmp(1)]/ sqrt(sum(tmp.^2));
0732 
0733    
0734    
0735 
0736 <a name="_sub13" href="#_subfunctions" class="code">function elec = elec_spec( row, is2D, hig, rad )</a>
0737   <span class="keyword">if</span>     is2D
0738      <span class="keyword">if</span> length(row)&gt;=2 &amp;&amp; row(2) == -1 <span class="comment">% Point electrodes</span>
0739         <span class="comment">% Create rectangular electrodes with bottom, cw point where we want</span>
0740         elec.shape = <span class="string">'P'</span> ;
0741         <span class="keyword">if</span> length(row)&gt;=3 &amp;&amp; row(3) &gt; 0
0742            elec.dims  =  row(3);
0743         <span class="keyword">else</span>
0744            elec.dims  =  rad; <span class="comment">% Make big if unspecified</span>
0745         <span class="keyword">end</span>
0746      <span class="keyword">else</span>
0747         <span class="comment">% create circular electrodes for now, rectangular not yet supported</span>
0748 <span class="comment">%         elec.shape = 'C';</span>
0749 <span class="comment">%         elec.dims = row(1);</span>
0750         elec.shape = <span class="string">'R'</span>;
0751         elec.dims  = [row(1),hig];
0752      <span class="keyword">end</span>
0753   <span class="keyword">else</span>
0754      <span class="keyword">if</span> length(row)&lt;2 || row(2) == 0 <span class="comment">% Circular electrodes</span>
0755         elec.shape = <span class="string">'C'</span>;
0756         elec.dims  = row(1);
0757      <span class="keyword">elseif</span> row(2) == -1 <span class="comment">% Point electrodes</span>
0758         <span class="comment">% Create rectangular electrodes with bottom, cw point where we want</span>
0759         elec.shape = <span class="string">'P'</span>; 
0760         <span class="keyword">if</span> length(row)&gt;=3 &amp;&amp; row(3) &gt; 0
0761            elec.dims  =  row(3);
0762         <span class="keyword">else</span>
0763            elec.dims  =  rad; <span class="comment">% Make big if unspecified</span>
0764         <span class="keyword">end</span>
0765      <span class="keyword">elseif</span> row(2)&gt;0      <span class="comment">% Rectangular electrodes</span>
0766         elec.shape = <span class="string">'R'</span>;
0767         elec.dims  = row(1:2);
0768      <span class="keyword">else</span>
0769         error(<span class="string">'negative electrode width'</span>);
0770      <span class="keyword">end</span>
0771   <span class="keyword">end</span>
0772 
0773   <span class="keyword">if</span> length(row)&gt;=3 &amp;&amp; row(3) &gt; 0
0774      elec.maxh = sprintf(<span class="string">'-maxh=%f'</span>, row(3));
0775   <span class="keyword">else</span>
0776      elec.maxh = <span class="string">''</span>;
0777   <span class="keyword">end</span>
0778 
0779   <span class="keyword">if</span> length(row)&lt;4 || row(4) == 0
0780      elec.model = <span class="string">'cem'</span>; <span class="comment">% Complete Electrode Model (CEM)</span>
0781   <span class="keyword">else</span>
0782      elec.model = <span class="string">'pem'</span>; <span class="comment">% Point Electrode Model (PEM)</span>
0783   <span class="keyword">end</span>
0784   <span class="comment">%TODO support Shunt Electrode Model (SEM)</span>
0785 
0786   <span class="keyword">if</span> length(row) &lt; 5 || row(5) == 0
0787       elec.discretize = 0;
0788   <span class="keyword">else</span>
0789       elec.discretize = row(5);
0790   <span class="keyword">end</span>
0791   
0792   
0793   
0794   
0795   
0796   
0797   
0798   
0799   
0800   
0801   
0802   
0803   
0804 <a name="_sub14" href="#_subfunctions" class="code">function write_geo_file(geofn, tank_height, tank_shape, </a><span class="keyword">...</span>
0805                         tank_maxh, elecs, extra_ng_code)
0806     fid=fopen(geofn,<span class="string">'w'</span>);
0807     <a href="#_sub15" class="code" title="subfunction write_header(fid,tank_height,tank_shape,maxsz,extra)">write_header</a>(fid,tank_height,tank_shape,tank_maxh,extra_ng_code);
0808 
0809     n_verts = size(tank_shape.vertices,1);
0810     n_elecs = length(elecs);
0811     <span class="comment">%  elecs(i).pos   = [x,y,z]</span>
0812     <span class="comment">%  elecs(i).shape = 'C' or 'R'</span>
0813     <span class="comment">%  elecs(i).dims  = [radius] or [width,height]</span>
0814     <span class="comment">%  elecs(i).maxh  = '-maxh=#' or '';</span>
0815     <span class="comment">%  elecs(i).edg_no = i (index of the edge on which the electrode lies)</span>
0816     pts_elecs_idx = [];
0817     <span class="comment">%^keyboard</span>
0818     <span class="keyword">for</span> i=1:n_elecs
0819         name = sprintf(<span class="string">'elec%04d'</span>,i);
0820         pos = elecs(i).pos;
0821         dirn = elecs(i).normal;
0822         <span class="keyword">switch</span> elecs(i).shape
0823             <span class="keyword">case</span> <span class="string">'C'</span>
0824                 <a href="#_sub17" class="code" title="subfunction write_circ_elec(fid,name,c, dirn, rd, centroid, maxh)">write_circ_elec</a>(fid,name, pos, dirn,  <span class="keyword">...</span>
0825                     elecs(i).dims, tank_shape.centroid, elecs(i).maxh);
0826             <span class="keyword">case</span> <span class="string">'R'</span>
0827                 <a href="#_sub18" class="code" title="subfunction write_rect_elec(fid,name,c, dirn,wh,d,maxh)">write_rect_elec</a>(fid,name, pos, dirn,  <span class="keyword">...</span>
0828                     elecs(i).dims, tank_shape.size/10, elecs(i).maxh);
0829                 <span class="comment">%        case 'P'</span>
0830                 <span class="comment">%          pts_elecs_idx = [ pts_elecs_idx, i];</span>
0831                 <span class="comment">%          continue; % DON'T print solid cyl</span>
0832 
0833             <span class="keyword">otherwise</span>; error(<span class="string">'unknown electorde shape'</span>);
0834         <span class="keyword">end</span>
0835         <span class="comment">%       fprintf(fid,'solid cyl%04d = trunk   and %s; \n',i,name);</span>
0836     <span class="keyword">end</span>
0837     fprintf(fid,<span class="string">'solid trunk = bound'</span>);
0838     <span class="keyword">if</span> isfield(tank_shape,<span class="string">'additional_shapes'</span>)
0839          <span class="keyword">for</span> i = 1:length(tank_shape.additional_shapes)
0840              fprintf(fid,<span class="string">' and not add_obj%04d'</span>,i);
0841          <span class="keyword">end</span>
0842     <span class="keyword">end</span>
0843     fprintf(fid,<span class="string">';\n'</span>);
0844     
0845     <span class="keyword">if</span> isfield(tank_shape,<span class="string">'additional_shapes'</span>)
0846         <span class="keyword">for</span> i = 1:length(tank_shape.additional_shapes)
0847             fprintf(fid,<span class="string">'solid add_obj%04dc = add_obj%04d'</span>,i,i);
0848             <span class="keyword">for</span> j = (i+1):length(tank_shape.additional_shapes)
0849                 fprintf(fid,<span class="string">' and not add_obj%04d'</span>,j);
0850             <span class="keyword">end</span>
0851 
0852 <span class="comment">% This code was added while trying to debug mixed shapes</span>
0853 <span class="comment">%   with solid geometry and extruded shapes. It didn't help</span>
0854 <span class="comment">%           if ~isempty(extra_ng_code{1})</span>
0855 <span class="comment">%                fprintf(fid,' and not %s',extra_ng_code{1});</span>
0856 <span class="comment">%           end</span>
0857 
0858             fprintf(fid,[<span class="string">' and plane(0,0,0;0,0,-1)\n'</span> <span class="keyword">...</span>
0859                 <span class="string">'      and  plane(0,0,%6.2f;0,0,1)'</span>],tank_height);
0860             fprintf(fid,<span class="string">';\n'</span>);
0861         <span class="keyword">end</span>
0862     <span class="keyword">end</span>
0863     
0864     <span class="keyword">if</span> tank_maxh ~= 0
0865         fprintf(fid,<span class="string">'tlo trunk -transparent -maxh=%f;\n'</span>,tank_maxh);
0866     <span class="keyword">else</span>
0867         fprintf(fid,<span class="string">'tlo trunk -transparent;\n'</span>);
0868     <span class="keyword">end</span>
0869     <span class="keyword">if</span> ~isempty(extra_ng_code{1})
0870         fprintf(fid,<span class="string">'tlo %s -col=[0,1,0];\n'</span>,extra_ng_code{1});
0871     <span class="keyword">end</span>
0872 
0873     <span class="keyword">if</span> isfield(tank_shape,<span class="string">'additional_shapes'</span>)
0874          <span class="keyword">for</span> i = 1:length(tank_shape.additional_shapes)
0875              fprintf(fid,<span class="string">'tlo add_obj%04dc -col=[0,1,0];\n'</span>,i);
0876          <span class="keyword">end</span>
0877     <span class="keyword">end</span>
0878 
0879     <span class="keyword">for</span> i=1:n_elecs
0880         <span class="keyword">if</span> any(i == pts_elecs_idx); <span class="keyword">continue</span>; <span class="keyword">end</span>
0881         fprintf(fid,<span class="string">'tlo elec%04d -col=[1,0,0];\n'</span>,i);
0882     <span class="keyword">end</span>
0883 
0884 
0885     fclose(fid); <span class="comment">% geofn</span>
0886 
0887    
0888    
0889    <a name="_sub15" href="#_subfunctions" class="code">function write_header(fid,tank_height,tank_shape,maxsz,extra)</a>
0890    <span class="keyword">if</span> maxsz==0; 
0891       maxsz = <span class="string">''</span>;
0892    <span class="keyword">else</span>
0893       maxsz = sprintf(<span class="string">'-maxh=%f'</span>,maxsz);
0894    <span class="keyword">end</span>
0895 
0896    <span class="keyword">if</span> ~isempty( extra{1} )
0897       extra{1} = [<span class="string">' and not '</span>,extra{1}];
0898    <span class="keyword">end</span>
0899 
0900    
0901    fprintf(fid,<span class="string">'#Automatically generated by ng_mk_extruded_model\n'</span>);
0902    fprintf(fid,<span class="string">'algebraic3d\n'</span>);
0903    fprintf(fid,<span class="string">'%s\n'</span>,extra{2}); <span class="comment">% Define extra stuff here</span>
0904    
0905    fprintf(fid,<span class="string">'curve3d extrsncurve=(2; 0,0,0; 0,0,%6.2f; 1; 2,1,2);\n'</span>, <span class="keyword">...</span>
0906        tank_height+1);
0907 
0908 
0909    <a href="#_sub16" class="code" title="subfunction write_curve(fid, tank_shape, name, scale)">write_curve</a>(fid,tank_shape,<span class="string">'outer'</span>, 1.15);
0910    <a href="#_sub16" class="code" title="subfunction write_curve(fid, tank_shape, name, scale)">write_curve</a>(fid,tank_shape,<span class="string">'inner'</span>, 0.99);
0911    <a href="#_sub16" class="code" title="subfunction write_curve(fid, tank_shape, name, scale)">write_curve</a>(fid,tank_shape,<span class="string">'surf'</span>, 1);
0912    
0913     fprintf(fid,[<span class="string">'solid bound= plane(0,0,0;0,0,-1)\n'</span> <span class="keyword">...</span>
0914                 <span class="string">'      and  plane(0,0,%6.2f;0,0,1)\n'</span> <span class="keyword">...</span>
0915                 <span class="string">'      and  extrusion(extrsncurve;surf;0,1,0)'</span><span class="keyword">...</span>
0916                 <span class="string">'%s %s;\n'</span>],tank_height,extra{1},maxsz);
0917             
0918    fprintf(fid,[<span class="string">'solid inner_bound= plane(0,0,0;0,0,-1)\n'</span> <span class="keyword">...</span>
0919                 <span class="string">'      and  plane(0,0,%6.2f;0,0,1)\n'</span> <span class="keyword">...</span>
0920                 <span class="string">'      and  extrusion(extrsncurve;inner;0,1,0)'</span><span class="keyword">...</span>
0921                 <span class="string">'%s %s;\n'</span>],tank_height,extra{1},maxsz);
0922 
0923    fprintf(fid,[<span class="string">'solid outer_bound= plane(0,0,0;0,0,-1)\n'</span> <span class="keyword">...</span>
0924                 <span class="string">'      and  plane(0,0,%6.2f;0,0,1)\n'</span> <span class="keyword">...</span>
0925                 <span class="string">'      and  extrusion(extrsncurve;outer;0,1,0)'</span><span class="keyword">...</span>
0926                 <span class="string">'%s %s;\n'</span>],tank_height,extra{1},maxsz);
0927            
0928    <span class="comment">% EVERYTHING below this line assumes additional shapes are defined</span>
0929    <span class="keyword">if</span> ~isfield(tank_shape, <span class="string">'additional_shapes'</span>), <span class="keyword">return</span>, <span class="keyword">end</span>
0930    
0931    <span class="keyword">for</span> i = 1:length(tank_shape.additional_shapes)
0932        name_curve = sprintf(<span class="string">'add_curve%04d'</span>,i); 
0933        <a href="#_sub16" class="code" title="subfunction write_curve(fid, tank_shape, name, scale)">write_curve</a>(fid,tank_shape.additional_shapes{i},name_curve);
0934        name_obj = sprintf(<span class="string">'add_obj%04d'</span>,i); 
0935        fprintf(fid,[<span class="string">'solid %s= plane(0,0,%6.2f;0,0,-1)\n'</span> <span class="keyword">...</span>
0936            <span class="string">'      and  plane(0,0,%6.2f;0,0,1)\n'</span> <span class="keyword">...</span>
0937            <span class="string">'      and  extrusion(extrsncurve;%s;0,1,0)'</span><span class="keyword">...</span>
0938            <span class="string">'%s %s;\n'</span>],name_obj,-i,tank_height+i,name_curve,extra{1},maxsz);
0939    <span class="keyword">end</span>
0940                    
0941         
0942    <a name="_sub16" href="#_subfunctions" class="code">function write_curve(fid, tank_shape, name, scale)</a>
0943         <span class="keyword">if</span> nargin &lt;4
0944             scale = 1;
0945         <span class="keyword">end</span>
0946        
0947         is_struct = isstruct(tank_shape);
0948         <span class="keyword">if</span> ~is_struct
0949             vertices = tank_shape;
0950             STRUCT = false;
0951             <span class="keyword">if</span> scale ~= 1
0952                 warning(<span class="string">'Scale is ignored when second input is an array'</span>);
0953                 scale = 1;
0954             <span class="keyword">end</span>
0955         <span class="keyword">elseif</span> scale ~= 1
0956             vertices = tank_shape.vertices + <span class="keyword">...</span>
0957                 (scale-1)*tank_shape.vertex_dir*tank_shape.size;
0958         <span class="keyword">else</span>
0959             vertices = tank_shape.vertices;
0960         <span class="keyword">end</span>
0961        n_vert = size(vertices,1);
0962        
0963        fprintf(fid,<span class="string">'curve2d %s=(%d; \n'</span>, name, n_vert);
0964        
0965        <span class="keyword">for</span> i = 1:n_vert
0966            <span class="comment">% because of the definitions of the local axis in extrusion, the</span>
0967            <span class="comment">% x coordinate has to be multiplied by -1. This assures the</span>
0968            <span class="comment">% object appears at the expected coordinates. To maintain</span>
0969            <span class="comment">% clockwise order (required by netget) the vertices are printed</span>
0970            <span class="comment">% in the opposite order.</span>
0971            fprintf(fid,<span class="string">'       %6.4f, %6.4f;\n'</span>,[-1 1].*vertices(n_vert-i+1,:));
0972            <span class="comment">%             fprintf(fid,'       %6.2f, %6.2f;\n',vertices(i,:));</span>
0973        <span class="keyword">end</span>
0974        <span class="keyword">if</span> is_struct
0975            spln_sgmnts = tank_shape.spln_sgmnts;
0976        <span class="keyword">else</span>
0977            spln_sgmnts = zeros(max(size(vertices)));
0978        <span class="keyword">end</span>
0979        n_sgmnts = length(spln_sgmnts);
0980        fprintf(fid,<span class="string">'       %d;\n'</span>,n_sgmnts);
0981        cv = 1; <span class="comment">%current vertex</span>
0982        <span class="keyword">for</span> i = 1:n_sgmnts
0983            <span class="keyword">if</span> spln_sgmnts(i)
0984                <span class="keyword">if</span> i == n_sgmnts
0985                   fprintf(fid,<span class="string">'       %d, %d, %d, %d );\n\n\n'</span>, 3, cv,cv+1, 1);
0986                <span class="keyword">else</span>
0987                    fprintf(fid,<span class="string">'       %d, %d, %d, %d; \n'</span>, 3, cv, cv+1, cv+2);
0988                <span class="keyword">end</span>
0989                cv = cv + 2;
0990            <span class="keyword">else</span>
0991                <span class="keyword">if</span> i == n_sgmnts
0992                    fprintf(fid,<span class="string">'       %d, %d, %d );\n\n\n'</span>, 2, cv, 1);
0993                <span class="keyword">else</span>
0994                    fprintf(fid,<span class="string">'       %d, %d, %d; \n'</span>, 2, cv, cv+1);
0995                <span class="keyword">end</span>
0996                cv = cv + 1;
0997            <span class="keyword">end</span>
0998        <span class="keyword">end</span>
0999        
1000        
1001 <a name="_sub17" href="#_subfunctions" class="code">function write_circ_elec(fid,name,c, dirn, rd, centroid, maxh)</a>
1002 <span class="comment">% writes the specification for a netgen cylindrical rod on fid,</span>
1003 <span class="comment">%  named name, centerd on c,</span>
1004 <span class="comment">% in the direction given by vector dirn, radius rd</span>
1005 <span class="comment">% direction is in the xy plane</span>
1006 
1007     <span class="comment">% the direction vector</span>
1008     dirn(3) = 0; dirn = dirn/norm(dirn);
1009 
1010     fprintf(fid,<span class="string">'solid %s  = '</span>, name);
1011     fprintf(fid,[<span class="string">'  outer_bound and not inner_bound and '</span><span class="keyword">...</span>
1012         <span class="string">'cylinder(%6.3f,%6.3f,%6.3f;%6.3f,%6.3f,%6.3f;%6.3f) '</span><span class="keyword">...</span>
1013         <span class="string">'and plane(%6.3f,%6.3f,%6.3f;%6.3f,%6.3f,%6.3f) '</span><span class="keyword">...</span>
1014         <span class="string">'and not bound %s;\n'</span>], <span class="keyword">...</span>
1015         c(1)-dirn(1),c(2)-dirn(2),c(3)-dirn(3),<span class="keyword">...</span>
1016         c(1)+dirn(1),c(2)+dirn(2),c(3)+dirn(3), rd, <span class="keyword">...</span>
1017         centroid(1), centroid(2), 0, -dirn(1), -dirn(2), dirn(3),maxh);
1018 
1019 <a name="_sub18" href="#_subfunctions" class="code">function write_rect_elec(fid,name,c, dirn,wh,d,maxh)</a>
1020 <span class="comment">% writes the specification for a netgen cuboid on fid, named name, centerd on c,</span>
1021 <span class="comment">% in the direction given by vector dirn,</span>
1022 <span class="comment">% hw = [height, width]  and depth d</span>
1023 <span class="comment">% direction is in the xy plane</span>
1024    w = wh(1); h= wh(2);
1025    dirn(3) = 0; dirn = dirn/norm(dirn);
1026    dirnp = [-dirn(2),dirn(1),0];
1027    dirnp = dirnp/norm(dirnp);
1028 
1029    bl = c - (d/2)* dirn + (w/2)*dirnp - [0,0,h/2];
1030    tr = c + (d/2)* dirn - (w/2)*dirnp + [0,0,h/2];
1031    fprintf(fid,<span class="string">'solid %s  = outer_bound and not inner_bound and'</span>, name);
1032    fprintf(fid,<span class="string">' plane (%6.3f,%6.3f,%6.3f;0, 0, -1) and\n'</span>, <span class="keyword">...</span>
1033            bl(1),bl(2),bl(3));
1034    fprintf(fid,<span class="string">' plane(%6.3f,%6.3f,%6.3f;%6.3f,%6.3f,%6.3f) and\n'</span>, <span class="keyword">...</span>
1035            bl(1),bl(2),bl(3),-dirn(1),-dirn(2),0);
1036    fprintf(fid,<span class="string">' plane(%6.3f,%6.3f,%6.3f;%6.3f,%6.3f,%6.3f) and\n'</span>, <span class="keyword">...</span>
1037            bl(1),bl(2),bl(3),dirnp(1),dirnp(2),0);
1038    fprintf(fid,<span class="string">' plane(%6.3f,%6.3f,%6.3f;0, 0, 1) and\n'</span>, <span class="keyword">...</span>
1039            tr(1),tr(2),tr(3));
1040    fprintf(fid,<span class="string">' plane(%6.3f,%6.3f,%6.3f;%6.3f,%6.3f,%6.3f) and\n'</span>, <span class="keyword">...</span>
1041            tr(1),tr(2),tr(3),dirn(1),dirn(2),0);
1042    fprintf(fid,<span class="string">' plane(%6.3f,%6.3f,%6.3f;%6.3f,%6.3f,%6.3f  )\n'</span>, <span class="keyword">...</span>
1043            tr(1),tr(2),tr(3),-dirnp(1),-dirnp(2),0);
1044    fprintf(fid,<span class="string">' and not bound %s;\n'</span>, maxh);
1045     
1046 <span class="comment">% NG_REMOVE_ELECTRODES: cleans up matrices read from a *.vol file</span>
1047 <span class="comment">% [srf,vtx,fc,bc,simp,edg,mat_ind]= ng_remove_electrodes...</span>
1048 <span class="comment">%     (srf,vtx,fc,bc,simp,edg,mat_ind, N_elec)</span>
1049 <span class="comment">%</span>
1050 <span class="comment">% Used to clean up external objects used to force electrode meshing in</span>
1051 <span class="comment">% ng_mk_extruded_model.</span>
1052 <span class="comment">%</span>
1053 <a name="_sub19" href="#_subfunctions" class="code">function [srf,vtx,fc,bc,simp,edg,mat_ind] = ng_remove_electrodes</a><span class="keyword">...</span>
1054     (srf,vtx,fc,bc,simp,edg,mat_ind, N_elec)
1055 
1056 fc = []; <span class="comment">% Unused, and we're not sure what it is;</span>
1057 
1058 <span class="comment">% total objects:</span>
1059 N_obj = max(mat_ind);
1060 
1061 <span class="comment">% The electodes are the last N_elec simps</span>
1062 elec_ind = mat_ind &gt; (N_obj - N_elec);
1063 
1064 in = unique(simp(~elec_ind,:)); <span class="comment">% nodes in real object</span>
1065 out = unique(simp(elec_ind,:)); <span class="comment">% nodes in electrodes</span>
1066 boundary = intersect(in,out);   <span class="comment">% nodes shared obj/electrodes</span>
1067 out = setdiff(out,boundary);    <span class="comment">% nodes only in electrodes</span>
1068 
1069 <span class="comment">% remove simps which contain nodes in the &quot;out&quot; list</span>
1070 remove_simp = any( ismember(simp,out), 2);
1071 simp0 = simp;
1072 simp( remove_simp,:) = [];
1073 
1074 <span class="comment">% Choose which vertices to keep</span>
1075 vtx_renum = logical( zeros(size(vtx,1),1) );
1076 vtx_renum( in ) = logical(1);
1077 vtx_renum = cumsum(vtx_renum);
1078 
1079 vtx(out,:) = [];
1080 simp =  reshape( vtx_renum(simp), size(simp));
1081 
1082 <span class="comment">% recalculate surface</span>
1083 <span class="comment">% STUPID MATLAB BUGS MEAN WE CANT allow int32 here</span>
1084 srf= double( <a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(simp) );
1085 bc = ones(size(srf,1),1); <span class="comment">% Add srf for the electrodes</span>
1086 
1087 <span class="comment">% Iterate over electrodes</span>
1088 <span class="keyword">for</span> i=1:N_elec;
1089   eleci_obj = mat_ind == (N_obj - N_elec + i);
1090   this_elec = unique( simp0( eleci_obj, : ));
1091   eleci_nodes = vtx_renum( intersect( this_elec, in )); 
1092 
1093 <span class="comment">% This is the direct way to get electrodes. Instead we need to call the</span>
1094 <span class="comment">%   electrode finder function</span>
1095 <span class="comment">% elec(i).nodes = eleci_nodes;</span>
1096   
1097   eleci_srf = all( ismember(srf, eleci_nodes), 2);
1098   bc( eleci_srf ) = i+1; <span class="comment">% give this elec a surface</span>
1099 <span class="keyword">end</span>
1100 
1101 mat_ind( remove_simp) = [];
1102 
1103 <span class="comment">% Test code:</span>
1104 <span class="comment">% fmdl.type='fwd_model'; fmdl.nodes = vtx; fmdl.elems =  simp_obj; fmdl.electrode= elec;</span>
1105 
1106 
1107 
1108 <a name="_sub20" href="#_subfunctions" class="code">function [srf,vtx,fc,bc,simp,edg,mat_ind] = ng_remove_electrodes_old</a><span class="keyword">...</span>
1109     (srf,vtx,fc,bc,simp,edg,mat_ind, N_elec)
1110 
1111 <span class="comment">% total objects:</span>
1112 N_obj = max(mat_ind);
1113 
1114 <span class="comment">% The electodes are the last N_elec simps</span>
1115 e_simp_ind = mat_ind &gt; (N_obj - N_elec);
1116 
1117 in = unique(simp(~e_simp_ind,:));
1118 out = unique(simp(e_simp_ind,:));
1119 boundary = intersect(in,out);
1120 out = setdiff(out,boundary);
1121 
1122 ext_srf_ind = ismember(srf,out);
1123 ext_srf_ind = ext_srf_ind(:,1) | ext_srf_ind(:,2) | ext_srf_ind(:,3);
1124 
1125 srf(ext_srf_ind,:) = [];
1126 bc(ext_srf_ind,:) = [];
1127 fc(ext_srf_ind,:) = [];
1128 simp = simp(~e_simp_ind,:);
1129 mat_ind = mat_ind(~e_simp_ind);
1130 
1131 <span class="comment">% fix bc:</span>
1132 n_unique = numel(unique(bc));
1133 missing = setdiff(1:n_unique, unique(bc));
1134 spare = setdiff(unique(bc), 1:n_unique); 
1135 
1136 <span class="keyword">for</span> i = 1:length(missing)
1137     bc( bc==spare(i) ) = missing(i);
1138 <span class="keyword">end</span>
1139 
1140 <span class="comment">% fix vtx:</span>
1141 v = 1:size(vtx,1);
1142 unused_v = setdiff(v, union(unique(simp),unique(srf))); 
1143 v(unused_v) = [];
1144 <span class="keyword">for</span> i = 1:size(vtx,1);
1145 <span class="comment">%     simp_ind = find(simp == i);</span>
1146 <span class="comment">%     srf_ind = find( srf == i);</span>
1147     new_v_ind = find(v == i);
1148     simp( simp == i ) = new_v_ind; 
1149     srf( srf  == i ) = new_v_ind;
1150 <span class="keyword">end</span>
1151 vtx(unused_v,:) = [];
1152 
1153 
1154 <span class="comment">%copied from ng_mk_cyl_model</span>
1155 <a name="_sub21" href="#_subfunctions" class="code">function [mdl2,idx2] = mdl2d_from3d(mdl3,idx3);</a>
1156    <span class="comment">% set name</span>
1157    mdl2 = <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'fwd_model'</span>,sprintf(<span class="string">'%s 2D'</span>,mdl3.name));
1158 
1159    <span class="comment">% set nodes</span>
1160    [bdy,idx] = <a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(mdl3.elems);
1161    vtx = mdl3.nodes;
1162    z_vtx = reshape(vtx(bdy,3), size(bdy) );
1163    lay0  = find( all(z_vtx==0,2) );
1164    bdy0  = bdy( lay0, :);
1165    
1166    vtx0  = unique(bdy0(:));
1167    mdl2.nodes = vtx(vtx0,1:2);
1168 
1169    <span class="comment">% set elems</span>
1170    nmap  = zeros(size(vtx,1),1); nmap(vtx0) = 1:length(vtx0);
1171    bdy0  = reshape(nmap(bdy0), size(bdy0) ); <span class="comment">% renumber to new scheme</span>
1172    mdl2.elems = bdy0;
1173 
1174    <span class="comment">% set boundary</span>
1175    mdl2.boundary = <a href="../../../eidors/algorithms/n_polydorides/find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>( mdl2.elems);
1176 
1177    <span class="comment">% set gnd_node</span>
1178    mdl2.gnd_node = nmap(mdl3.gnd_node);
1179 
1180    <span class="comment">% set material indices</span>
1181    <span class="comment">% TODO: vectorize code</span>
1182    idx2 = {};
1183    idx0  = idx( lay0, :);
1184    <span class="keyword">for</span> i=1:size(idx3,2)
1185      idx2{i} = [];
1186      ii = 1;
1187      <span class="keyword">for</span> j=1:size(idx3{i},1)
1188          idx_tmp = find( idx0==idx3{i}(j) );
1189          <span class="keyword">if</span> not(isempty(idx_tmp))
1190            idx2{i}(ii,1) = idx_tmp(1,1);
1191            ii = ii + 1;
1192          <span class="keyword">end</span>
1193      <span class="keyword">end</span>
1194    <span class="keyword">end</span>
1195    
1196    <span class="comment">% set electrode</span>
1197    <span class="keyword">if</span> isfield(mdl3,<span class="string">'electrode'</span>)
1198      mdl2.electrode = mdl3.electrode;
1199      <span class="keyword">for</span> i=1:length(mdl2.electrode);
1200         enodes = nmap( mdl2.electrode(i).nodes );
1201         enodes(enodes==0) = []; <span class="comment">% Remove 3D layers</span>
1202         mdl2.electrode(i).nodes = enodes(:)';
1203      <span class="keyword">end</span>
1204    <span class="keyword">end</span>
1205 
1206    <span class="comment">% copy other fields</span>
1207    <span class="keyword">if</span> isfield(mdl3,<span class="string">'stimulation'</span>); mdl2.stimulation= mdl3.stimulation; <span class="keyword">end</span>
1208    <span class="comment">%if isfield(mdl3,'solve');       mdl2.solve = mdl3.solve;            end</span>
1209    mdl2.solve = <span class="string">'aa_fwd_solve'</span>; <span class="comment">% FIXME? can't use default np_fwd_solve</span>
1210    <span class="keyword">if</span> isfield(mdl3,<span class="string">'jacobian'</span>);    mdl2.jacobian = mdl3.jacobian;      <span class="keyword">end</span>
1211    <span class="comment">%if isfield(mdl3,'system_mat');  mdl2.system_mat = mdl3.system_mat;  end</span>
1212    mdl2.system_mat = <span class="string">'aa_calc_system_mat'</span>; <span class="comment">% FIXME? can't use default np_calc_system_mat</span>
1213 
1214    <span class="comment">% update cache</span>
1215 <span class="comment">%    mdl2 = eidors_obj('fwd_model',mdl2);</span>
1216 
1217 
1218 
1219 
1220 
1221 
1222 <span class="comment">%%</span>
1223 <a name="_sub22" href="#_subfunctions" class="code">function [fmdl, mat_idx] = do_unit_test</a>
1224 fmdl = [];
1225 mat_idx = [];
1226     a = [
1227    -0.8981   -0.7492   -0.2146    0.3162    0.7935    0.9615    0.6751    0.0565   -0.3635   -0.9745
1228     0.1404    0.5146    0.3504    0.5069    0.2702   -0.2339   -0.8677   -0.6997   -0.8563   -0.4668 ]';
1229 <span class="comment">% [fmdl, mat_idx] = ng_mk_extruded_model({2,{a,0.5*a,0.2*a},1},[16,0,1],[0.01]);</span>
1230 <span class="comment">% load CT2</span>
1231 
1232 <span class="comment">% [fmdl, mat_idx] = ng_mk_extruded_model({150,flipud(trunk),1},[16,0,75],[0.01]);</span>
1233 
1234 <span class="comment">% [fmdl, mat_idx] = ng_mk_extruded_model({2,{trunk/100, lung_heart_dep/100, heart/100},1},[16,1,1],[0.1]);</span>
1235 <span class="comment">% img = mk_image( fmdl, 1);</span>
1236 <span class="comment">%  img.elem_data(mat_idx{2}) = 1.1;</span>
1237 
1238 <span class="comment">% trunk = [    -4    -2     2     4     4     2    -2    -4</span>
1239 <span class="comment">%               2     4     4     2    -2    -4    -4    -2]';</span>
1240 <span class="comment">% heart_lung = [    -2    -1    -0.8  0.8  1     2     2    -2</span>
1241 <span class="comment">%                    1     2     1.8  1.8  2     1    -2    -2]';</span>
1242 <span class="comment">% lung = [    -2    -1    -1  -1  1     2     2    -2</span>
1243 <span class="comment">%             1     2     0   0  2     1    -2    -2]';</span>
1244 <span class="comment">% heart = [    -1    -1     1     1</span>
1245 <span class="comment">%               0     2     2     0]';</span>
1246 
1247 <span class="comment">% [fmdl, mat_idx] = ng_mk_extruded_model({2,{trunk, heart_lung, heart},1},[16,1,1],[0.1]);</span>
1248 
1249 <span class="comment">%  figure, show_fem( fmdl );</span>
1250  
1251 <span class="comment">%%</span>
1252 xx=[
1253   -88.5777  -11.4887    4.6893   49.8963  122.7033  150.3033  195.5103 249.7573 <span class="keyword">...</span>
1254   258.8013  279.7393  304.9623  309.2443  322.0923  337.7963  340.6503 348.2633 <span class="keyword">...</span>
1255   357.3043  358.7333  361.5873  364.9183  365.3943  366.3453  366.3453 365.3943 <span class="keyword">...</span>
1256   362.5393  351.5943  343.5053  326.8513  299.2503  288.3073  264.9923 224.0703 <span class="keyword">...</span>
1257   206.4633  162.6833  106.5313   92.2543   57.5153    7.0733   -8.6297 -42.4167 <span class="keyword">...</span>
1258   -90.9547 -105.7057 -134.2577 -178.0367 -193.2647 -222.7687 -265.5957 -278.9197 <span class="keyword">...</span>
1259  -313.1817 -355.5337 -363.6237 -379.3267 -397.8857 -400.7407 -401.6927 -398.8377 <span class="keyword">...</span>
1260  -395.0307 -384.0867 -368.3837 -363.6247 -351.7277 -334.1217 -328.4117 -314.1357 <span class="keyword">...</span>
1261  -291.2947 -282.7297 -267.0257 -236.5707 -221.8187 -196.5977 -159.4807 -147.5837];
1262 
1263 yy=[
1264  -385.8513 -386.8033 -386.3273 -384.8993 -368.7193 -353.9673 -323.0363 -283.5403 <span class="keyword">...</span>
1265  -274.9743 -254.0363 -225.4843 -217.8703 -187.4153 -140.7813 -124.6013  -86.0573 <span class="keyword">...</span>
1266   -38.4703  -29.4273   -9.9173   21.0137   32.4347   53.3727   83.8257   93.3437 <span class="keyword">...</span>
1267   114.7587  149.0237  161.8717  187.5677  222.3037  231.3447  247.5237  267.5087 <span class="keyword">...</span>
1268   271.3177  277.0297  281.3127  279.4097  274.6507  273.2227  276.5547  284.6447 <span class="keyword">...</span>
1269   295.1127  297.4927  301.7757  304.1557  302.2537  297.4947  287.5017  282.2667 <span class="keyword">...</span>
1270   259.9017  225.6387  213.7427  185.6677  141.4127  125.2337   88.5917   34.8187 <span class="keyword">...</span>
1271    17.6897  -22.2803  -73.6723  -85.0923 -117.9263 -163.6083 -176.4573 -205.9613 <span class="keyword">...</span>
1272  -245.9343 -256.4023 -275.4373 -304.9403 -315.4083 -332.0623 -352.0473 -355.3783];
1273 
1274 a = [xx; yy]';
1275 a = flipud(a);
1276 <span class="comment">% th=linspace(0,2*pi,33)'; th(end)=[];</span>
1277 <span class="comment">% a=[sin(th)*0.3,cos(th)];</span>
1278 
1279 
1280      fmdl = <a href="ng_mk_extruded_model.html" class="code" title="function [fmdl,mat_idx] = ng_mk_extruded_model(shape, elec_pos, elec_shape,extra_ng_code)">ng_mk_extruded_model</a>({300,a,[4,50]},[16,1.11,150],[1]);
1281      figure
1282      <a href="../../../eidors/graphics_matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(fmdl);</pre></div>
<hr><address>Generated on Tue 09-Aug-2011 11:38:31 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>