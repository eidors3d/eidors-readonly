<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mdl_slice_mapper</title>
  <meta name="keywords" content="mdl_slice_mapper">
  <meta name="description" content="MDL_SLICE_MAPPER: map pixels to FEM elements or nodes">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html?eidors/graphics_matlab/mdl_slice_mapper.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html eidors --><!-- menu.html graphics_matlab -->
<h1>mdl_slice_mapper
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function map = mdl_slice_mapper( fmdl, maptype ); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> MDL_SLICE_MAPPER: map pixels to FEM elements or nodes
    map = mdl_slice_mapper( fmdl, levels, maptype );

 USAGE:
 fmdl = fwd_model object
     required fields
   fmdl.mdl_slice_mapper.npx   - number of points in horizontal direction
   fmdl.mdl_slice_mapper.npy   - number of points in vertical 
    or
   fmdl.mdl_slice_mapper.x_pts - vector of points in horizontal direction
   fmdl.mdl_slice_mapper.y_pts - vector of points in vertical

   fmdl.mdl_slice_mapper.level = Vector [1x3] of intercepts
          of the slice on the x, y, z axis. To specify a z=2 plane
          parallel to the x,y: use levels= [inf,inf,2]
 maptype
    for 'elem' map is FEM element nearest the point
    for 'node' map is FEM vertex nearest the point
    for 'nodeinterp' map a npx x npy x (Nd+1) matrix such that for each point i,j
       the nearby nodes are weighted with the corresponding element in the map(i,j).</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG: eidors progress and status messages</li><li><a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li><li><a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>	MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</li><li><a href="../../eidors/models/a_adler/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>	MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</li><li><a href="show_current.html" class="code" title="function quiv = show_current( img, vv )">show_current</a>	SHOW_CURRENT: show current or other quantity defined</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function elem_ptr = mdl_elem_mapper(fwd_model);</a></li><li><a href="#_sub2" class="code">function ninterp_ptr = mdl_nodeinterp_mapper(fwd_model);</a></li><li><a href="#_sub3" class="code">function node_ptr = mdl_node_mapper(fwd_model);</a></li><li><a href="#_sub4" class="code">function NPTR= node_mapper( NODE, ELEM, bdy, x, y);</a></li><li><a href="#_sub5" class="code">function EPTR= img_mapper2(NODE, ELEM, x, y );</a></li><li><a href="#_sub6" class="code">function EPTR= img_mapper2a(NODE, ELEM, npx, npy );</a></li><li><a href="#_sub7" class="code">function EPTR= img_mapper3(NODE, ELEM, x, y );</a></li><li><a href="#_sub8" class="code">function NODE= level_model( fwd_model, level )</a></li><li><a href="#_sub9" class="code">function  [x,y] = grid_the_space( fmdl);</a></li><li><a href="#_sub10" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function map = mdl_slice_mapper( fmdl, maptype );</a>
0002 <span class="comment">% MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</span>
0003 <span class="comment">%    map = mdl_slice_mapper( fmdl, levels, maptype );</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% USAGE:</span>
0006 <span class="comment">% fmdl = fwd_model object</span>
0007 <span class="comment">%     required fields</span>
0008 <span class="comment">%   fmdl.mdl_slice_mapper.npx   - number of points in horizontal direction</span>
0009 <span class="comment">%   fmdl.mdl_slice_mapper.npy   - number of points in vertical</span>
0010 <span class="comment">%    or</span>
0011 <span class="comment">%   fmdl.mdl_slice_mapper.x_pts - vector of points in horizontal direction</span>
0012 <span class="comment">%   fmdl.mdl_slice_mapper.y_pts - vector of points in vertical</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%   fmdl.mdl_slice_mapper.level = Vector [1x3] of intercepts</span>
0015 <span class="comment">%          of the slice on the x, y, z axis. To specify a z=2 plane</span>
0016 <span class="comment">%          parallel to the x,y: use levels= [inf,inf,2]</span>
0017 <span class="comment">% maptype</span>
0018 <span class="comment">%    for 'elem' map is FEM element nearest the point</span>
0019 <span class="comment">%    for 'node' map is FEM vertex nearest the point</span>
0020 <span class="comment">%    for 'nodeinterp' map a npx x npy x (Nd+1) matrix such that for each point i,j</span>
0021 <span class="comment">%       the nearby nodes are weighted with the corresponding element in the map(i,j).</span>
0022 
0023 <span class="comment">% (C) 2006 Andy Adler. License: GPL version 2 or version 3</span>
0024 <span class="comment">% $Id$</span>
0025 
0026 <span class="keyword">if</span> isstr(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'UNIT_TEST'</span>); <a href="#_sub10" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0027 
0028 <span class="keyword">switch</span> maptype
0029   <span class="keyword">case</span> <span class="string">'elem'</span>;       map = <a href="#_sub1" class="code" title="subfunction elem_ptr = mdl_elem_mapper(fwd_model);">mdl_elem_mapper</a>(fmdl);
0030   <span class="keyword">case</span> <span class="string">'node'</span>;       map = <a href="#_sub3" class="code" title="subfunction node_ptr = mdl_node_mapper(fwd_model);">mdl_node_mapper</a>(fmdl);
0031   <span class="keyword">case</span> <span class="string">'nodeinterp'</span>; map = <a href="#_sub2" class="code" title="subfunction ninterp_ptr = mdl_nodeinterp_mapper(fwd_model);">mdl_nodeinterp_mapper</a>(fmdl);
0032   <span class="keyword">otherwise</span>;   error(<span class="string">'expecting maptype = elem or node'</span>);
0033 <span class="keyword">end</span>
0034 
0035 <a name="_sub1" href="#_subfunctions" class="code">function elem_ptr = mdl_elem_mapper(fwd_model);</a>
0036    level= fwd_model.mdl_slice_mapper.level;
0037 
0038    elem_ptr = <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'get-cache'</span>, fwd_model, <span class="string">'elem_ptr'</span>);
0039 
0040    <span class="keyword">if</span> ~isempty(elem_ptr)
0041       <span class="keyword">return</span>;
0042    <span class="keyword">end</span>
0043 
0044    NODE = <a href="#_sub8" class="code" title="subfunction NODE= level_model( fwd_model, level )">level_model</a>( fwd_model, level );
0045    ELEM= fwd_model.elems';
0046    <span class="keyword">if</span> size(NODE,1) ==2 <span class="comment">%2D</span>
0047       [x,y] = <a href="#_sub9" class="code" title="subfunction  [x,y] = grid_the_space( fmdl);">grid_the_space</a>( fwd_model);
0048       elem_ptr= <a href="#_sub5" class="code" title="subfunction EPTR= img_mapper2(NODE, ELEM, x, y );">img_mapper2</a>( NODE, ELEM, x, y);
0049    <span class="keyword">else</span>
0050       fmdl3 = fwd_model; fmdl3.nodes = NODE'; 
0051       [x,y] = <a href="#_sub9" class="code" title="subfunction  [x,y] = grid_the_space( fmdl);">grid_the_space</a>( fmdl3 );
0052       elem_ptr= <a href="#_sub7" class="code" title="subfunction EPTR= img_mapper3(NODE, ELEM, x, y );">img_mapper3</a>( NODE, ELEM, x, y);
0053    <span class="keyword">end</span>
0054 
0055    <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'set-cache'</span>, fwd_model, <span class="string">'elem_ptr'</span>, elem_ptr);
0056    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mdl_slice_mapper: setting cached value'</span>, 3);
0057 
0058 <a name="_sub2" href="#_subfunctions" class="code">function ninterp_ptr = mdl_nodeinterp_mapper(fwd_model);</a>
0059    level= fwd_model.mdl_slice_mapper.level;
0060 
0061    ninterp_ptr = <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'get-cache'</span>, fwd_model, <span class="string">'ninterp_ptr'</span>);
0062    <span class="keyword">if</span> ~isempty(ninterp_ptr); <span class="keyword">return</span>; <span class="keyword">end</span>
0063 
0064 
0065    elem_ptr = <a href="#_sub1" class="code" title="subfunction elem_ptr = mdl_elem_mapper(fwd_model);">mdl_elem_mapper</a>(fwd_model);
0066    NODE = <a href="#_sub8" class="code" title="subfunction NODE= level_model( fwd_model, level )">level_model</a>( fwd_model, level );
0067    fwd_model.nodes = NODE';
0068    [x,y] = <a href="#_sub9" class="code" title="subfunction  [x,y] = grid_the_space( fmdl);">grid_the_space</a>( fwd_model);
0069 
0070    ndims = size(NODE,1);
0071    <span class="keyword">if</span>  ndims == 2;  NODEz = []; <span class="keyword">else</span>; NODEz= 0; <span class="keyword">end</span>
0072    ninterp_ptr = zeros(length(x(:)),ndims+1); <span class="comment">% reshape later</span>
0073 
0074    <span class="keyword">for</span> i= find( elem_ptr(:)&gt;0 )'; <span class="comment">% look for all x,y inside elements</span>
0075      nodes_i = fwd_model.elems(elem_ptr(i),:);
0076      int_fcn = inv( [ones(1,ndims+1);NODE(:,nodes_i)] );
0077      ninterp_ptr(i,:) = ( int_fcn *[1;x(i);y(i);NODEz] )';
0078    <span class="keyword">end</span>
0079    ninterp_ptr = reshape( ninterp_ptr, size(x,1), size(x,2), ndims + 1);
0080 
0081 
0082    <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'set-cache'</span>, fwd_model, <span class="string">'ninterp_ptr'</span>, ninterp_ptr);
0083    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mdl_slice_mapper: setting cached value'</span>, 3);
0084 
0085 <a name="_sub3" href="#_subfunctions" class="code">function node_ptr = mdl_node_mapper(fwd_model);</a>
0086    level= fwd_model.mdl_slice_mapper.level;
0087 
0088    node_ptr = <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'get-cache'</span>, fwd_model, <span class="string">'node_ptr'</span>);
0089 
0090    <span class="keyword">if</span> ~isempty(node_ptr)
0091       <span class="keyword">return</span>;
0092    <span class="keyword">end</span>
0093 
0094    NODE = <a href="#_sub8" class="code" title="subfunction NODE= level_model( fwd_model, level )">level_model</a>( fwd_model, level );
0095    [x,y] = <a href="#_sub9" class="code" title="subfunction  [x,y] = grid_the_space( fmdl);">grid_the_space</a>( fwd_model);
0096    node_ptr= <a href="#_sub4" class="code" title="subfunction NPTR= node_mapper( NODE, ELEM, bdy, x, y);">node_mapper</a>( NODE, fwd_model.elems', fwd_model.boundary, x, y);
0097 
0098    <a href="../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'set-cache'</span>, fwd_model, <span class="string">'node_ptr'</span>, node_ptr);
0099    <a href="../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mdl_slice_mapper: setting cached value'</span>, 3);
0100 
0101 
0102 <span class="comment">% Search through each element and find the points which</span>
0103 <span class="comment">% are in that element</span>
0104 <span class="comment">% NPTR is matrix npx x npy with a pointer to the</span>
0105 <span class="comment">% node closest to it.</span>
0106 <a name="_sub4" href="#_subfunctions" class="code">function NPTR= node_mapper( NODE, ELEM, bdy, x, y);</a>
0107   [npy,npx] = size(x);
0108 
0109   NODEx= NODE(1,:);
0110   NODEy= NODE(2,:);
0111   <span class="keyword">if</span> size(NODE,1) == 2
0112      NODEz2= 0;
0113      bdy= unique(bdy(:));
0114      in = inpolygon(x(:),y(:),NODE(1,bdy)',NODE(2,bdy)');
0115   <span class="keyword">else</span>
0116      NODEz2= NODE(3,:).^2;
0117      <span class="comment">% This is a slow way to get the elems outside the space, but I don't see another</span>
0118      EPTR= <a href="#_sub7" class="code" title="subfunction EPTR= img_mapper3(NODE, ELEM, x, y );">img_mapper3</a>(NODE, ELEM, x, y );
0119      in = EPTR&gt;0;
0120   <span class="keyword">end</span>
0121   NPTR=zeros(npy,npx);
0122 
0123 <span class="comment">% This next operation can be vectorized, but we don't</span>
0124 <span class="comment">%  do it because that can make really big matrices</span>
0125 
0126   <span class="keyword">for</span> i= 1: npy
0127      <span class="keyword">for</span> j= 1: npx
0128         dist2 = (NODEx-x(i,j)).^2 + (NODEy-y(i,j)).^2 + NODEz2;
0129         ff = find(dist2 == min(dist2));
0130         NPTR(i,j) = ff(1);
0131      <span class="keyword">end</span>
0132   <span class="keyword">end</span>
0133   NPTR(~in)= 0; <span class="comment">% outside</span>
0134 
0135 <span class="comment">% Search through each element and find the points which</span>
0136 <span class="comment">% are in that element</span>
0137 <span class="comment">% EPTR is matrix npx x npy with a pointer to the</span>
0138 <span class="comment">% element which contains it.</span>
0139 <a name="_sub5" href="#_subfunctions" class="code">function EPTR= img_mapper2(NODE, ELEM, x, y );</a>
0140   [npy,npx] = size(x);
0141   v_yx= [-y(:) x(:)];
0142   turn= [0 -1 1;1 0 -1;-1 1 0];
0143   EPTR=zeros(npy,npx);
0144   <span class="comment">% for each element j, we get points on the simplex a,b,c</span>
0145   <span class="comment">%   area A = abc</span>
0146   <span class="comment">%   for each candidate point d,</span>
0147   <span class="comment">%      area AA = abd + acd + bcd</span>
0148   <span class="comment">%      d is in j if AA = A</span>
0149   <span class="keyword">for</span> j= 1: size(ELEM,2)
0150     <span class="comment">% calculate area of three subtrianges to each candidate point.</span>
0151     xy= NODE(:,ELEM(:,j))';
0152     <span class="comment">% come up with a limited set of candidate points which</span>
0153     <span class="comment">% may be within the simplex</span>
0154     endr=find( y(:)&lt;=max(xy(:,2)) &amp; y(:)&gt;=min(xy(:,2)) <span class="keyword">...</span>
0155              &amp; x(:)&lt;=max(xy(:,1)) &amp; x(:)&gt;=min(xy(:,1)) );
0156     <span class="comment">% a is determinant of matrix [i,j,k, xy]</span>
0157     a= xy([2;3;1],1).*xy([3;1;2],2)- xy([3;1;2],1).*xy([2;3;1],2);
0158 
0159     aa= sum(abs(ones(length(endr),1)*a'+ <span class="keyword">...</span>
0160                 v_yx(endr,:)*xy'*turn)');
0161     endr( abs( (abs(sum(a))-aa) ./ sum(a)) &gt;1e-8)=[];
0162     EPTR(endr)= j;
0163   <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0164 
0165 <span class="comment">% 2D mapper of points to elements. First, we assume that</span>
0166 <span class="comment">% The vertex geometry (NODE) has been rotated and translated</span>
0167 <span class="comment">% so that the imaging plane is on the z-axis. Then we iterate</span>
0168 <span class="comment">% through elements to find the containing each pixel</span>
0169 <a name="_sub6" href="#_subfunctions" class="code">function EPTR= img_mapper2a(NODE, ELEM, npx, npy );</a>
0170   [x,y] = <a href="#_sub9" class="code" title="subfunction  [x,y] = grid_the_space( fmdl);">grid_the_space</a>(npx, npy);
0171 
0172   EPTR=zeros(npy,npx);
0173   <span class="comment">% for each element j, we get points on the simplex a,b,c</span>
0174   <span class="comment">%   area A = abc</span>
0175   <span class="comment">%   for each candidate point d,</span>
0176   <span class="comment">%      area AA = abd + acd + bcd</span>
0177   <span class="comment">%      d is in j if AA = A</span>
0178   <span class="keyword">for</span> j= 1: size(ELEM,2)
0179     xyz= NODE(:,ELEM(:,j))';
0180     min_x= min(xyz(:,1)); max_x= max(xyz(:,1));
0181     min_y= min(xyz(:,2)); max_y= max(xyz(:,2));
0182 
0183     <span class="comment">% Simplex volume is det([v2-v1,v3-v1, ...])</span>
0184     VOL= abs(det(xyz'*[-1,1,0;-1,0,1]'));
0185 
0186     <span class="comment">% come up with a limited set of candidate points which</span>
0187     <span class="comment">% may be within the simplex</span>
0188     endr=find( y(:)&lt;=max_y &amp; y(:)&gt;=min_y <span class="keyword">...</span>
0189              &amp; x(:)&lt;=max_x &amp; x(:)&gt;=min_x );
0190 
0191     nn=  size(ELEM,1); <span class="comment">%Simplex vertices</span>
0192     ll=  length(endr);
0193     vol=zeros(ll,nn);
0194     <span class="keyword">for</span> i=1:nn
0195        i1= i; i2= rem(i,nn)+1;
0196        x1= xyz(i1,1) - x(endr);
0197        y1= xyz(i1,2) - y(endr);
0198        x2= xyz(i2,1) - x(endr);
0199        y2= xyz(i2,2) - y(endr);
0200        vol(:,i)= x1.*y2 - x2.*y1;  <span class="comment">% determinant</span>
0201     <span class="keyword">end</span>
0202 
0203     endr( sum(abs(vol),2) - VOL &gt;1e-8 )=[];
0204     EPTR(endr)= j;
0205   <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0206 
0207 
0208 <span class="comment">% 3D mapper of points to elements. First, we assume that</span>
0209 <span class="comment">% The vertex geometry (NODE) has been rotated and translated</span>
0210 <span class="comment">% so that the imaging plane is on the z-axis. Then we iterate</span>
0211 <span class="comment">% through elements to find the containing each pixel</span>
0212 <a name="_sub7" href="#_subfunctions" class="code">function EPTR= img_mapper3(NODE, ELEM, x, y );</a>
0213   [npy,npx] = size(x);
0214 
0215   EPTR=zeros(npy,npx);
0216   <span class="comment">% for each element j, we get points on the simplex a,b,c</span>
0217   <span class="comment">%   area A = abc</span>
0218   <span class="comment">%   for each candidate point d,</span>
0219   <span class="comment">%      area AA = abd + acd + bcd</span>
0220   <span class="comment">%      d is in j if AA = A</span>
0221   <span class="keyword">for</span> j= 1: size(ELEM,2)
0222     xyz= NODE(:,ELEM(:,j))';
0223     min_z= min(xyz(:,3)); max_z= max(xyz(:,3));
0224     <span class="keyword">if</span> (min_z&gt;0 || max_z&lt;0)
0225         <span class="keyword">continue</span>;
0226     <span class="keyword">end</span>
0227     min_x= min(xyz(:,1)); max_x= max(xyz(:,1));
0228     min_y= min(xyz(:,2)); max_y= max(xyz(:,2));
0229 
0230     <span class="comment">% Simplex volume is det([v2-v1,v3-v1, ...])</span>
0231     VOL= abs(det(xyz'*[-1,1,0,0;-1,0,1,0;-1,0,0,1]'));
0232 
0233     <span class="comment">% come up with a limited set of candidate points which</span>
0234     <span class="comment">% may be within the simplex</span>
0235     endr=find( y(:)&lt;=max_y &amp; y(:)&gt;=min_y <span class="keyword">...</span>
0236              &amp; x(:)&lt;=max_x &amp; x(:)&gt;=min_x );
0237 
0238     nn=  size(ELEM,1); <span class="comment">%Simplex vertices</span>
0239     ll=  length(endr);
0240     vol=zeros(ll,nn);
0241     <span class="keyword">for</span> i=1:nn
0242        i1= i; i2= rem(i,nn)+1; i3= rem(i+1,nn)+1;
0243        x1= xyz(i1,1)-x(endr); y1= xyz(i1,2)-y(endr); z1= xyz(i1,3);
0244        x2= xyz(i2,1)-x(endr); y2= xyz(i2,2)-y(endr); z2= xyz(i2,3);
0245        x3= xyz(i3,1)-x(endr); y3= xyz(i3,2)-y(endr); z3= xyz(i3,3);
0246        vol(:,i)= x1.*y2.*z3 - x1.*y3.*z2 - x2.*y1.*z3 + <span class="keyword">...</span>
0247                  x3.*y1.*z2 + x2.*y3.*z1 - x3.*y2.*z1;
0248     <span class="keyword">end</span>
0249 
0250     endr( sum(abs(vol),2) - VOL &gt;1e-8 )=[];
0251     EPTR(endr)= j;
0252   <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0253 
0254 
0255 <span class="comment">% Level model: usage</span>
0256 <span class="comment">%   NODE= level_model( fwd_model, level );</span>
0257 <span class="comment">%</span>
0258 <span class="comment">% Level is a 1x3 vector specifying the x,y,z axis intercepts</span>
0259 <span class="comment">% NODE describes the vertices in this coord space</span>
0260 
0261 <a name="_sub8" href="#_subfunctions" class="code">function NODE= level_model( fwd_model, level )</a>
0262 
0263    vtx= fwd_model.nodes;
0264    [nn, dims] = size(vtx);
0265    <span class="keyword">if</span> dims ==2 <span class="comment">% 2D case</span>
0266        NODE= vtx';
0267        <span class="keyword">return</span>;
0268    <span class="keyword">end</span>
0269 
0270    <span class="comment">% Infinities tend to cause issues -&gt; replace with realmax</span>
0271    <span class="comment">% Don't need to worry about the sign of the inf</span>
0272    level( isinf(level) | isnan(level) ) = realmax;
0273    level( level==0 ) =     1e-10; <span class="comment">%eps;</span>
0274 
0275    <span class="comment">% Step 1: Choose a centre point in the plane</span>
0276    <span class="comment">%  Weight the point by it's inv axis coords</span>
0277    invlev= 1./level;
0278    ctr= invlev / sum( invlev.^2 );
0279 
0280    <span class="comment">% Step 2: Choose basis vectors in the plane</span>
0281    <span class="comment">%  First is the axis furthest from ctr</span>
0282    [jnk, s_ax]= sort( - abs(level - ctr) );
0283    v1= [0,0,0]; v1(s_ax(1))= level(s_ax(1));
0284    v1= v1 - ctr;
0285    v1= v1 / norm(v1);
0286 
0287    <span class="comment">% Step 3: Get off-plane vector, by cross product</span>
0288    v2= [0,0,0]; v2(s_ax(2))= level(s_ax(2));
0289    v2= v2 - ctr;
0290    v2= v2 / norm(v2);
0291    v3= cross(v1,v2);
0292 
0293    <span class="comment">% Step 4: Get orthonormal basis. Replace v2</span>
0294    v2= cross(v1,v3);
0295 
0296    <span class="comment">% Step 5: Get bases to point in 'positive directions'</span>
0297    v1= v1 * (1-2*(sum(v1)&lt;0));
0298    v2= v2 * (1-2*(sum(v2)&lt;0));
0299    v3= v3 * (1-2*(sum(v3)&lt;0));
0300 
0301    NODE= [v1;v2;v3] * (vtx' - ctr'*ones(1,nn) );
0302 
0303 <span class="comment">% Create matrices x y which grid the space of NODE</span>
0304 <a name="_sub9" href="#_subfunctions" class="code">function  [x,y] = grid_the_space( fmdl);</a>
0305 
0306   xspace = []; yspace = [];
0307   <span class="keyword">try</span> 
0308      xspace = fmdl.mdl_slice_mapper.x_pts;
0309      yspace = fmdl.mdl_slice_mapper.y_pts;
0310   <span class="keyword">end</span>
0311 
0312   <span class="keyword">if</span> isempty(xspace)
0313      npx  = fmdl.mdl_slice_mapper.npx;
0314      npy  = fmdl.mdl_slice_mapper.npy;
0315 
0316      xmin = min(fmdl.nodes(:,1));    xmax = max(fmdl.nodes(:,1));
0317      xmean= mean([xmin,xmax]); xrange= xmax-xmin;
0318 
0319      ymin = min(fmdl.nodes(:,2));    ymax = max(fmdl.nodes(:,2));
0320      ymean= mean([ymin,ymax]); yrange= ymax-ymin;
0321 
0322      range= max([xrange, yrange]);
0323      xspace = linspace( xmean - range*0.5, xmean + range*0.5, npx );
0324      yspace = linspace( ymean + range*0.5, ymean - range*0.5, npy );
0325   <span class="keyword">end</span>
0326 
0327   [x,y]=meshgrid( xspace, yspace );
0328 
0329 <a name="_sub10" href="#_subfunctions" class="code">function do_unit_test</a>
0330 <span class="comment">% 2D NUMBER OF POINTS</span>
0331    imdl = <a href="../../eidors/models/a_adler/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,8); fmdl = imdl.fwd_model;
0332    fmdl.mdl_slice_mapper.level = [inf,inf,0];
0333    fmdl.mdl_slice_mapper.npx = 5;
0334    fmdl.mdl_slice_mapper.npy = 5;
0335    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0336    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr01'</span>,eptr,[ 0  0 51  0  0; 0 34 26 30  0;
0337                  62 35  4 29 55; 0 36 32 31  0; 0  0 59  0  0]);
0338 
0339    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0340    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr01'</span>,nptr,[ 0  0 28  0  0; 0 14  7 17  0;
0341                  40 13  1  9 32; 0 23 11 20  0; 0  0 36  0  0]);
0342 
0343    nint = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'nodeinterp'</span>);
0344    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nint01a'</span>,nint(2:4,2:4,1),[ 0.8284, 1, 0.8284;1,1,1; 0.8284, 1, 0.8284], 1e-3);
0345 
0346    fmdl.mdl_slice_mapper.npx = 5;
0347    fmdl.mdl_slice_mapper.npy = 3;
0348    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0349    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr02'</span>,eptr,[  0  0 51 0  0;62 35  4 29 55; 0 0 59 0 0]);
0350 
0351    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0352    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr02'</span>,nptr,[ 0 0 28 0 0; 40 13 1 9 32; 0 0 36 0 0 ]);
0353 
0354 <span class="comment">% DIRECT POINT TESTS</span>
0355    imdl = <a href="../../eidors/models/a_adler/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,8); fmdl = imdl.fwd_model;
0356    fmdl.mdl_slice_mapper.level = [inf,inf,0];
0357    fmdl.mdl_slice_mapper.x_pts = linspace(-1,1,5);
0358    fmdl.mdl_slice_mapper.y_pts = [0,0.5];
0359    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0360    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr03'</span>,eptr,[ 62 35 4 29 55; 0 34 26 30 0]);
0361 
0362    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0363    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr03'</span>,nptr,[ 40 13 1 9 32; 0 14 7 17 0]);
0364 
0365 <span class="comment">% 3D NPOINTS</span>
0366    imdl = <a href="../../eidors/models/a_adler/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,8); fmdl = imdl.fwd_model;
0367    fmdl.mdl_slice_mapper.level = [inf,inf,1];
0368    fmdl.mdl_slice_mapper.npx = 4;
0369    fmdl.mdl_slice_mapper.npy = 4;
0370    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0371    test = zeros(4); test(2:3,2:3) = [512 228;524 533];
0372    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr04'</span>,eptr, test);
0373    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0374    test = zeros(4); test(2:3,2:3) = [116 113;118 121];
0375    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr04'</span>,nptr, test);
0376 
0377    fmdl.mdl_slice_mapper.level = [inf,0,inf];
0378    eptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'elem'</span>);
0379    test = zeros(4); test(1:4,2:3) = [ 792 777; 791 776; 515 500; 239 224];
0380    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'eptr05'</span>,eptr,test);
0381 
0382    nptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'node'</span>);
0383    test = zeros(4); test(1:2,:) = [ 80, 124, 122, 64; 17, 61, 59, 1];
0384    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nptr05'</span>,nptr,test);
0385 
0386    nint = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>(fmdl,<span class="string">'nodeinterp'</span>);
0387    <a href="../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'nint05a'</span>,nint(2:3,2:3,1),[0,1;0,1],1e-3);
0388 
0389</pre></div>
<hr><address>Generated on Tue 09-Aug-2011 11:38:31 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>