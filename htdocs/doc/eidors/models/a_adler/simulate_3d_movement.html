<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of simulate_3d_movement</title>
  <meta name="keywords" content="simulate_3d_movement">
  <meta name="description" content="SIMULATE_3D_MOVEMENT simulate rotational movement in 2D">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- # models --><!-- menu.html a_adler -->
<h1>simulate_3d_movement
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>SIMULATE_3D_MOVEMENT simulate rotational movement in 2D</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, mdl_3d, rad_pr,movefcn ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> SIMULATE_3D_MOVEMENT simulate rotational movement in 2D
 [vh,vi,xyzr_pt]= simulate_3d_movement( n_points, model, rad_pr, movefcn )

   rad_pr = [path_radius, target_radius, zmin, zmax]
      values are the fraction of the extent in each dimension
      DEFAULT: [2/3, .05, .1, .9 ]
 
   n_points = number of points to simulate (default = 200)

   model = fwd_model to simulate 
         (default use internal, or if model= []);

   movefcn = 1 (Default)  helical motion where the target starts
     at (rad_pr(1),0) and rotates clockwise moving bottom to top.
   movefcn = 2            radial movement in the vertical plane

   movefcn = FUCN NAME or FUNC HANDLE
      the function must accept the following parameters
      [xp,yp,zp] = movefcn(f_frac, radius, z_bottom,z_top);

 OUTPUT:
   vh - homogeneous measurements            M x 1
   vi - target simulations                  M x n_points
   xyzr_pt - x,y,z and radius of each point 3 x n_points

 For small targets it is more accurate and much faster to
  use the function: simulate_movement.m</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/a_adler/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>	INTERP_MESH: calculate interpolation points onto mdl elements</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG: eidors progress and status messages</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li><li><a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [xp,yp,zp]= helical_path(f_frac, radius, z0,zt);</a></li><li><a href="#_sub2" class="code">function [xp,yp,zp]= radial_path(f_frac, radius, z0,zt);</a></li><li><a href="#_sub3" class="code">function [EPTR, VOL] = img_mapper3a(NODE, ELEM, x,y,z );</a></li><li><a href="#_sub4" class="code">function [radius, rp, zmin, zmax,x,y,z] =</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [vh,vi,xyzr_pt]= simulate_3d_movement( n_sims, mdl_3d, rad_pr,movefcn )</a>
0002 <span class="comment">% SIMULATE_3D_MOVEMENT simulate rotational movement in 2D</span>
0003 <span class="comment">% [vh,vi,xyzr_pt]= simulate_3d_movement( n_points, model, rad_pr, movefcn )</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%   rad_pr = [path_radius, target_radius, zmin, zmax]</span>
0006 <span class="comment">%      values are the fraction of the extent in each dimension</span>
0007 <span class="comment">%      DEFAULT: [2/3, .05, .1, .9 ]</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%   n_points = number of points to simulate (default = 200)</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%   model = fwd_model to simulate</span>
0012 <span class="comment">%         (default use internal, or if model= []);</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%   movefcn = 1 (Default)  helical motion where the target starts</span>
0015 <span class="comment">%     at (rad_pr(1),0) and rotates clockwise moving bottom to top.</span>
0016 <span class="comment">%   movefcn = 2            radial movement in the vertical plane</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%   movefcn = FUCN NAME or FUNC HANDLE</span>
0019 <span class="comment">%      the function must accept the following parameters</span>
0020 <span class="comment">%      [xp,yp,zp] = movefcn(f_frac, radius, z_bottom,z_top);</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% OUTPUT:</span>
0023 <span class="comment">%   vh - homogeneous measurements            M x 1</span>
0024 <span class="comment">%   vi - target simulations                  M x n_points</span>
0025 <span class="comment">%   xyzr_pt - x,y,z and radius of each point 3 x n_points</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% For small targets it is more accurate and much faster to</span>
0028 <span class="comment">%  use the function: simulate_movement.m</span>
0029 
0030 <span class="comment">% (C) 2005-2009 Andy Adler. Licensed under GPL v2 or v3</span>
0031 <span class="comment">% $Id$</span>
0032 
0033 <span class="keyword">if</span> nargin &lt;1
0034    n_sims = 200;
0035 <span class="keyword">end</span>
0036 
0037 <span class="keyword">if</span> nargin&lt;2 || isempty(mdl_3d) <span class="comment">% create our own fmdl</span>
0038    mdl_3d= <a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]); <span class="comment">% NP's demo model</span>
0039    mdl_3d= mdl_3d.fwd_model;
0040 <span class="keyword">end</span>
0041 
0042 <span class="keyword">if</span> nargin&lt;3 || isempty(rad_pr);
0043    rad_pr= [2/3, 0.05, 0.1, 0.9];
0044 <span class="keyword">end</span>
0045 
0046 <span class="keyword">if</span> nargin&lt;4
0047    movefcn = 1;
0048 <span class="keyword">end</span>
0049 <span class="keyword">if</span> isnumeric(movefcn)
0050    <span class="keyword">if</span>     movefcn==1
0051       movefcn = @<a href="#_sub1" class="code" title="subfunction [xp,yp,zp]= helical_path(f_frac, radius, z0,zt);">helical_path</a>;
0052    <span class="keyword">elseif</span> movefcn==2
0053       movefcn = @<a href="#_sub2" class="code" title="subfunction [xp,yp,zp]= radial_path(f_frac, radius, z0,zt);">radial_path</a>;
0054    <span class="keyword">else</span>
0055       error(<span class="string">'value of movefcn not understood'</span>);
0056    <span class="keyword">end</span>
0057 <span class="keyword">else</span>
0058    <span class="comment">% assume movefcn is a function</span>
0059 <span class="keyword">end</span>
0060 
0061 
0062 <span class="keyword">if</span> 0 <span class="comment">% OLD CODE - now use solver provided</span>
0063    mdl_3d.solve=      <span class="string">'np_fwd_solve'</span>;
0064    mdl_3d.system_mat= <span class="string">'np_calc_system_mat'</span>;
0065    mdl_3d.jacobian=   <span class="string">'np_calc_jacobian'</span>;
0066    mdl_3d.misc.perm_sym=   <span class="string">'{n}'</span>;
0067    n_elems= size(mdl_3d.elems,1);
0068 <span class="keyword">end</span>
0069 
0070 
0071 <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'simulate_3d_movement: step #1: homogeneous simulation'</span>,2);
0072 <span class="comment">% create homogeneous image + simulate data</span>
0073 sigma= ones( size(mdl_3d.elems,1) ,1);
0074 img= <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'image'</span>, <span class="string">'homogeneous image'</span>, <span class="keyword">...</span>
0075     <span class="string">'elem_data'</span>, sigma, <span class="keyword">...</span>
0076     <span class="string">'fwd_model'</span>, mdl_3d );
0077 vh = <a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>( img);
0078 
0079 <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'simulate_3d_movement: step #2: find points'</span>,2);
0080 
0081 <span class="keyword">if</span> 0 <span class="comment">% Old Style</span>
0082    npx=128;
0083    npy=128;
0084    npz=64;
0085    [radius,rp,z0,zt,x,y,z] = calc_point_grid(mdl_3d.nodes', rad_pr, npx, npy, npz);
0086 
0087    clear pts;
0088    <span class="keyword">for</span> i=1:n_sims
0089        f_frac= (i-1)/n_sims;
0090 
0091        <span class="comment">% call function to simulate data</span>
0092        [xp,yp,zp]= feval(movefcn, f_frac, radius, z0,zt);
0093 
0094        ff= find( (x(:)-xp).^2 + (y(:)-yp).^2 + (z(:)-zp).^2 &lt;= rp^2 )';
0095        pts{i} = ff;
0096    <span class="keyword">end</span>
0097    pts_all = unique( [pts{:}] );
0098    pts_all = pts_all(:);
0099    <span class="keyword">for</span> i=1:n_sims
0100       [jnk,idx_i]= intersect( pts_all, pts{i});
0101       pts_idx{i}= idx_i;
0102    <span class="keyword">end</span>
0103 
0104    [eptr,vol]= <a href="#_sub3" class="code" title="subfunction [EPTR, VOL] = img_mapper3a(NODE, ELEM, x,y,z );">img_mapper3a</a>(mdl_3d.nodes', mdl_3d.elems',  <span class="keyword">...</span>
0105             x(pts_all), y(pts_all), z(pts_all));
0106 <span class="keyword">else</span>
0107     mdl_pts = <a href="../../../eidors/algorithms/a_adler/interp_mesh.html" class="code" title="function mdl_pts = interp_mesh( mdl, n_interp)">interp_mesh</a>( mdl_3d, 2); <span class="comment">% 10 per elem</span>
0108     x= mdl_pts(:,1,:);
0109     y= mdl_pts(:,2,:);
0110     z= mdl_pts(:,3,:);
0111    [radius,rp,z0,zt] = calc_point_grid(mdl_3d.nodes', rad_pr);
0112 <span class="keyword">end</span>
0113 
0114 target_conductivity= .1;
0115 
0116 <span class="keyword">for</span> i=1:n_sims
0117    <span class="keyword">if</span> rem(i, max( floor(i/10), 10))==1; <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>( <span class="keyword">...</span>
0118        <span class="string">'simulate_3d_movement: step #3 (%d of %d): target simulations'</span>, <span class="keyword">...</span>
0119        i, n_sims, 2); 
0120    <span class="keyword">end</span>
0121    <span class="keyword">if</span> 0
0122       obj_n= sparse( eptr(pts_idx{i}),1,1, n_elems, 1);
0123       img.elem_data= 1 + target_conductivity * obj_n./vol;
0124   <span class="comment">%   show_fem(img); view([-2,84]);pause;</span>
0125    <span class="keyword">else</span>
0126       f_frac= (i-1)/n_sims;
0127       [xp,yp,zp]= feval(movefcn, f_frac, radius, z0,zt);
0128       ff=  (x-xp).^2 + (y-yp).^2 + (z-zp).^2 &lt;= rp^2;
0129       img.elem_data= 1 + target_conductivity * mean(ff,3);
0130    <span class="keyword">end</span>
0131 
0132    xyzr_pt(:,i)= [xp;-yp;zp;rp]; <span class="comment">% -y because images and axes are reversed</span>
0133    vi(i)= <a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>( img );<span class="comment">% measurement</span>
0134 <span class="keyword">end</span>
0135 
0136 vi= [vi(:).meas];
0137 vh= [vh(:).meas];
0138 
0139 <span class="comment">%   movefcn = 1 (Default)  helical motion where the target starts</span>
0140 <span class="comment">%     at (rad_pr(1),0) and rotates clockwise moving bottom to top.</span>
0141 <span class="comment">% calculate x,y,z position of point, given f_frac of path</span>
0142 <a name="_sub1" href="#_subfunctions" class="code">function [xp,yp,zp]= helical_path(f_frac, radius, z0,zt);</a>
0143    xp= radius * cos(f_frac*2*pi);
0144    yp= radius * sin(f_frac*2*pi);
0145    <span class="comment">% object moves from bottow to top</span>
0146    zp = z0 + (zt - z0) * f_frac;
0147 
0148 <span class="comment">%   movefcn = 2            radial movement in the vertical plane</span>
0149 <a name="_sub2" href="#_subfunctions" class="code">function [xp,yp,zp]= radial_path(f_frac, radius, z0,zt);</a>
0150    rp= f_frac*radius; 
0151    cv= 2*pi*f_frac;
0152    xp= rp * cos(cv);
0153    yp= rp * sin(cv);
0154    zp = mean([zt,z0]);
0155 
0156 <span class="comment">% modified img_mapper3 from calc_slices.m</span>
0157 <span class="comment">% this is like tsearch, but doesn't require</span>
0158 <span class="comment">% delaunay triangularization. I also wrote it, so I like it :-)</span>
0159 <a name="_sub3" href="#_subfunctions" class="code">function [EPTR, VOL] = img_mapper3a(NODE, ELEM, x,y,z );</a>
0160    <span class="comment">% calc and see if one point is in one element</span>
0161    elems = size(ELEM,2);
0162 
0163    EPTR= zeros(prod(size(x)),1);
0164    VOL= zeros(elems,1);
0165 
0166    <span class="keyword">for</span> j= 1: elems
0167        <span class="keyword">if</span> rem(j,5000)==0; fprintf(<span class="string">'mapping %d / %d \n'</span>,j,elems); <span class="keyword">end</span>
0168        xyz= NODE(:,ELEM(:,j))';
0169        min_x= min(xyz(:,1)); max_x= max(xyz(:,1));
0170        min_y= min(xyz(:,2)); max_y= max(xyz(:,2));
0171        min_z= min(xyz(:,3)); max_z= max(xyz(:,3));
0172 
0173        <span class="comment">% Simplex relative volume is det([v2-v1,v3-v1, ...])</span>
0174        VOL(j)= abs(det(xyz'*[-1,1,0,0;-1,0,1,0;-1,0,0,1]'));
0175 
0176        xlmax= x&lt;=max_x; <span class="keyword">if</span> ~any(xlmax); <span class="keyword">continue</span>; <span class="keyword">end</span>
0177        xgmin= x&gt;=min_x; <span class="keyword">if</span> ~any(xgmin); <span class="keyword">continue</span>; <span class="keyword">end</span>
0178        ylmax= y&lt;=max_y; <span class="keyword">if</span> ~any(ylmax); <span class="keyword">continue</span>; <span class="keyword">end</span>
0179        ygmin= y&gt;=min_y; <span class="keyword">if</span> ~any(ygmin); <span class="keyword">continue</span>; <span class="keyword">end</span>
0180        zlmax= z&lt;=max_z; <span class="keyword">if</span> ~any(zlmax); <span class="keyword">continue</span>; <span class="keyword">end</span>
0181        zgmin= z&gt;=min_z; <span class="keyword">if</span> ~any(zgmin); <span class="keyword">continue</span>; <span class="keyword">end</span>
0182        <span class="comment">% come up with a limited set of candidate points which</span>
0183        <span class="comment">% may be within the simplex</span>
0184        endr=find( xlmax &amp; xgmin &amp; ylmax &amp; ygmin &amp; zlmax &amp; zgmin);
0185        ll=  prod(size(endr));
0186        <span class="keyword">if</span> isempty(ll);
0187           <span class="keyword">continue</span>;
0188        <span class="keyword">end</span>
0189 
0190        nn=  size(ELEM,1); <span class="comment">%Simplex vertices</span>
0191        vol=zeros(ll,nn);
0192        <span class="keyword">for</span> i=1:nn
0193            i1= i; i2= rem(i,nn)+1; i3= rem(i+1,nn)+1;
0194            x1= xyz(i1,1)-x(endr); y1= xyz(i1,2)-y(endr); z1= xyz(i1,3)-z(endr);
0195            x2= xyz(i2,1)-x(endr); y2= xyz(i2,2)-y(endr); z2= xyz(i2,3)-z(endr);
0196            x3= xyz(i3,1)-x(endr); y3= xyz(i3,2)-y(endr); z3= xyz(i3,3)-z(endr);
0197            vol(:,i)= x1.*y2.*z3 - x1.*y3.*z2 - x2.*y1.*z3 + <span class="keyword">...</span>
0198                x3.*y1.*z2 + x2.*y3.*z1 - x3.*y2.*z1;
0199        <span class="keyword">end</span>
0200 
0201        endr( sum(abs(vol),2) - VOL(j) &gt;1e-8 )=[];
0202        EPTR(endr)= j;
0203    <span class="keyword">end</span> <span class="comment">%for j=1:ELEM</span>
0204 
0205 <a name="_sub4" href="#_subfunctions" class="code">function [radius, rp, zmin, zmax,x,y,z] = </a><span class="keyword">...</span>
0206          calc_point_grid(NODE, rad_pr, npx, npy, npz);
0207 
0208    xmin = min(NODE(1,:));    xmax = max(NODE(1,:));
0209    xmean= mean([xmin,xmax]); xrange= xmax-xmin;
0210 
0211    ymin = min(NODE(2,:));    ymax = max(NODE(2,:));
0212    ymean= mean([ymin,ymax]); yrange= ymax-ymin;
0213 
0214    zmin = min(NODE(3,:));    zmax = max(NODE(3,:));
0215    zmean= mean([zmin,zmax]); zrange= zmax-zmin;
0216 
0217    radius= rad_pr(1)*(xmax-xmin)/2;
0218    rp=     rad_pr(2)*(xmax-xmin)/2;
0219    zmin=   (rad_pr(3)-.5)*zrange + zmean;
0220    zmax=   (rad_pr(4)-.5)*zrange + zmean;
0221 
0222    <span class="keyword">if</span> nargout&lt;=4; <span class="keyword">return</span>; <span class="keyword">end</span>
0223    range= max([xrange, yrange,zrange]);
0224    [x y z]=ndgrid( <span class="keyword">...</span>
0225        linspace( xmean - range*0.5, xmean + range*0.5, npx ), <span class="keyword">...</span>
0226        linspace( ymean + range*0.5, ymean - range*0.5, npy ),<span class="keyword">...</span>
0227        linspace( zmean - zrange*0.5, zmean + zrange*0.5, npz ));</pre></div>
<hr><address>Generated on Wed 13-Jul-2011 23:23:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>