<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_circ_tank</title>
  <meta name="keywords" content="mk_circ_tank">
  <meta name="description" content="MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- # models --><!-- menu.html a_adler -->
<h1>mk_circ_tank
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function param= mk_circ_tank(rings, levels, elec_spec ); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D
 param= mk_circ_tank(rings, levels, elec_spec );
 
 rings:  number of horizontal plane rings (divisible by 4)
 levels: vector of vertical placement of levels
     for 2D mesh, levels = []
 
 elec_spec: parameter to specify number of electrodes
        specified as { 'opt1', val11, val12 , 'opt2', val21, val22 }

 elec_spec = scalar (divisible by 4)
      - puts a single plane of electrodes in centre of cylinder
 eg. elec_spec  = 16

 elec_spec = { 'planes', n_elecs, elec_planes }
      - puts plane each of n_elecs at planes specified by elec_planes
 eg. elec_spec  =  {'planes', 16, [2,6,8]}

 elec_spec = { 'zigzag', n_elecs, elec_planes }
      - puts plane of n_elecs 'zigzagged' electrodes onto planes specified
        1st elec on plane 2, 2nd elec on plane 6, 3rd on plane 2, etc 
 eg. elec_spec  =  {'zigzag', 16, [2,6]}
      - Note, based on the restults of Graham et al (2006), zigzag
        electrode placement is not recommended
      - In order to implement the 'planar3d' pattern from this paper,
        puts 2d electrodes onto rings ie [ ...  7  8  1  2  ...
                                           ... 15 16  9 10  ... ]
      -&gt;use  elec_spec = { 'planes', n_elecs/2, elec_planes }

 mk_circ_tank creates simple, point electrodes. Improved models
  may be created with ng_mk_cyl_models

 output:
  param.name        Model name (if known) 
  param.nodes       position of FEM nodes (Nodes x Dims) 
  param.elems       definition of FEM elements (Elems x Dims+1) 
  param.boundary    nodes of element faces on the medium surface 
  param.gnd_node    Number of node connected to ground 
  param.electrode   Vector (Num_elecs x 1) of electrode models (elec_model)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/examples/cheating_2d.html" class="code" title="function out=cheating_2d( figno, rand_seed )">cheating_2d</a>	code to simulate inverse crimes in EIT</li><li><a href="../../../eidors/examples/demo_2d_simdata.html" class="code" title="">demo_2d_simdata</a>	Example of using EIDORS to simulate 2D data and to</li><li><a href="../../../eidors/examples/demo_3d_simdata.html" class="code" title="">demo_3d_simdata</a>	How to make simulation data using EIDORS3D</li><li><a href="mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="simulate_2d_movement.html" class="code" title="function [vh,vi,xyr_pt]= simulate_2d_movement( n_sims, fmdl, rad_pr, movefcn )">simulate_2d_movement</a>	SIMULATE_2D_MOVEMENT simulate rotational movement in 2D</li><li><a href="../../../eidors/tests/calc_data_prior_test.html" class="code" title="function ok= calc_data_prior_test">calc_data_prior_test</a>	Verify dataprior:</li><li><a href="../../../eidors/tests/calc_jacobian_test.html" class="code" title="function ok= calc_jacobian_test">calc_jacobian_test</a>	Verify Jacobian Calculation by small derivative from forward problem</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function elec_nodes= electrode_pattern( point_elec_nodes, elec_spec )</a></li><li><a href="#_sub2" class="code">function [ELEM, NODE, bdy_nodes, point_elec_nodes, NODE_order] =</a></li><li><a href="#_sub3" class="code">function [ELEM, NODE, BDY, elec_nodes] = mk_3D_model(</a></li><li><a href="#_sub4" class="code">function elec_struct = mk_electrodes( elec_nodes)</a></li><li><a href="#_sub5" class="code">function elem=  node_reorder( elem0, node_order);</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function param= mk_circ_tank(rings, levels, elec_spec );</a>
0002 <span class="comment">%MK_CIRC_TANK: make a cylindrical tank FEM geometry in 2D or 3D</span>
0003 <span class="comment">% param= mk_circ_tank(rings, levels, elec_spec );</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% rings:  number of horizontal plane rings (divisible by 4)</span>
0006 <span class="comment">% levels: vector of vertical placement of levels</span>
0007 <span class="comment">%     for 2D mesh, levels = []</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% elec_spec: parameter to specify number of electrodes</span>
0010 <span class="comment">%        specified as { 'opt1', val11, val12 , 'opt2', val21, val22 }</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% elec_spec = scalar (divisible by 4)</span>
0013 <span class="comment">%      - puts a single plane of electrodes in centre of cylinder</span>
0014 <span class="comment">% eg. elec_spec  = 16</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% elec_spec = { 'planes', n_elecs, elec_planes }</span>
0017 <span class="comment">%      - puts plane each of n_elecs at planes specified by elec_planes</span>
0018 <span class="comment">% eg. elec_spec  =  {'planes', 16, [2,6,8]}</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% elec_spec = { 'zigzag', n_elecs, elec_planes }</span>
0021 <span class="comment">%      - puts plane of n_elecs 'zigzagged' electrodes onto planes specified</span>
0022 <span class="comment">%        1st elec on plane 2, 2nd elec on plane 6, 3rd on plane 2, etc</span>
0023 <span class="comment">% eg. elec_spec  =  {'zigzag', 16, [2,6]}</span>
0024 <span class="comment">%      - Note, based on the restults of Graham et al (2006), zigzag</span>
0025 <span class="comment">%        electrode placement is not recommended</span>
0026 <span class="comment">%      - In order to implement the 'planar3d' pattern from this paper,</span>
0027 <span class="comment">%        puts 2d electrodes onto rings ie [ ...  7  8  1  2  ...</span>
0028 <span class="comment">%                                           ... 15 16  9 10  ... ]</span>
0029 <span class="comment">%      -&gt;use  elec_spec = { 'planes', n_elecs/2, elec_planes }</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% mk_circ_tank creates simple, point electrodes. Improved models</span>
0032 <span class="comment">%  may be created with ng_mk_cyl_models</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% output:</span>
0035 <span class="comment">%  param.name        Model name (if known)</span>
0036 <span class="comment">%  param.nodes       position of FEM nodes (Nodes x Dims)</span>
0037 <span class="comment">%  param.elems       definition of FEM elements (Elems x Dims+1)</span>
0038 <span class="comment">%  param.boundary    nodes of element faces on the medium surface</span>
0039 <span class="comment">%  param.gnd_node    Number of node connected to ground</span>
0040 <span class="comment">%  param.electrode   Vector (Num_elecs x 1) of electrode models (elec_model)</span>
0041 
0042 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0043 <span class="comment">% $Id$</span>
0044 
0045 <span class="keyword">if</span> rem(rings,4) ~= 0
0046    error(<span class="string">'parameter rings and must be divisible by 4'</span>);
0047 <span class="keyword">end</span>
0048 
0049 <span class="comment">% parse easy case of electrode specifications</span>
0050 n_elec= [];
0051 <span class="keyword">if</span> size(elec_spec) == [1,1] <span class="keyword">if</span> isnumeric(elec_spec)
0052    n_elec= elec_spec;
0053 <span class="keyword">end</span>; <span class="keyword">end</span>
0054 
0055 [elem, node, bdy, point_elec_nodes, node_order] = mk_2D_model( rings );
0056 
0057 <span class="keyword">if</span> isempty( levels ) <span class="comment">% 2D</span>
0058    
0059    <span class="keyword">if</span> ~isempty( n_elec )
0060       idx= (0:n_elec-1)*length(point_elec_nodes)/n_elec + 1;
0061       <span class="keyword">if</span> any(rem(idx,1) ~= 0);
0062          error(<span class="string">'The requested number of electrodes is not compatible with this FEM mesh'</span>)
0063       <span class="keyword">end</span>
0064       elec_nodes= point_elec_nodes( idx );
0065    <span class="keyword">else</span>
0066       error(<span class="string">'2D models only support scalar electrode patterns'</span>);
0067    <span class="keyword">end</span>
0068 <span class="keyword">else</span>  <span class="comment">%3D</span>
0069    [elem, node, bdy, point_elec_nodes] = <a href="#_sub3" class="code" title="subfunction [ELEM, NODE, BDY, elec_nodes] = mk_3D_model( ">mk_3D_model</a>( elem, node, <span class="keyword">...</span>
0070                   levels, bdy, point_elec_nodes, node_order );
0071     <span class="comment">% 3D - fixed - don't need this anymore!</span>
0072 <span class="comment">%  bdy= find_boundary(elem')';</span>
0073 
0074    <span class="keyword">if</span> ~isempty( n_elec )
0075       idx= (0:n_elec-1)*length(point_elec_nodes)/n_elec + 1;
0076       half_lev = ceil( length(levels)/2 );
0077       elec_nodes= point_elec_nodes( half_lev, idx );
0078    <span class="keyword">else</span>
0079       elec_nodes= <a href="#_sub1" class="code" title="subfunction elec_nodes= electrode_pattern( point_elec_nodes, elec_spec )">electrode_pattern</a>( point_elec_nodes, elec_spec );
0080    <span class="keyword">end</span>
0081 
0082 <span class="keyword">end</span>
0083 
0084 param.name= sprintf(<span class="string">'EIT FEM by mk_circ_tank with N=%d levs=%d'</span>, <span class="keyword">...</span>
0085                     rings, length(levels) );
0086 param.nodes = node';
0087 param.elems = elem';
0088 param.boundary = bdy';
0089 param.gnd_node = 1; <span class="comment">% node at bottom and center of the tank</span>
0090 param.electrode =  <a href="#_sub4" class="code" title="subfunction elec_struct = mk_electrodes( elec_nodes)">mk_electrodes</a>( elec_nodes );
0091 
0092 <span class="keyword">return</span>;
0093 
0094 <span class="comment">% parse the elec_spec parameter</span>
0095 <span class="comment">% elec_spec = { 'planes', n_elecs, elec_planes }</span>
0096 <span class="comment">%      - puts plane each of n_elecs at planes specified by elec_planes</span>
0097 <span class="comment">% eg. elec_spec  =  {'planes', 16, [2,6,8]}</span>
0098 <span class="comment">%</span>
0099 <span class="comment">% elec_spec = { 'zigzag', n_elecs, elec_planes }</span>
0100 <span class="comment">%      - puts plane of n_elecs 'zigzagged' electrodes onto planes specified</span>
0101 <span class="comment">%        1st elec on plane 2, 2nd elec on plane 6, 3rd on plane 2, etc</span>
0102 <span class="comment">% eg. elec_spec  =  {'zigzag', 16, [2,6]}</span>
0103 <a name="_sub1" href="#_subfunctions" class="code">function elec_nodes= electrode_pattern( point_elec_nodes, elec_spec )</a>
0104    elec_nodes= [];
0105    lpe = size(point_elec_nodes,2);
0106    nlev= size(point_elec_nodes,1);
0107    <span class="keyword">for</span> i=1:3:length(elec_spec)-2
0108       spec = elec_spec{i};
0109       <span class="keyword">if</span>      strcmp( spec,<span class="string">'planes'</span> )
0110           n_elec= elec_spec{i+1};
0111           levs =  elec_spec{i+2};
0112 
0113           eidx= (0:n_elec-1);
0114           idx= round(eidx*lpe/n_elec) + 1;
0115           nodes= point_elec_nodes( levs, idx )';
0116           elec_nodes= [ elec_nodes; nodes(:) ];
0117       <span class="keyword">elseif</span>  strcmp( spec,<span class="string">'zigzag'</span> )
0118           n_elec= elec_spec{i+1};
0119           levs =  elec_spec{i+2};
0120           <span class="keyword">if</span> any(levs &gt; size(point_elec_nodes,1))
0121              error(<span class="string">'requested electrode plane larger than FEModel'</span>);
0122           <span class="keyword">end</span>
0123 
0124           eidx= (0:n_elec-1);
0125           idx= round(eidx*lpe/n_elec)*nlev + <span class="keyword">...</span>
0126                levs( rem( eidx, length(levs))+1);
0127           nodes= point_elec_nodes( idx );
0128           elec_nodes= [ elec_nodes; nodes(:) ];
0129       <span class="keyword">else</span>
0130         error(<span class="string">'elec_spec parameter not understood'</span>);
0131       <span class="keyword">end</span>
0132    <span class="keyword">end</span>
0133 
0134 <span class="comment">% Create a simple 2D regular mesh, based on N circular rings</span>
0135 <span class="comment">%   and n_elec electrodes</span>
0136 <a name="_sub2" href="#_subfunctions" class="code">function [ELEM, NODE, bdy_nodes, point_elec_nodes, NODE_order] =  </a><span class="keyword">...</span>
0137           mk_2D_model( N );
0138   ELEM=[];
0139   NODE= [0;0];
0140   NODE_order= [1];
0141   int=1;
0142   <span class="keyword">for</span> k=1:N
0143     phi= (0:4*k-1)*pi/2/k;
0144     NODE= [NODE k/N*[sin(phi);cos(phi)]];
0145 
0146 <span class="comment">% NODE_order for extruded 3D model      3 1 2 3 1</span>
0147 <span class="comment">%                                     1 2 3 1 2 3</span>
0148     NOq= rem(k+(0:k),3)+1;
0149     NODE_order= [NODE_order, NOq([1:k, k+1:-1:2, 1:k, k+1:-1:2])];
0150 
0151     ext= 2*(k*k-k+1);
0152     idxe=[0:k-1; 1:k];
0153     idxi=[0:k-1]; 
0154     elem= [ ext+idxe, ext+2*k+[-idxe idxe], <span class="keyword">...</span>
0155                      ext+rem(4*k-idxe,4*k), <span class="keyword">...</span>
0156             ext+idxe, ext+2*k+[-idxe idxe], <span class="keyword">...</span>
0157                      ext+rem(4*k-idxe,4*k);
0158             int+idxi, int+2*(k-1)+[-idxi, idxi], <span class="keyword">...</span><span class="comment"> </span>
0159             int+rem(4*(k-1)-idxi, 4*(k-1)+(k==1) ) <span class="keyword">...</span>
0160             ext+4*k+1+idxi, <span class="keyword">...</span>
0161             ext+6*k+ [1-idxi 3+idxi], <span class="keyword">...</span>
0162             ext+8*k+3-idxi ];
0163     <span class="keyword">for</span> j=1:k
0164       r1= rem(j+k-1,3)+1;
0165       r2= rem(j+k,3)+1;
0166       r3= 6-r1-r2;
0167       elem([r1 r2 r3],j+k*(0:7) )= elem(:,j+k*(0:7));
0168     <span class="keyword">end</span>
0169 
0170     ELEM=[ ELEM elem(:,1:(8-4*(k==N))*k) ];
0171     int=ext;
0172   <span class="keyword">end</span> <span class="comment">%for k=1:N</span>
0173 
0174   bdy_nodes= [ (ext  :ext+N*4-1) ; <span class="keyword">...</span>
0175                (ext+1:ext+N*4-1), ext ];
0176   point_elec_nodes= (ext):(ext+N*4-1) ;
0177  
0178 
0179 <span class="comment">% 'extrude' a 2D model defined by ELEM and NODE into a 3D model</span>
0180 <span class="comment">% levels are defined by 'niveaux',</span>
0181 <span class="comment">% 2D parameters are ELEM, NODE, and bdy</span>
0182 <span class="comment">%</span>
0183 <span class="comment">% FIXME: The boundary calculated in 3D is no good. Instead</span>
0184 <span class="comment">%   it needs to be fixed using find_boundary, later</span>
0185 <a name="_sub3" href="#_subfunctions" class="code">function [ELEM, NODE, BDY, elec_nodes] = mk_3D_model( </a><span class="keyword">...</span>
0186      elem0, node0, niveaux, bdy, elec_nodes0, node_order );
0187 
0188   elem0= <a href="#_sub5" class="code" title="subfunction elem=  node_reorder( elem0, node_order);">node_reorder</a>( elem0, node_order);
0189 
0190   d= size(elem0,1);       <span class="comment">%dimentions+1</span>
0191   n= size(node0,2);       <span class="comment">%NODEs</span>
0192   e= size(elem0,2);       <span class="comment">%ELEMents</span>
0193 
0194 <span class="comment">%                   D     U</span>
0195   elem_odd= [elem0([3,2,1,1],:), <span class="keyword">...</span><span class="comment"> % 1 up 1 2 3 down</span>
0196              elem0([3,2,2,1],:), <span class="keyword">...</span><span class="comment"> % 1 2 up 2 3 down </span>
0197              elem0([3,3,2,1],:)];    <span class="comment">% 1 2 3 up 3 down</span>
0198   elem_even=[elem0([1,2,3,3],:), <span class="keyword">...</span><span class="comment"> % 3 up 1 2 3 down</span>
0199              elem0([1,2,2,3],:), <span class="keyword">...</span><span class="comment"> % 3 2 up 2 1 down </span>
0200              elem0([1,1,2,3],:)];    <span class="comment">% 3 2 1 up 1 down</span>
0201 
0202   NODE= [node0; niveaux(1)*ones(1,n) ];
0203   ELEM= [];
0204   bl= size(bdy,2);
0205 <span class="comment">% Interlaced bdy idx</span>
0206 
0207   bdy_order =node_order(bdy);
0208   bdy_up= find(bdy_order&gt;[1;1]*min(bdy_order));
0209   bdy_dn= find(bdy_order&lt;[1;1]*max(bdy_order));
0210   
0211   bdy_odd = [bdy; bdy(bdy_up')];
0212   bdy_even= [bdy; bdy(bdy_dn')];
0213   BDY = [];
0214  
0215   ln= length(niveaux);
0216   <span class="keyword">for</span> k=2:ln
0217     NODE=[NODE  [node0; niveaux(k)*ones(1,n)] ];
0218     <span class="keyword">if</span> rem(k,2)==1
0219         elem= elem_odd;
0220         bdy_e0= bdy_even;
0221         bdy_e1= bdy_odd;
0222     <span class="keyword">else</span>
0223         elem= elem_even;
0224         bdy_e1= bdy_even;
0225         bdy_e0= bdy_odd;
0226     <span class="keyword">end</span>
0227     el_add = (k-2)*n+[[zeros(3,e);n*ones(1,e)], <span class="keyword">...</span>
0228                       [zeros(2,e);n*ones(2,e)], <span class="keyword">...</span>
0229                       [zeros(1,e);n*ones(3,e)]];
0230     ELEM= [ELEM,elem + el_add];
0231     BDY= [BDY, bdy_e0+(k-2)*n+[zeros(2,bl);n*ones(1,bl)], <span class="keyword">...</span>
0232                bdy_e1+(k-2)*n+[n*ones(2,bl);zeros(1,bl)] ];
0233   <span class="keyword">end</span> <span class="comment">%for k</span>
0234 
0235   <span class="comment">% Now add top and bottom boundary</span>
0236   BDY= [elem0, BDY, elem0+n*(ln-1) ];
0237 
0238   <span class="comment">% elec_nodes is all nodes for all layers</span>
0239   elec_nodes= ones(ln,1) * elec_nodes0 + <span class="keyword">...</span>
0240               (0:ln-1)'  * n*ones(1, length(elec_nodes0) );
0241 
0242 
0243 <span class="comment">%param.electrode = mk_electrodes( elec_nodes );</span>
0244 <span class="comment">% Create the electrode structure from elec_nodes</span>
0245 <span class="comment">% Currently implements point electrodes with</span>
0246 <span class="comment">%   contact impedance of near zero.</span>
0247 <a name="_sub4" href="#_subfunctions" class="code">function elec_struct = mk_electrodes( elec_nodes)</a>
0248    <span class="keyword">for</span> i= 1:length( elec_nodes )
0249       elec_struct(i).nodes     = elec_nodes(i);
0250       elec_struct(i).z_contact = 0.001; <span class="comment">% corresponds to 1 ohm</span>
0251    <span class="keyword">end</span>
0252    <span class="comment">% Need to do it this way to be compatible accross versions</span>
0253    <span class="keyword">if</span> ~exist(<span class="string">'elec_struct'</span>);
0254        elec_struct= [];
0255    <span class="keyword">end</span>
0256 
0257 <a name="_sub5" href="#_subfunctions" class="code">function elem=  node_reorder( elem0, node_order);</a>
0258   e= size(elem0,2);       <span class="comment">%ELEMents</span>
0259 
0260   no_test=  node_order(elem0);
0261   no_test=  (0:e-1)'*[3,3,3]+no_test';
0262   elem=     elem0(no_test');
0263 
0264   no_test = node_order(elem);
0265   ok= ~norm(no_test - [1;2;3]*ones(1,e));
0266 
0267   <span class="keyword">if</span> ~ok; error(<span class="string">'test_node_order fails - cant do 3D meshes'</span>); <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 13-Jul-2011 23:23:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>