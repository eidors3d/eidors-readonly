<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mk_GREIT_model</title>
  <meta name="keywords" content="mk_GREIT_model">
  <meta name="description" content="MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html?eidors/models/a_adler/mk_GREIT_model.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html eidors --><!-- # models --><!-- menu.html a_adler -->
<h1>mk_GREIT_model
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach
   [imdl, weight]= mk_GREIT_model( mdl, radius, weight, options )

 Output: 
   imdl   - GREIT inverse model
   weight - value of the weight paramater chosed to satisfy the prescribed
            noise figure (NF). See options.noise_figure below.

 Parameters:
   mdl    - fwd model on which to do simulations, or
          - inv model (experimental), or
          - string specifying prepackaged models

   radius - requested weighting matrix  (recommend 0.25 for 16 electrodes)
   weight - weighting matrix (weighting of noise vs signal). Can be empty
            options.noise_figure is specified
   options- structure with fields:
     imgsz       - [xsz ysz] reconstructed image size in pixels 
                   (default: [32 32])
     Nsim        - number of training points (default: 1000)
     distr       - distribution of training points:
         0 -&gt; original (as per GREITv1, default)
         1 -&gt; random, centre-heavy 
         2 -&gt; random, uniform
         3 -&gt; fixed, uniform (debug)
     target_size - size of simulated targets as proportion of mesh radius
         (default: 0.02). Can be specified as [min_size max_size] for 
         random variation
     target_plane - the (mean) height z at which simulation targets are
         placed. This controls the image plane. Default: mean electrode
         height
     target_offset - maximum allowed vertical displacement from the
         target_plane (default: 0). Can be specified as
         [down_offset up_offset].
     noise_figure - the noise figure (NF) to achieve. Overwrites weight 
         which will be optimised to achieve the target NF.
     extra_noise - extra noise samples (such as electrode movement)

 NOTE
   currently extra_noise is not supported
   currently weighting matrix must be scalar</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/a_adler/calc_GREIT_RM.html" class="code" title="function RM= calc_GREIT_RM(vh,vi, xyc, radius, weight, options)">calc_GREIT_RM</a>	CALCULATE GREIT reconstruction matrix</li><li><a href="../../../eidors/algorithms/a_adler/calc_noise_params.html" class="code" title="function params = calc_noise_params(imdl, vh, vi )">calc_noise_params</a>	params = GREIT_noise_params(imdl, homg_voltage, sig_voltage)</li><li><a href="../../../eidors/algorithms/a_adler/solve_use_matrix.html" class="code" title="function img= solve_use_matrix( inv_model, data1, data2)">solve_use_matrix</a>	SOLVE_USE_MATRIX solve using reconstruction matrix</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG: eidors progress and status messages</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>	EIDORS_OBJ: 'constructor' to create a eidors structure</li><li><a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>	FWD_SOLVE: calculate data from a fwd_model object and an image</li><li><a href="../../../eidors/graphics_matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/graphics_matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li><li><a href="../../../eidors/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>	INV_SOLVE: calculate imag from an inv_model and data</li><li><a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>	FOURIER_FIT: use fourier series to interpolate onto a boundary</li><li><a href="../../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>	NG_MAKE_CYL_MODELS: create cylindrical models using netgen</li><li><a href="../../../eidors/meshing/netgen/ng_mk_ellip_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_ellip_models(ellip_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_ellip_models</a>	NG_MAKE_ELLIP_MODELS: create elliptical models using netgen</li><li><a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>	MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach</li><li><a href="mk_common_gridmdl.html" class="code" title="function inv_mdl= mk_common_gridmdl( str, RM)">mk_common_gridmdl</a>	MK_COMMON_MODEL: make EIT on reconstruction grids (GREIT)</li><li><a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>	MK_STIM_PATTERNS: create an EIDORS stimulation pattern structure</li><li><a href="select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>	SELECT_IMDL: select pre-packaged inverse model features</li><li><a href="simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr );">simulate_movement</a>	SIMULATE_MOVEMENT simulate small conductivity perturbations</li><li><a href="../../../eidors/models/b_grychtol/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft)">mk_library_model</a>	MK_LIBRARY_MODEL - FEM models based on library shapes</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>	MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach</li><li><a href="test_GREIT_model.html" class="code" title="">test_GREIT_model</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [imdl, weight]= mk_GREIT_model_calc( fmdl, imdl, imgs, radius, weight, opt)</a></li><li><a href="#_sub2" class="code">function out = to_optimise(vh,vi,xy,radius,weight, opt, inside, imdl,</a></li><li><a href="#_sub3" class="code">function  imgs = get_prepackaged_fmdls( fmdl );</a></li><li><a href="#_sub4" class="code">function [vi,vh,xy,bound,elec_loc,opt]= stim_targets(imgs, Nsim, opt );</a></li><li><a href="#_sub5" class="code">function z = calc_offset(z0,opt,Nsim)</a></li><li><a href="#_sub6" class="code">function r = calc_radius(R,opt,Nsim)</a></li><li><a href="#_sub7" class="code">function RM = resize_if_reqd(RM,inside);</a></li><li><a href="#_sub8" class="code">function [imdl,fmdl,imgs] = parse_fmdl(fmdl);</a></li><li><a href="#_sub9" class="code">function opt = parse_options(opt,fmdl,imdl);</a></li><li><a href="#_sub10" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )</a>
0002 <span class="comment">% MK_GREIT_MODEL: make EIDORS inverse models using the GREIT approach</span>
0003 <span class="comment">%   [imdl, weight]= mk_GREIT_model( mdl, radius, weight, options )</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Output:</span>
0006 <span class="comment">%   imdl   - GREIT inverse model</span>
0007 <span class="comment">%   weight - value of the weight paramater chosed to satisfy the prescribed</span>
0008 <span class="comment">%            noise figure (NF). See options.noise_figure below.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Parameters:</span>
0011 <span class="comment">%   mdl    - fwd model on which to do simulations, or</span>
0012 <span class="comment">%          - inv model (experimental), or</span>
0013 <span class="comment">%          - string specifying prepackaged models</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%   radius - requested weighting matrix  (recommend 0.25 for 16 electrodes)</span>
0016 <span class="comment">%   weight - weighting matrix (weighting of noise vs signal). Can be empty</span>
0017 <span class="comment">%            options.noise_figure is specified</span>
0018 <span class="comment">%   options- structure with fields:</span>
0019 <span class="comment">%     imgsz       - [xsz ysz] reconstructed image size in pixels</span>
0020 <span class="comment">%                   (default: [32 32])</span>
0021 <span class="comment">%     Nsim        - number of training points (default: 1000)</span>
0022 <span class="comment">%     distr       - distribution of training points:</span>
0023 <span class="comment">%         0 -&gt; original (as per GREITv1, default)</span>
0024 <span class="comment">%         1 -&gt; random, centre-heavy</span>
0025 <span class="comment">%         2 -&gt; random, uniform</span>
0026 <span class="comment">%         3 -&gt; fixed, uniform (debug)</span>
0027 <span class="comment">%     target_size - size of simulated targets as proportion of mesh radius</span>
0028 <span class="comment">%         (default: 0.02). Can be specified as [min_size max_size] for</span>
0029 <span class="comment">%         random variation</span>
0030 <span class="comment">%     target_plane - the (mean) height z at which simulation targets are</span>
0031 <span class="comment">%         placed. This controls the image plane. Default: mean electrode</span>
0032 <span class="comment">%         height</span>
0033 <span class="comment">%     target_offset - maximum allowed vertical displacement from the</span>
0034 <span class="comment">%         target_plane (default: 0). Can be specified as</span>
0035 <span class="comment">%         [down_offset up_offset].</span>
0036 <span class="comment">%     noise_figure - the noise figure (NF) to achieve. Overwrites weight</span>
0037 <span class="comment">%         which will be optimised to achieve the target NF.</span>
0038 <span class="comment">%     extra_noise - extra noise samples (such as electrode movement)</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% NOTE</span>
0041 <span class="comment">%   currently extra_noise is not supported</span>
0042 <span class="comment">%   currently weighting matrix must be scalar</span>
0043               
0044 <span class="comment">% Examples</span>
0045 <span class="comment">%   imdl =  mk_GREIT_model( 'c=1;h=2;r=.08;ce=16;bg=1;st=1;me=1;nd', 0.25, 10);</span>
0046 <span class="comment">% OR</span>
0047 <span class="comment">%   fmdl = mk_library_model('adult_male_16el');</span>
0048 <span class="comment">%   fmdl.stimulation = stim;</span>
0049 <span class="comment">%   fmdl.normalize_measurements = 1;</span>
0050 <span class="comment">%   opt.noise_figure = 0.5;</span>
0051 <span class="comment">%   imdl = mk_GREIT_model(fmdl,0.25,5,opt);</span>
0052 
0053 <span class="comment">% (C) 2010 Andy Adler. License: GPL version 2 or version 3</span>
0054 <span class="comment">% $Id$</span>
0055 
0056 <span class="keyword">if</span> isstr(fmdl) &amp;&amp; strcmp(fmdl,<span class="string">'UNIT_TEST'</span>); <a href="#_sub10" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0057 
0058 <span class="keyword">if</span> nargin &lt; 4, options = [];<span class="keyword">end</span>
0059 [imdl,fmdl,imgs] = <a href="#_sub8" class="code" title="subfunction [imdl,fmdl,imgs] = parse_fmdl(fmdl);">parse_fmdl</a>(fmdl);
0060 options = <a href="#_sub9" class="code" title="subfunction opt = parse_options(opt,fmdl,imdl);">parse_options</a>(options,fmdl,imdl);
0061 
0062 cache_obj= { fmdl, imdl, imgs, radius, weight, options};
0063 
0064 out= <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'get-cache'</span>, cache_obj, <span class="string">'mk_GREIT_model'</span>);
0065 <span class="keyword">if</span> ~isempty(out)
0066    <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mk_GREIT_model: using cached value'</span>, 3);
0067    imdl= out{1}; weight=out{2}; <span class="keyword">return</span>
0068 <span class="keyword">end</span>
0069 [imdl, weight]= <a href="#_sub1" class="code" title="subfunction [imdl, weight]= mk_GREIT_model_calc( fmdl, imdl, imgs, radius, weight, opt)">mk_GREIT_model_calc</a>( fmdl, imdl, imgs, radius, weight, options);
0070 
0071 <a href="../../../eidors/eidors_obj.html" class="code" title="function obj_id= eidors_obj(type,name, varargin );">eidors_obj</a>(<span class="string">'set-cache'</span>, cache_obj, <span class="string">'mk_GREIT_model'</span>, {imdl,weight});
0072 <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mk_GREIT_model: setting cached value'</span>, 3);
0073 
0074 <a name="_sub1" href="#_subfunctions" class="code">function [imdl, weight]= mk_GREIT_model_calc( fmdl, imdl, imgs, radius, weight, opt)</a>
0075 
0076 Nsim = opt.Nsim;
0077 [vi,vh,xy,bound,elec_loc,opt]= <a href="#_sub4" class="code" title="subfunction [vi,vh,xy,bound,elec_loc,opt]= stim_targets(imgs, Nsim, opt );">stim_targets</a>(imgs, Nsim, opt );
0078 
0079 
0080 xgrid = linspace(opt.minnode(1),opt.maxnode(1),opt.imgsz(1)+1);
0081 ygrid = linspace(opt.minnode(2),opt.maxnode(2),opt.imgsz(2)+1);
0082 rmdl = <a href="mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],xgrid,ygrid);
0083 x_avg = conv2(xgrid, [1,1]/2,<span class="string">'valid'</span>);
0084 y_avg = conv2(ygrid, [1,1]/2,<span class="string">'valid'</span>);
0085 [x,y] = ndgrid( x_avg, y_avg);
0086 
0087 <span class="comment">%Calculate rec_model (if absent) and find the inside array</span>
0088 <span class="keyword">if</span> ~isfield(imdl,<span class="string">'rec_model'</span>);
0089  inside = inpolygon(x(:),y(:),bound(:,1),bound(:,2) );
0090  
0091  ff = find(~inside);
0092  rmdl.elems([2*ff, 2*ff-1],:)= [];
0093  rmdl.coarse2fine([2*ff, 2*ff-1],:)= [];
0094  rmdl.coarse2fine(:,ff)= [];
0095  
0096  imdl.rec_model = rmdl;
0097 <span class="keyword">else</span>
0098  <span class="comment">% this assumes the original grid model was created the same way</span>
0099  inside = ismember(rmdl.elems,imdl.rec_model.elems,<span class="string">'rows'</span>);
0100  inside = inside(1:2:end);
0101 <span class="keyword">end</span>
0102 
0103 imdl.solve = @<a href="../../../eidors/algorithms/a_adler/solve_use_matrix.html" class="code" title="function img= solve_use_matrix( inv_model, data1, data2)">solve_use_matrix</a>;
0104 log_level = <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>( <span class="string">'log_level'</span>, 1);
0105 
0106 <span class="keyword">if</span> ~isempty(opt.noise_figure)
0107     target = opt.noise_figure;
0108     <span class="keyword">if</span> ~isempty(weight)
0109         <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mk_GREIT_model: Using weight parameter as a guess, options.noise_figure is non-empty'</span>);
0110     <span class="keyword">else</span>
0111         weight = target;
0112     <span class="keyword">end</span>
0113 
0114     xyzr = mean(fmdl.nodes);
0115     xyzr(3) = opt.target_plane;
0116     xyzr(4) = opt.target_size;
0117     [jnk,vi_NF] = <a href="simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr );">simulate_movement</a>(imgs,xyzr');
0118     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mk_GREIT_model: Finding noise weighting for given Noise Figure'</span>,1);
0119     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mk_GREIT_model: This will take a while...'</span>,1);
0120     f = @(X) <a href="#_sub2" class="code" title="subfunction out = to_optimise(vh,vi,xy,radius,weight, opt, inside, imdl, ">to_optimise</a>(vh,vi,xy, radius, X, opt, inside, imdl, target, vi_NF);
0121     fms_opts.TolFun = 0.01*target; <span class="comment">%don't need higher accuracy</span>
0122     [weight, NF] = fminsearch(f, weight);
0123     <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'mk_GREIT_model: Optimal solution gives NF='</span> <span class="keyword">...</span><span class="comment"> </span>
0124         num2str(NF+target) <span class="string">' with weight='</span> num2str(weight)],1);
0125 <span class="keyword">end</span>
0126 <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>( <span class="string">'log_level'</span>, log_level);
0127 RM= <a href="../../../eidors/algorithms/a_adler/calc_GREIT_RM.html" class="code" title="function RM= calc_GREIT_RM(vh,vi, xyc, radius, weight, options)">calc_GREIT_RM</a>(vh,vi, xy, radius, weight, opt );
0128 imdl.solve_use_matrix.RM = <a href="#_sub7" class="code" title="subfunction RM = resize_if_reqd(RM,inside);">resize_if_reqd</a>(RM,inside);
0129 <span class="comment">%imdl.solve_use_matrix.map = inside;</span>
0130 
0131 <a name="_sub2" href="#_subfunctions" class="code">function out = to_optimise(vh,vi,xy,radius,weight, opt, inside, imdl, </a><span class="keyword">...</span>
0132     target,vi_NF)
0133 
0134    <span class="comment">% calculate GREIT matrix as usual</span>
0135    RM = <a href="../../../eidors/algorithms/a_adler/calc_GREIT_RM.html" class="code" title="function RM= calc_GREIT_RM(vh,vi, xyc, radius, weight, options)">calc_GREIT_RM</a>(vh,vi,xy, radius, weight, opt);
0136    imdl.solve_use_matrix.RM = <a href="#_sub7" class="code" title="subfunction RM = resize_if_reqd(RM,inside);">resize_if_reqd</a>(RM,inside);
0137    NF = <a href="../../../eidors/algorithms/a_adler/calc_noise_params.html" class="code" title="function params = calc_noise_params(imdl, vh, vi )">calc_noise_params</a>(imdl,vh, vi_NF);
0138    <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'NF = '</span>, num2str(NF), <span class="string">' weight = '</span>, num2str(weight)],1);
0139    out = (NF - target)^2;
0140 <span class="comment">%    out = (mean(NF) - target)^2 + std(NF);</span>
0141    
0142 <a name="_sub3" href="#_subfunctions" class="code">function  imgs = get_prepackaged_fmdls( fmdl );</a>
0143   <span class="keyword">switch</span> fmdl
0144     <span class="keyword">case</span> <span class="string">'c=1;h=2;r=.08;ce=16;bg=1;st=1;me=1;nd'</span>
0145       fmdl = <a href="../../../eidors/meshing/netgen/ng_mk_cyl_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_cyl_models(cyl_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_cyl_models</a>([2,1,0.18],[16,1],[0.05]); 
0146       fmdl.stimulation = <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(16,1,[0,1],[0,1],{},1);
0147       fmdl.normalize_measurements = 1;
0148       imgs= <a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>( fmdl, 1);
0149     <span class="keyword">otherwise</span>
0150       error(<span class="string">'specified fmdl (%s) is not understood'</span>, fmdl);
0151   <span class="keyword">end</span>
0152 
0153 <a name="_sub4" href="#_subfunctions" class="code">function [vi,vh,xy,bound,elec_loc,opt]= stim_targets(imgs, Nsim, opt );</a>
0154     fmdl = imgs.fwd_model;
0155    ctr =  mean(fmdl.nodes);  
0156    maxx = max(abs(fmdl.nodes(:,1) - ctr(1)));
0157    maxy = max(abs(fmdl.nodes(:,2) - ctr(2)));
0158 
0159    <span class="comment">% Calculate the position of the electrodes</span>
0160    Nelecs = length(imgs.fwd_model.electrode);
0161    <span class="keyword">for</span> i=1:Nelecs
0162        enodesi =     imgs.fwd_model.electrode(i).nodes;
0163        elec_loc(i,:) = mean( imgs.fwd_model.nodes( enodesi,:),1 );
0164    <span class="keyword">end</span>
0165    
0166    <span class="keyword">if</span> opt.target_plane == 1i
0167        opt.target_plane = mean(elec_loc(:,3));
0168    <span class="keyword">end</span>
0169    
0170    <span class="comment">% calculate the boundary (for external use)</span>
0171    F = <a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(elec_loc(:,1:2));
0172    v = linspace(0,1,100+1); v(end)=[];
0173    bound = <a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(F,v);
0174 
0175    
0176    <span class="keyword">switch</span> opt.distr 
0177        <span class="keyword">case</span> 0 <span class="comment">% original</span>
0178            r = linspace(0,0.9, Nsim);
0179            th = r*4321; <span class="comment">% want object to jump around in radius</span>
0180            xyzr = [maxx*r.*cos(th); maxy*r.*sin(th); 
0181                opt.target_plane*ones(1,Nsim);
0182                0.05/mean([maxx,maxy])*ones(1,Nsim)];
0183        
0184        <span class="keyword">case</span> 1 <span class="comment">%centre-heavy</span>
0185            <span class="comment">% Now, use elec_loc to figure out the shape. We can assume the obj is</span>
0186            <span class="comment">% extruded in z</span>
0187            F = <a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(elec_loc(:,1:2));
0188            v = linspace(0,1,Nsim*100+1); v(end)=[];
0189            pts = <a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(F,v);
0190            idx_p = floor(rand(Nsim,1)*Nsim*100);
0191            xyzr = pts(idx_p,:)'.*repmat(rand(Nsim,1),[1 2])';
0192            xyzr(3,:) = <a href="#_sub5" class="code" title="subfunction z = calc_offset(z0,opt,Nsim)">calc_offset</a>(opt.target_plane,opt,Nsim);
0193            
0194            <span class="comment">% TODO: What size is good here and how to figure it out?</span>
0195            xyzr(4,:) = <a href="#_sub6" class="code" title="subfunction r = calc_radius(R,opt,Nsim)">calc_radius</a>(mean([maxx maxy]),opt,Nsim);
0196        <span class="keyword">case</span> 2 <span class="comment">%uniform</span>
0197            F = <a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(elec_loc(:,1:2));
0198            v = linspace(0,1,101); v(end)=[];
0199            pts = <a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(F,v);
0200            <span class="comment">% avoid edges</span>
0201            pts = 0.9*( pts - repmat(ctr(1:2),length(pts),1) ) + repmat(ctr(1:2),length(pts),1);
0202            <span class="comment">% using maxx and maxy below would in general not produce a</span>
0203            <span class="comment">% uniform distribution</span>
0204            lim = max(maxx, maxy);
0205            x = ctr(1) + (rand(Nsim*10,1)-0.5)*2*lim;
0206            y = ctr(2) + (rand(Nsim*10,1)-0.5)*2*lim;
0207            IN = inpolygon(x,y,pts(:,1),pts(:,2));
0208            xyzr(1,:) = x(find(IN,Nsim));
0209            xyzr(2,:) = y(find(IN,Nsim));
0210            xyzr(3,:) = <a href="#_sub5" class="code" title="subfunction z = calc_offset(z0,opt,Nsim)">calc_offset</a>(opt.target_plane,opt,Nsim);
0211            <span class="comment">% TODO: What size is good here and how to figure it out?</span>
0212            xyzr(4,:) = <a href="#_sub6" class="code" title="subfunction r = calc_radius(R,opt,Nsim)">calc_radius</a>(mean([maxx maxy]),opt,Nsim);
0213        <span class="keyword">case</span> 3 <span class="comment">% uniform, non-random</span>
0214            F = <a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(elec_loc(:,1:2));
0215            v = linspace(0,1,101); v(end)=[];
0216            pts = <a href="../../../eidors/meshing/netgen/fourier_fit.html" class="code" title="function C = fourier_fit(points,N,start);">fourier_fit</a>(F,v);
0217            lim = max(maxx, maxy);
0218            frac = polyarea(pts(:,1),pts(:,2)) / (2*lim)^2;
0219            [x,y] = ndgrid( linspace(-lim,lim,ceil(sqrt(Nsim/frac))), <span class="keyword">...</span>
0220                            linspace(-lim,lim,ceil(sqrt(Nsim/frac))));
0221                       
0222            x = x+ctr(1); y = y + ctr(2);    
0223            IN = inpolygon(x,y,pts(:,1),pts(:,2));
0224            xyzr(1,:) = x(find(IN));
0225            xyzr(2,:) = y(find(IN));
0226            xyzr(3,:) = <a href="#_sub5" class="code" title="subfunction z = calc_offset(z0,opt,Nsim)">calc_offset</a>(opt.target_plane,opt,size(xyzr,2));
0227            <span class="comment">% TODO: What size is good here and how to figure it out?</span>
0228            xyzr(4,:) = <a href="#_sub6" class="code" title="subfunction r = calc_radius(R,opt,Nsim)">calc_radius</a>(mean([maxx maxy]),opt,size(xyzr,2));
0229            <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'mk_GREIT_model: Using '</span> num2str(size(xyzr,2)) <span class="string">' points'</span>]);
0230    <span class="keyword">end</span>
0231    before = size(xyzr,2);
0232    [vh,vi,xyzr] = <a href="simulate_movement.html" class="code" title="function [vh,vi,xyzr,c2f]= simulate_movement( img, xyzr );">simulate_movement</a>(imgs, xyzr);
0233    after = size(xyzr,2);
0234    <span class="keyword">if</span>(after~=before)
0235        <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>([<span class="string">'mk_GREIT_model: Now using '</span> num2str(after) <span class="string">' points'</span>]);
0236    <span class="keyword">end</span>
0237    xy = xyzr(1:2,:);
0238 
0239 <a name="_sub5" href="#_subfunctions" class="code">function z = calc_offset(z0,opt,Nsim)</a>
0240     <span class="keyword">if</span> opt.random_offset
0241         l_bnd = opt.target_offset(1);
0242         width = sum(opt.target_offset(1:2));
0243         z = z0 - l_bnd + rand(Nsim,1)*width;
0244     <span class="keyword">else</span>
0245         z = z0*ones(Nsim,1);
0246     <span class="keyword">end</span>
0247 
0248 <a name="_sub6" href="#_subfunctions" class="code">function r = calc_radius(R,opt,Nsim)</a>
0249    <span class="keyword">if</span> opt.random_size
0250        min_sz = opt.target_size(1);
0251        max_sz = opt.target_size(2);
0252        range = max_sz - min_sz;
0253        r = (min_sz + rand(Nsim,1)*range)*R;
0254    <span class="keyword">else</span>
0255        r = opt.target_size(1)*ones(Nsim,1)*R;
0256    <span class="keyword">end</span>
0257            
0258    
0259    
0260 <a name="_sub7" href="#_subfunctions" class="code">function RM = resize_if_reqd(RM,inside);</a>
0261    szRM = size(RM,1);
0262    <span class="keyword">if</span> sum(inside) == szRM
0263       <span class="comment">% RM is fine</span>
0264    <span class="keyword">elseif</span> size(inside,1) == szRM
0265       RM = RM(inside,:);
0266    <span class="keyword">else</span>
0267       error(<span class="string">'mismatch in size of provided RecMatrix'</span>);
0268    <span class="keyword">end</span>
0269 
0270 
0271 <a name="_sub8" href="#_subfunctions" class="code">function [imdl,fmdl,imgs] = parse_fmdl(fmdl);</a>
0272    imdl = []; 
0273    <span class="keyword">if</span> isstr(fmdl)
0274       imgs = <a href="#_sub3" class="code" title="subfunction  imgs = get_prepackaged_fmdls( fmdl );">get_prepackaged_fmdls</a>( fmdl );
0275       fmdl = imgs.fwd_model;
0276    <span class="keyword">elseif</span> isfield(fmdl,<span class="string">'type'</span>);
0277      <span class="keyword">switch</span> fmdl.type
0278    <span class="comment">%  if we get a fwd_model, assume uniform conductivity backgnd of 1</span>
0279        <span class="keyword">case</span> <span class="string">'fwd_model'</span>; imgs = <a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>( fmdl, 1);
0280    <span class="comment">%  if we get an image, use it. It may have a non-uniform backgnd</span>
0281        <span class="keyword">case</span> <span class="string">'image'</span>;     imgs = fmdl; <span class="comment">% fmdl was an image</span>
0282                          fmdl = imgs.fwd_model; <span class="comment">% now it's a fmdl</span>
0283        <span class="keyword">case</span> <span class="string">'inv_model'</span>; imdl = fmdl;
0284                          fmdl = imdl.fwd_model;
0285                          imgs = <a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>( fmdl, 1);
0286        <span class="keyword">otherwise</span>; error(<span class="string">'unrecognized eidors object'</span>);
0287      <span class="keyword">end</span>
0288    <span class="keyword">else</span>
0289       error(<span class="string">'specified parameter must be an object or a string'</span>);
0290    <span class="keyword">end</span>
0291    <span class="comment">% Prepare model</span>
0292    <span class="keyword">if</span> isempty(imdl)
0293       imdl = <a href="select_imdl.html" class="code" title="function inv_mdl= select_imdl( mdl, options )">select_imdl</a>( fmdl,{<span class="string">'Basic GN dif'</span>});
0294    <span class="keyword">end</span>
0295 
0296 <a name="_sub9" href="#_subfunctions" class="code">function opt = parse_options(opt,fmdl,imdl);</a>
0297     
0298     maxnode = max(fmdl.nodes); minnode = min(fmdl.nodes);
0299     opt.maxnode = maxnode;     opt.minnode = minnode; 
0300     
0301     <span class="keyword">if</span> ~isfield(opt, <span class="string">'imgsz'</span>),     opt.imgsz = [32 32]; <span class="keyword">end</span>
0302     <span class="comment">% Allow imdl.rec_model to overwrite options.imgsz</span>
0303     <span class="keyword">if</span> isfield(imdl,<span class="string">'rec_model'</span>) &amp;&amp; ~isempty(imdl.rec_model)
0304         <span class="comment">% this assumes rec_model is a rectangular grid, as it should</span>
0305         opt.imgsz(1) = numel(unique(imdl.rec_model.nodes(:,1)))-1;
0306         opt.imgsz(2) = numel(unique(imdl.rec_model.nodes(:,2)))-1;
0307     <span class="keyword">end</span>  
0308     
0309     <span class="keyword">if</span> ~isfield(opt, <span class="string">'distr'</span>),     opt.distr = 3;       <span class="keyword">end</span> 
0310     <span class="keyword">if</span> ~isfield(opt, <span class="string">'Nsim'</span> ),     opt.Nsim  = 1000;    <span class="keyword">end</span>
0311     <span class="keyword">if</span> ~isfield(opt, <span class="string">'noise_figure'</span>), opt.noise_figure = []; <span class="keyword">end</span>
0312     <span class="keyword">if</span> isfield(opt,<span class="string">'extra_noise'</span>)
0313       error(<span class="string">'mk_GREIT_model: doesn''t currently support extra_noise'</span>);
0314     <span class="keyword">end</span>
0315     <span class="keyword">if</span> ~isfield(opt, <span class="string">'target_size'</span>)
0316         opt.target_size = 0.02;
0317     <span class="keyword">end</span>
0318     <span class="keyword">if</span> sum(size(opt.target_size)) &gt; 2
0319         <span class="keyword">if</span> opt.target_size(1) == opt.target_size(2);
0320             opt.random_size = false;
0321         <span class="keyword">else</span>
0322             opt.random_size = true;
0323         <span class="keyword">end</span>
0324     <span class="keyword">end</span>
0325     <span class="keyword">if</span> sum(size(opt.target_size)) == 2
0326             opt.random_size = false;
0327     <span class="keyword">end</span>
0328     
0329     <span class="keyword">if</span> ~isfield(opt, <span class="string">'target_plane'</span>)
0330         opt.target_plane = 1i;
0331     <span class="keyword">else</span>
0332         t = opt.target_plane;
0333         <span class="keyword">if</span> t&lt;minnode(3) || t&gt;maxnode(3)
0334             warning(<span class="string">'options.target_plane is outside the model!'</span>);
0335             <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mk_GREIT_model: Resorting to default target_plane'</span>);
0336             opt.target_plane = 1i;
0337         <span class="keyword">end</span>
0338     <span class="keyword">end</span>
0339     <span class="keyword">if</span> ~isfield(opt, <span class="string">'target_offset'</span>)
0340         opt.target_offset = 0;
0341     <span class="keyword">end</span>
0342     <span class="keyword">if</span> sum(size(opt.target_offset)) == 2
0343         <span class="keyword">if</span> opt.target_offset &lt; 0, opt.target_offset = 0; <span class="keyword">end</span>
0344         opt.target_offset(2) = opt.target_offset(1);
0345     <span class="keyword">end</span>
0346     <span class="keyword">if</span> any(opt.target_offset &gt; 0)
0347         opt.random_offset = true;
0348     <span class="keyword">else</span>
0349         opt.random_offset = false;
0350     <span class="keyword">end</span>
0351 
0352     <span class="keyword">try</span>, opt.normalize = fmdl.normalize_measurements;
0353     <span class="keyword">catch</span>, 
0354         opt.normalize = 0;
0355         <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'mk_GREIT_model: fmdl.normalize_measurements not specified, assuming 0'</span>);
0356     <span class="keyword">end</span>
0357     opt.meshsz = [minnode(1) maxnode(1) minnode(2) maxnode(2)];
0358 
0359 <a name="_sub10" href="#_subfunctions" class="code">function do_unit_test</a>
0360 <span class="comment">% Create a 3D elliptical cylinder with 16 circular electrodes</span>
0361 fmdl_1= <a href="../../../eidors/meshing/netgen/ng_mk_ellip_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_ellip_models(ellip_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_ellip_models</a>([1,1.2,0.8],[16,0.5],[0.1]); <span class="comment">%show_fem(fmdl);</span>
0362 <span class="comment">% Put two balls into the elliptical cylinder</span>
0363 extra={<span class="string">'ball'</span>,<span class="string">'solid ball = sphere(0.5,0.5,0.5;0.1) or sphere(0.5,-0.5,0.5;0.1);'</span>};
0364 [fmdl_2,mat_idx]= <a href="../../../eidors/meshing/netgen/ng_mk_ellip_models.html" class="code" title="function [fmdl,mat_idx] = ng_mk_ellip_models(ellip_shape, elec_pos,elec_shape, extra_ng_code);">ng_mk_ellip_models</a>([1,1.2,0.8],[16,0.5],[0.1],extra); 
0365 <span class="comment">% Set the model to use adjacent current patterns</span>
0366 stim = <a href="mk_stim_patterns.html" class="code" title="function [stim, meas_sel]= mk_stim_patterns(n_elec, n_rings, inj, meas, options, amplitude)">mk_stim_patterns</a>(16,1,[0,1],[0,1],{}); 
0367 fmdl_1.stimulation = stim;
0368 fmdl_2.stimulation = stim;
0369 <span class="comment">% Simulate homogeneous voltages (background conductivity = 0.5);</span>
0370 img = <a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>(fmdl_2, 0.5); vh = <a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>(img); <span class="comment">%show_fem(img);</span>
0371 <span class="comment">% Simulate inhomogeneous voltages (ball conductivity = 1.0);</span>
0372 img.elem_data(mat_idx{2})= 1.0; vi = <a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>(img); 
0373 <a href="../../../eidors/graphics_matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(img);
0374 <span class="comment">% Reconstruct the image using GREITv1</span>
0375 imdl= <a href="mk_common_gridmdl.html" class="code" title="function inv_mdl= mk_common_gridmdl( str, RM)">mk_common_gridmdl</a>(<span class="string">'GREITc1'</span>); 
0376 img= <a href="../../../eidors/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh,vi);
0377 figure, <a href="../../../eidors/graphics_matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels )">show_slices</a>(img)
0378 
0379 <span class="comment">% Create a GREIT model for the ellipse</span>
0380 opt.noise_figure = 0.5; opt.distr = 3; <span class="comment">%other options are defaults</span>
0381 fmdl_2.normalize_measurements = 0;
0382 <span class="comment">% use the true model (inverse crime)</span>
0383 imdl1 = <a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>(<a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>(fmdl_2,0.5), 0.25, [], opt);
0384 img1= <a href="../../../eidors/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl1,vh,vi); 
0385 
0386 <span class="comment">% use honogenous model</span>
0387 fmdl_1.normalize_measurements = 0;
0388 imdl2 = <a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>(<a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>(fmdl_1,0.5), 0.25, [], opt);
0389 img2= <a href="../../../eidors/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl2,vh,vi); 
0390 
0391 <span class="comment">%% repeat with normalized data</span>
0392 fmdl_2.normalize_measurements = 1;
0393 <span class="comment">% use the true model (inverse crime)</span>
0394 imdl3 = <a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>(<a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>(fmdl_2,0.5), 0.25, [], opt);
0395 img3= <a href="../../../eidors/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl3,vh,vi); 
0396 
0397 <span class="comment">% use honogenous model</span>
0398 fmdl_1.normalize_measurements = 1;
0399 imdl4 = <a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>(<a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>(fmdl_1,0.5), 0.25, [], opt);
0400 img4= <a href="../../../eidors/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl4,vh,vi); 
0401 
0402 figure
0403 <a href="../../../eidors/graphics_matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels )">show_slices</a>([img1 img2 img3 img4])
0404 
0405 
0406 <span class="comment">%% Use a prepackaged model</span>
0407 fmdl = <a href="../../../eidors/models/b_grychtol/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft)">mk_library_model</a>(<span class="string">'adult_male_16el_lungs'</span>);
0408 fmdl.stimulation = stim;
0409 fmdl.normalize_measurements = 1;
0410 img = <a href="../../../eidors/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, name)">mk_image</a>(fmdl,1);
0411 img.elem_data([fmdl.mat_idx{2}; fmdl.mat_idx{3}],1) = 0.3;
0412 vh = <a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>(img);
0413 img.elem_data([fmdl.mat_idx{2}; fmdl.mat_idx{3}],1) = 0.4;
0414 vi = <a href="../../../eidors/fwd_solve.html" class="code" title="function data = fwd_solve( fwd_model, img)">fwd_solve</a>(img);
0415 
0416 
0417 fmdl2 = <a href="../../../eidors/models/b_grychtol/mk_library_model.html" class="code" title="function out = mk_library_model(shape,elec_pos,elec_shape,maxsz,nfft)">mk_library_model</a>(<span class="string">'adult_male_16el'</span>);
0418 fmdl2.stimulation = stim;
0419 fmdl2.normalize_measurements = 1;
0420 imdl = <a href="mk_GREIT_model.html" class="code" title="function [imdl, weight]= mk_GREIT_model( fmdl, radius, weight, options )">mk_GREIT_model</a>(fmdl2,0.25,3,opt);
0421 
0422 img = <a href="../../../eidors/inv_solve.html" class="code" title="function img = inv_solve( inv_model, data1, data2)">inv_solve</a>(imdl,vh, vi);
0423 figure
0424 <a href="../../../eidors/graphics_matlab/show_slices.html" class="code" title="function out_img= show_slices( img, levels )">show_slices</a>(img);
0425 
0426 
0427</pre></div>
<hr><address>Generated on Tue 09-Aug-2011 11:38:31 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>