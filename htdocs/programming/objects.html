<HTML><BODY>
<html>
   <head>
<title>EIDORS-3D</title>
   <style type="text/css">
        body, td, th {
        font-family: Verdana, Helvetica, Arial, sans-serif;
        font-size:80%;
        }
        pre, tt {
        font-family:lucida console, FixedSys, Courier, Terminal, monospaced;
        font-size:100%;
        }
   </style>

</head>

<body link="#800000"
      marginwidth=5 marginheight=5 topmargin=5 leftmargin=5 
      vlink="#400000" >
<table border="0" cellspacing="0" cellpadding="0"><tr><td>
<img alt="Eidors-logo" src="../eidors-logo.jpg">&nbsp;&nbsp; &nbsp;
</td><td>
<h2>
    EIDORS-3D:
    <small><i>Electrical Impedance Tomography and
    Diffuse Optical Tomography Reconstruction Software</i></small>
</h2>
</td></tr></table>
<table border="0"> <tr>
<td valign="top">
<a href="http://www.eidors.org/" >EIDORS</a><br>
<a href="../index.html" >Main</a><br>
<a href="../docs.html" >Documentation</a><br>
<a href="../screenshot.html" >Screenshots</a><br>
<a href="http://sourceforge.net/projects/eidors3d/"
   >Download</a><br>
<a href="http://cvs.sourceforge.net/viewcvs.py/eidors3d/"
   >Browse CVS</a><br>
<hr>
<a href="../news.html">News</a><br>
<a href="../faq.html">FAQ</a><br>
<a href="../programming.html">Developer</a><br>
<a href="../programming/examples.html" >&minus; Examples</a><br>
<a href="../programming/structure.html">&minus; Structure</a><br>
<a href="../programming/objects.html"  >&minus; Objects</a><br>
<a href="../programming/caching.html"  >&minus; Caching</a><br>
<a href="../paper-cheating/cheating-with-eidors.html"
                                    >&minus; Cheating</a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
</td><td>&nbsp;</td><td valign="top">

<h2>EIDORS-3D: Programming / Objects</h2>

In order to clarify the operation of EIDORS, variables are
packaged in to eidors objects. This page describes
each EIDORS object and its members and methods.

<p>
In terms of design choices for EIDORS:<br>
    &minus; We avoid an OO framework because
    1) Matlab's OO framework sucks,
    2) Too much OO is bad for project clarity

    <br>&minus; Instead, we use a structure for each
       important object in the system
       <br>&minus; Each structure will have data elements,
       as well as function "pointers" (the name of a function)
       which will be used. For example, consider
       this code:
<pre>
  my_model.nodes= ... % add data here
  my_model.elems= ... % add data here
  my_model.jacobian= "my_jac_calc_function";
  jj= calc_jacobian( my_model, ...
                conductivites); % calls my_jac_calc_function
</pre>


<H3>EIDORS Objects Reference</H3>
    <ul>
      <p><li><b>
        data
      </b><br>
      A data object represents one set of measurement data. It is a
      collection of all measurements for each stimulation pattern.
      While not simultaneous, we conceptually represent this as
      representing the conductivity distribution at an instant.
      It is invisaged that data converter software be written to
      load from the various hardware systems into this format.
      <ul>
        <b>Properties</b>:
        <li><tt>data.name
        </tt> &nbsp; &nbsp;
        <i>string</i>
        name of data (or empty string)
        <li><tt>data.meas
        </tt> &nbsp; &nbsp;
        <i>vector</i> (Num_meas &times; 1)
        actual measured data, ordered as measurements for each
        stimulation pattern
        <li><tt>data.time
        </tt> &nbsp; &nbsp;
        <i>scalar</i>
        measurement start time in seconds since the epoch, 0=unknown.
        In Matlab this is given by <tt>time</tt>.
        <li><tt>data.comment
        </tt> &nbsp; &nbsp;
        <i>string</i>
        comments on this measurement
        <li><tt>data.meas_config
        </tt> &nbsp; &nbsp;
        <i>EIDORS3D configuration structure</i>
        <b>meas_config</b>
        common to all measurements with
        the same configuration
        <p><b>Methods</b>:
        None
      </ul>

      <p><li><b>
          meas_config
      </b><br>
      this structure represents a given measurement configuration.
      This would be created by a data reading function as it loads
      the data from a file (or gets the input directly from the
      hardware)
      <ul>
        <b>Properties</b>:
        <li><tt>meas_config.name
        </tt> &nbsp; &nbsp;
        <i>string</i>
        name of measurement configuration (or empty string)

        <li><tt>meas_config.units
        </tt> &nbsp; &nbsp;
        <i>string</i>
        measurement units (ie. volts)

        <li><tt>meas_config.subject
        </tt> &nbsp; &nbsp;
        <i>string</i>
        description of subject (or empty string)

        <li><tt>meas_config.electrodes
        </tt> &nbsp; &nbsp;
        <i>vector</i> (Num_elec &times; 1)
        vector of descripions of electrodes, where each electrode has

        <ul>
            <li><tt>electrode(index).position
            </tt> &nbsp; &nbsp;
            <i>vector</i> (x,y,z) position of centre of electrode
            in units of <i>mm</i>

            <li><tt>electrode(index).diameter
            </tt> &nbsp; &nbsp;
            <i>scalar</i> diameter of electrode in <i>mm</i>

            <li><tt>electrode(index).diameter
            </tt> &nbsp; &nbsp;
            <i>scalar</i> diameter of electrode in <i>mm</i>

            <li><tt>electrode(index).z_contact
            </tt> &nbsp; &nbsp;
            contact impedance (in &Omega;) may be complex
        </ul>

        <li><tt>meas_config.stimulation
        </tt> &nbsp; &nbsp;
        <i>vector</i> (Num_stim &times; 1)
        stimulation patterns <b>stim_model</b>

        <p><b>Methods</b>:
        None
      </ul>

      <p><li><b>
        fwd_model
      </b><br>
      <ul>
        <b>Properties</b>:
        <li><tt>fwd_model.name
        </tt> &nbsp; &nbsp;
        Model name (if known)
        <li><tt>fwd_model.nodes
        </tt> &nbsp; &nbsp;
        position of FEM nodes (<i>Nodes</i>&times;<i>Dims</i>)
        <li><tt>fwd_model.elems
        </tt> &nbsp; &nbsp;
        definition of FEM elements (<i>Elems</i>&times;<i>Dims+1</i>)
        <br>Currently defined only for simplex element shapes
        (i.e. each element had dimentions + 1 nodes)
        <li><tt>fwd_model.boundary
        </tt> &nbsp; &nbsp;
        nodes of element faces on the medium surface
        <li><tt>fwd_model.gnd_node
        </tt> &nbsp; &nbsp;
        Number of node connected to ground
        <li><tt>fwd_model.electrode
        </tt> &nbsp; &nbsp;
        Vector <i>(Num_elecs &times;1)</i>
           of electrode models (<b>elec_model</b>)
        <li><tt>fwd_model.stimulation
        </tt> &nbsp; &nbsp;
        Vector <i>(Num_Stim &times;1)</i> of stimulation
        patterns (<b>stim_model</b>) (current in EIT)
        <li><tt>fwd_model.dimention
        </tt> &nbsp; &nbsp;
        2D, 3D, etc.
        <li><tt>fwd_model.normalize_measurements
        </tt> &nbsp; &nbsp;
        Do we do difference (v<sub>i</sub>&minus;v<sub>h</sub>) or
        normalized difference
        <li><tt>fwd_model.meas_select
        </tt> &nbsp; &nbsp;
        measurement reduction (when not measuring on injection
           electrodes, while given full data set)
 (v<sub>i</sub>&minus;v<sub>h</sub>)/v<sub>h</sub>?

        <p><b>Methods</b>:
        <li><tt>fwd_model.solve
        </tt> &nbsp; &nbsp;
        Calculate data object:
        <br>
        <i>usage:</i><tt>
          data = fwd_solve( fwd_model, image )
        </tt>

        <li><tt>fwd_model.jacobian
        </tt> &nbsp; &nbsp;
        <i>usage:</i><tt>
          data = jacobian( fwd_model, image )
        </tt>

        <li><tt>fwd_model.image_prior
        </tt> &nbsp; &nbsp;
        <i>usage:</i><tt>
          data = image_prior( fwd_model, image )
        </tt>

        <li><tt>fwd_model.data_prior
        </tt> &nbsp; &nbsp;
        <i>usage:</i><tt>
          data = data_prior( fwd_model, image )
        </tt>
      </ul>

      <p><li><b>
        elec_model
      </b><br>
      <ul>
        <b>Properties</b>:
        <li><tt>elec_model.name
        </tt> &nbsp; &nbsp;
        Electrode name (optional)

        <li><tt>elec_model.z_contact
        </tt> &nbsp; &nbsp;
        contact impedance (in &Omega;) may be complex

        <li><tt>elec_model.nodes
        </tt> &nbsp; &nbsp;
        nodes to which this electrode is attached

        <p><b>Methods</b>:
        None
      </ul>

      <p><li><b>
        stim_model
      </b><br>
      <ul>
model of a stimulation pattern and accociated measurements
<br>
        <b>Properties</b>:
        <li><tt>stim_model.name
        </tt> &nbsp; &nbsp;
        Stimulation name (optional)

        <li><tt>stim_model.stimulation
        </tt> &nbsp; &nbsp;
        Quantity stimulated (mA) in EIT, light in DOT
        <li><tt>stim_model.stim_pattern
        </tt> &nbsp; &nbsp;
        Quantity of stimulation on each electrode
        <i>(Num_elecs&times;1)</i>
        in units of <tt>.stimulation</tt>
        <br>
        <li><tt>stim_model.meas_pattern
        </tt> &nbsp; &nbsp;
        Measurements pattern for this stimulation
        <i>(Num_meas&times;Num_elecs)</i>.
        This is a sparse matrix of the contribution of
        each electrode to the measurement.
        <p><b>Methods</b>:
        None
      </ul>

      <p><li><b>
        inv_model
      </b><br>
      <ul>
        <i>Note all properties are required for all inv_models</i>
        <br>
        <b>Properties</b>:
        <li><tt>inv_model.name
        </tt> &nbsp; &nbsp;
        Model name (if known)
        <li><tt>inv_model.hyperparameter.func
        </tt> &nbsp; &nbsp;
        function to call to set hyperparameter value
        <li><tt>inv_model.hyperparameter.value
        </tt> &nbsp; &nbsp;
            specified value of hyperparameter (if 
            <tt>inv_model.hyperparameter.func</tt> doesn't exist)
        <li><tt>inv_model.image_prior.func
        </tt> &nbsp; &nbsp;
        function to calculate image prior
        <li><tt>inv_model.image_prior.parameters
        </tt> &nbsp; &nbsp;
        parameters to <tt>inv_model.image_prior.func</tt>
        <li><tt>inv_model.term_tolerance
        </tt> &nbsp; &nbsp;
        termination tolerance (or array of parameters)
        <li><tt>inv_model.iterations
        </tt> &nbsp; &nbsp;
        <li><tt>inv_model.type
        </tt> &nbsp; &nbsp;
        'differential' or 'static'
        <li><tt>inv_model.fwd_model
        </tt> &nbsp; &nbsp;
        pointer to fwd_model

        <p><b>Methods</b>:
        <li><tt>inv_model.solve
        </tt> &nbsp; &nbsp;
        Calculate image object:
        <br>
        <i>usage:</i><tt>
          image = inv_solve( model_static, data )
          <br><i>or</i>
          image = inv_solve( model_diff, data_1, data_2 )
        </tt>
      </ul>

      <p><li><b>
        image
      </b><br>
      <ul>
        <b>Properties</b>:
        <li><tt>image.name
        </tt> &nbsp; &nbsp;
        name of image (optional)
        <li><tt>image.elem_data
        </tt> &nbsp; &nbsp;
        data for each element
        <li><tt>image.type
        </tt> &nbsp; &nbsp;
        real, complex, tensor?
        <li><tt>image.fwd_model
        </tt> &nbsp; &nbsp;
        pointer to fwd_model
        <li><tt>image.inv_model
        </tt> &nbsp; &nbsp;
        pointer to inv_model

        <p><b>Methods</b>:
        None
      </ul>

    </ul>
</td></tr></table>
<p>
<small>
    Last Modified: $Date: 2005-10-18 13:18:13 $ by $Author: aadler $
</small>
</BODY></HTML>
<!--
      <p><li><b>
      </b><br>
      <ul>
      </ul>
      <i>Questions</i>:
      <br>&minus;

      -->
